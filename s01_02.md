class: center, up

# Conceptes Avan莽ats de Programaci贸

![:scale 50%](figures/lambda.png)

**Jordi Delgado**, **Gerard Escudero**,

**Curs 2024-25**: Sessions 1 i 2

![:scale 40%](figures/fib50anysUPC.png)

---

# Conceptes Avan莽ats de Programaci贸

## Expressions, avaluaci贸, valors

Un programa funcional (no trivial) est format d'**_expressions_**, que s'**_avaluen_**, i retornen un **_valor_**.

Si aquest programa est escrit en un llenguatge funcional _pur_ (p.ex. Haskell), aix貌 茅s tot. En canvi
si el llenguatge de programaci贸 no 茅s funcional pur (p.ex. Clojure), aquestes expressions poden tenir
_side effects_.

Hi ha expressions que es poden considerar _constants_, 茅s a dir, valors l'avaluaci贸 dels quals 
茅s precisament ells mateixos:

.cols5050[
.col1[
```Clojure
$ clj
Clojure 1.11.4
user=> 
(require '[clojure.math :as math])
nil
user=> 
math/PI
3.141592653589793
user=> 
2356785874320357840840324758576859043N
2356785874320357840840324758576859043N
user=>
```
]
.col2[
```Clojure
user=> 
1567843
1567843
user=> 
\t
\t
user=> 
:clau
:clau
user=> 
true
true
```
]]

---

# Conceptes Avan莽ats de Programaci贸

## Expressions, avaluaci贸, valors

En general, per貌, una **_expressi贸_** `(f e1 e2 ... eN)` en Clojure t茅 la forma d'una **_llista_**.red[*],  on:

* L'expressi贸 `f` 茅s una **_funci贸_**, un **_s铆mbol_** que s'avalui en una funci贸, 
  una [**_special form_**](https://clojure.org/reference/special_forms) o el nom d'una **_macro_**.
  
* Si l'expressi贸 `f` 茅s una **_funci贸_** o un **_s铆mbol_** que
  s'avalua en una funci贸, el resultat d'aquesta avaluaci贸 茅s un
  **_valor-funci贸_**, que anomenarem `fv`. Les expressions `e1 e2 ...
  eN` s'avaluen i resulten en valors `v1 v2 ... vN`. En aquest cas, el
  resultat de l'expressi贸 茅s l'aplicaci贸 del valor-funci贸 sobre els valors que es passen com a arguments:
  `fv(v1 v2 ... vN)`.

* Si l'expressi贸 `f` 茅s una [**_special
  form_**](https://clojure.org/reference/special_forms) o el nom d'una
  **_macro_**, els arguments no tenen per qu猫 avaluar-se i cal veure com es defineix
  l'**_special form_** o la macro en q眉esti贸.
  
.footnote[.red[*] Veurem les llistes de seguida, de moment penseu-hi com un contenidor d'elements entre par猫ntesi]

---

# Conceptes Avan莽ats de Programaci贸

## Expressions, avaluaci贸, valors

* Si l'expressi贸 `f` 茅s una **_funci贸_** o un **_s铆mbol_** que
  s'avalua en una funci贸, el resultat d'aquesta avaluaci贸 茅s un
  **_valor-funci贸_**, que anomenarem `fv`. Les expressions `e1 e2 ...
  eN` s'avaluen i resulten en valors `v1 v2 ... vN`. En aquest cas, el
  resultat de l'expressi贸 茅s l'aplicaci贸 del valor-funci贸 sobre els valors que es passen com a arguments:
  `fv(v1 v2 ... vN)`.

Per exemple,

```Clojure
$ clj
Clojure 1.11.4 
user=> 
(+ 10 20 30 40) ;; el s铆mbol '+' s'avalua en el valor-funci贸 de la funci贸 de suma
100
user=> 
(+ 1)
1
user=> 
(+)
0
user=> 
(max (+ 3 4) (* (- 4 2) (+ 8 10)) 10) ;; altres expressions com a arguments
36
user=> 
```

---

# Conceptes Avan莽ats de Programaci贸

## Expressions, avaluaci贸, valors

* Si l'expressi贸 `f` 茅s una [**_special
  form_**](https://clojure.org/reference/special_forms) o el nom d'una
  **_macro_**, els arguments no tenen per qu猫 avaluar-se i cal veure com es defineix
  l'**_special form_** o la macro en q眉esti贸.

Exemple: La **_special form_** `def`. 

Per lligar (_bind_) valors a noms (s铆mbols) fem servir la _special form_ `def`.

`(def s (max (+ 23 10) (- 100 85)))` lliga el s铆mbol `s` al valor `33`. Podem veure que 
`def` avalua el seu segon argument, per貌 <ins>NO</ins> avalua el primer argument, 
que ha de ser un s铆mbol.

Est pensat per modificar s铆mbols _globals_, i usualment no modificarem un lligam creat amb `def`.

Al s铆mbol creat amb `def` se'l coneix com a **var**, i _no 茅s el mateix que una variable_ (tal i com 
les entenem en altres llenguatges de programaci贸).

---

# Conceptes Avan莽ats de Programaci贸

## Expressions, avaluaci贸, valors

A Clojure tenim **Nombres** (enters, reals, tamb茅 tenim fraccions), **Carcters** (notaci贸 `\a`), **Booleans**,
**_keywords_** (notaci贸 `:s`), **s铆mbols** i **_strings_** (que tamb茅 s贸n col路leccions).

Operacions _habituals_ on la seva funcionalitat 茅s (m茅s o menys) 貌bvia: `+`, `-`, `*`, `/`, `quot`, `rem`, `mod`, `inc`, `dec`,
 `=`, `not=`, `<`, `<=`, `>`, `>=`, `zero?`, `pos?`, `neg?`, `number?`, `min`, `max`, `not`, `and`, `or`, `print`,
 `println`, `char`, `keyword`, `keyword?`, `str`, `subs`, `string?`

**Exercici**: Obriu un _repl_ de Clojure i feu-les servir. Exploreu.

.cols5050[
.col1[
```Clojure
$ clj
Clojure 1.11.4
user=> 
(- 10 9 8)
-7
user=> 
(/ 100 10 2)
5
user=> 
(number? "no")
false
user=> 
```
]
.col2[
```Clojure
$ clj
Clojure 1.11.4
user=>
(def v 7)
#'user/v
user=> 
(inc v)
8
user=> 
v
7
user=>
```
]]

---

# Conceptes Avan莽ats de Programaci贸

## Expressions, avaluaci贸, valors

Hem vist que les expressions s贸n llistes, per貌 les llistes s贸n un dels contenidors que podem fer servir
a Clojure. La **_Llista_** no 茅s m茅s que una col路lecci贸 d'elements en un ordre determinat, delimitada entre par猫ntesi:

.cols5050[
.col1[
`(1 2 3 4)` -- Llista amb `1`, `2`, `3`, `4`

`(\a "pep" 2 3.141592)` -- Elements de diferents tipus

`()` -- Llista buida
]
.col2[
`(def tt 2.781)` -- Una expressi贸 茅s una llista

`(max 34 -23 1)` -- Una expressi贸 茅s una llista

]]

**Homoiconicitat**: Un programa Clojure 茅s una expressi贸 i una llista, per tant 茅s tamb茅 un valor, o una dada, de Clojure.
_Code is Data_

---

# Conceptes Avan莽ats de Programaci贸

## Expressions, avaluaci贸, valors

Aleshores, **com distingeix Clojure entre una llista que nom茅s cont茅 dades i una expressi贸?**

```Clojure
(def x (\a "pep" 2 3.141592))  Execution error
(max 34 -23 1)                 34
```
Quan Clojure troba una llista **sempre l'avalua com si fos una expressi贸**. Si volem que una llista no 
s'avalui com una expressi贸 **cal dir-ho expl铆citament** amb `quote`:

```Clojure
(def x (quote (\a "pep" 2 3.141592))) 
x   (\a "pep" 2 3.141592)
```

Com que `quote` es fa servir molt sovint, tenim una manera d'abreujar-ho:

```Clojure
(def x '(\a "pep" 2 3.141592)) 
x   (\a "pep" 2 3.141592)
```

El carcter `'` fa el mateix paper que la _special form_ `quote`

---

# Conceptes Avan莽ats de Programaci贸

## Estructures de Control Condicionals

**Important!**: <ins>**Les estructures de control tamb茅 s贸n expressions**</ins> 

Tenim:

* `(if bool-expr  expr-true   expr-false)` - `if` 茅s una _special form_ (tamb茅 existeix la macro `if-not`).

* `(when bool-expr expr)` - `when` i `when-not` s贸n macros definides en termes d'`if`.

* Les macros `when-let` i `if-let` (en parlarem m茅s endavant).

* L'expressi贸 condicional m茅s general 茅s la macro `cond`:
    ```Clojure
    (cond 
       bool-expr expr 
       bool-expr expr 
       ... 
       bool-expr expr)
    ```

**Important!**: Nom茅s `false` i `nil` s贸n _falsy_. La resta de valors s贸n _truthy_.

---

# Conceptes Avan莽ats de Programaci贸

## Funcions: Funcions an貌nimes, l'_special form_ `fn`

Fem servir l'_special form_ `fn` per definir funcions an貌nimes:

```Clojure
;;   parmetres   cos de la funci贸
;;   ----------   ----------------  
(fn [p1 p2 ... pN] expr1 ... exprM)
```
Poden haver $M$ expressions, per貌 **el valor de retorn de la funci贸 茅s la darrera expressi贸 avaluada** 
(no hi ha `return`).

Per exemple:

```Clojure
(def valor_absolut (fn [x] ((if (> x 0) + -) x)))
(valor_absolut 234)   234
(valor_absolut -234)  234

(def que-fer (fn [temp] (cond
                          (> temp 30) "Em quedo a casa amb l'aire acondicionat"
                          (> temp 15) "Me'n vaig a fer un caf茅"
                          :else "Em quedo al llit")))            
(que-fer 31)  "Em quedo a casa amb l'aire acondicionat"
(que-fer 25)  "Me'n vaig a fer un caf茅"
(que-fer 10)  "Em quedo al llit"
```
---

# Conceptes Avan莽ats de Programaci贸

## Funcions: Funcions an貌nimes, notaci贸 abreujada `#(...)`

Podem escriure les funcions an貌nimes amb una notaci贸 molt m茅s c貌mode d'utilitzar. De fet, ho farem servir sovint: 

`#(cos de la funci贸)`

I els parmetres? Dins el cos de la funci贸 podem fer refer猫ncia als arguments que passem dins la crida a la funci贸 amb la notaci贸:

`%1`, `%2`, etc.  Si nom茅s n'hi ha un, podem fer servir `%`

Per exemple:

```Clojure
(def valor_absolut #((if (> % 0) + -) %) )
(valor_absolut 234)   234
(valor_absolut -234)  234

(def que-fer #(cond (> % 30) "Em quedo a casa amb l'aire acondicionat"
                    (> % 15) "Me'n vaig a fer un caf茅"
                    :else "Em quedo al llit") )
(que-fer 31)  "Em quedo a casa amb l'aire acondicionat"
(que-fer 25)  "Me'n vaig a fer un caf茅"
(que-fer 10)  "Em quedo al llit"
```
---

# Conceptes Avan莽ats de Programaci贸

## Funcions: La macro `defn` (I)

Existeix una macro, `defn` amb la que podem definir funcions de manera m茅s compacta:

```Clojure
;;                                       parmetres     cos de la funci贸
;;                                       ----------     ----------------
(defn nom-de-funci贸 "Comentari textual" [p1 p2 ... pN]   expr1 ... exprM )
```

Aquesta 茅s la manera en que habitualment definirem funcions. Per exemple:

```Clojure
(defn valor_absolut "Calcula |x|" [x] ((if (> x 0) + -) x))

(valor_absolut 234)   234
(valor_absolut -234)  234

(defn que-fer [temp] (cond
                       (> temp 30) "Em quedo a casa amb l'aire acondicionat"
                       (> temp 15) "Me'n vaig a fer un caf茅"
                       :else "Em quedo al llit"))
                       
(que-fer 31)  "Em quedo a casa amb l'aire acondicionat"
(que-fer 25)  "Me'n vaig a fer un caf茅"
(que-fer 10)  "Em quedo al llit"
```



---

# Conceptes Avan莽ats de Programaci贸

## Funcions: La macro `defn` (II)

Amb `defn` tamb茅 podem definir funcions d'_aritats m煤ltiples_, 茅s a dir, funcions amb diferent nombre de parmetres.

Per exemple:

```Clojure
(defn producte
   "Retorna 1, el parmetre o el producte depenent del nombre de parmetres"
   ([] 1)
   ([x] x)
   ([x y] (* x y)))
   
(producte)             1                                 ;; cap argument
(producte 129)         129                               ;; un argument
(producte 23 34)       782                               ;; dos arguments
(producte 231 134 23)  Execution error (ArityException)  ;; no m茅s

```

---

# Conceptes Avan莽ats de Programaci贸

## Funcions: Els parmetres (I)

Els parmetres formals de les funcions (excepte en les funcions an貌nimes en notaci贸 abreujada) s'especifiquen amb un _vector_.red[*]
de s铆mbols. Clojure permet _definir funcions amb un nombre <ins>variable</ins> de parmetres_.

La manera de fer-ho 茅s fent servir el s铆mbol especial `&`.

Suposem que definim una funci贸 amb parmetres formals `[p1...pN & p]`. Aquesta funci贸 requereix que la crida es faci amb un m铆nim
de $N$ arguments, per貌 tots els arguments a partir de l'$N+1$ apareixeran dins una seq眉猫ncia.red[*] lligada al s铆mbol `p`. 

El s铆mbol que segueix a `&` "_recull_" en una seq眉猫ncia tots
els arguments que es passin a la funci贸 (m茅s enll dels obligatoris) i
la lliga a aquest s铆mbol (dins de la funci贸).

.footnote[.red[*] Veurem els vectors i les seq眉猫ncies ben aviat. Ara penseu les seq眉猫ncies com una mena de llista.]
