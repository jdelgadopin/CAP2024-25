class: center, up

# CAP - Clojure: IntroducciÃ³

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 1</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Clojure: IntroducciÃ³

### Expressions, avaluaciÃ³, valors

Un programa funcional (no trivial) estÃ  format d'**_expressions_**, que s'**_avaluen_**, i retornen un **_valor_**.

Si aquest programa estÃ  escrit en un llenguatge funcional _pur_ (p.ex. Haskell), aixÃ² Ã©s tot. En canvi
si el llenguatge de programaciÃ³ no Ã©s funcional pur (p.ex. Clojure), aquestes expressions poden tenir
_side effects_.

Hi ha expressions que es poden considerar **_constants_**, Ã©s a dir, valors l'avaluaciÃ³ dels quals 
Ã©s precisament ells mateixos:

.cols5050[
.col1[
```Clojure
$ clj
Clojure 1.11.4
user=> "hola mÃ³n"
"hola mÃ³n"
user=> 235678587432035784084032475857N
235678587432035784084032475857N
user=> 3.141592653589793
3.141592653589793
user=> 1e-23
1.0E-23
```
]
.col2[
```Clojure
user=> 1567843
1567843
user=> \t
\t
user=> :clau
:clau
user=> true
true
user=> 5/2
5/2
```
]]

---

## Clojure: IntroducciÃ³

### Expressions, avaluaciÃ³, valors

En general, perÃ², una **_expressiÃ³_** en Clojure o bÃ© Ã©s un **_sÃ­mbol_**, o be tÃ© la forma d'una **_llista_**.red[*] `(f e1 e2 ... eN)`,  on:

* Si Ã©s un **_sÃ­mbol_**, s'avalua i es retorna el valor al que estÃ  lligat (_bound_). Error si no estÃ  lligat a cap valor.

* Si Ã©s una **_llista_**, l'expressiÃ³ `f` Ã©s una **_funciÃ³_**, un **_sÃ­mbol_** que s'avalui en una funciÃ³, 
  una [**_special form_**](https://clojure.org/reference/special_forms) o el nom d'una **_macro_**.
  
* Si l'expressiÃ³ `f` Ã©s una **_funciÃ³_** o un **_sÃ­mbol_** que
  s'avalua en una funciÃ³, el resultat d'aquesta avaluaciÃ³ Ã©s un
  **_valor-funciÃ³_**, que anomenarem `fv`. Les expressions `e1 e2 ...
  eN` s'avaluen i resulten en valors `v1 v2 ... vN`. En aquest cas, el
  resultat de l'expressiÃ³ Ã©s l'aplicaciÃ³ del valor-funciÃ³ sobre els valors que es passen com a arguments:
  `fv(v1 v2 ... vN)`.

* Si l'expressiÃ³ `f` Ã©s una [**_special
  form_**](https://clojure.org/reference/special_forms) o el nom d'una
  **_macro_**, els arguments no tenen per quÃ¨ avaluar-se i cal veure com es defineix
  l'**_special form_** o la macro en qÃ¼estiÃ³.
  
.footnote[.red[*] Veurem les llistes de seguida, de moment penseu-hi com un contenidor d'elements entre parÃ¨ntesi]

---

## Clojure: IntroducciÃ³

### Expressions, avaluaciÃ³, valors

* Si l'expressiÃ³ `f` Ã©s una **_funciÃ³_** o un **_sÃ­mbol_** que
  s'avalua en una funciÃ³, el resultat d'aquesta avaluaciÃ³ Ã©s un
  **_valor-funciÃ³_**, que anomenarem `fv`. Les expressions `e1 e2 ...
  eN` s'avaluen i resulten en valors `v1 v2 ... vN`. En aquest cas, el
  resultat de l'expressiÃ³ Ã©s l'aplicaciÃ³ del valor-funciÃ³ sobre els valors que es passen com a arguments:
  `fv(v1 v2 ... vN)`.

Per exemple,

```Clojure
$ clj
Clojure 1.11.4 
user=> (+ 10 20 30 40) ;; el sÃ­mbol '+' s'avalua en el valor-funciÃ³ de la suma
100
user=> (+ 1)
1
user=> (+)
0
user=> (max (+ 3 4) (* (- 4 2) (+ 8 10)) 10) ;; altres expressions com a arguments
36
user=> 
```

---

## Clojure: IntroducciÃ³

### Expressions, avaluaciÃ³, valors

* Si l'expressiÃ³ `f` Ã©s una [**_special
  form_**](https://clojure.org/reference/special_forms) o el nom d'una
  **_macro_**, els arguments no tenen per quÃ¨ avaluar-se i cal veure com es defineix
  l'**_special form_** o la macro en qÃ¼estiÃ³.

Exemple: La **_special form_** `def`. 

Per lligar (_bind_) valors a noms (sÃ­mbols) fem servir la _special form_ `def`.

`(def s (max (+ 23 10) (- 100 85)))` lliga el sÃ­mbol `s` al valor `33`. Podem veure que 
`def` avalua el seu segon argument, perÃ² <ins>NO</ins> avalua el primer argument, 
que ha de ser un sÃ­mbol.

EstÃ  pensat per modificar sÃ­mbols _globals_, i usualment no modificarem un lligam creat amb `def`.

Al sÃ­mbol creat amb `def` se'l coneix com a **var**, i _no Ã©s el mateix que una variable_ (tal i com 
les entenem en altres llenguatges de programaciÃ³).

---

## Clojure: IntroducciÃ³

### Expressions, avaluaciÃ³, valors

A Clojure tenim **Nombres** (enters, reals, tambÃ© tenim fraccions), **CarÃ cters** (notaciÃ³ `\a`), **Booleans**,
**_keywords_** (notaciÃ³ `:s`), **sÃ­mbols** i **_strings_** (que tambÃ© sÃ³n colÂ·leccions).

Operacions _habituals_ on la seva funcionalitat Ã©s (mÃ©s o menys) Ã²bvia: `+`, `-`, `*`, `/`, `quot`, `rem`, `mod`, `inc`, `dec`,
 `=`, `not=`, `<`, `<=`, `>`, `>=`, `zero?`, `pos?`, `neg?`, `number?`, `min`, `max`, `not`, `and`, `or`, `print`,
 `println`, `char`, `keyword`, `keyword?`, `str`, `subs`, `string?`

.small[**Exercici**: Obriu un _repl_ de Clojure i feu-les servir. Exploreu.]

.cols5050[
.col1[
```Clojure
$ clj
Clojure 1.11.4
user=> (- 10 9 8)
-7
user=> (/ 100 10 2)
5
user=> (number? "no")
false
user=> 
```
]
.col2[
```Clojure
$ clj
Clojure 1.11.4
user=> (def v 7)
#'user/v
user=> (inc v)
8
user=> v
7
user=>
```
]]

---

## Clojure: IntroducciÃ³

### Llistes (I)

Hem vist que les expressions sÃ³n llistes, perÃ² les llistes sÃ³n un dels contenidors de dades que podem fer servir
a Clojure. La **_Llista_** no Ã©s mÃ©s que una colÂ·lecciÃ³ d'elements en un ordre determinat, delimitada entre parÃ¨ntesi:

.cols5050[
.col1[
`(1 2 3 4)` -- Llista amb `1`, `2`, `3`, `4`

`(\a "pep" 2 3.141592)` -- Elements de diferents tipus

`()` -- Llista buida
]
.col2[
`(def tt 2.781)` -- Una expressiÃ³ Ã©s una llista

`(max 34 -23 1)` -- Una expressiÃ³ Ã©s una llista

]]

**Homoiconicitat**: Un programa Clojure Ã©s una expressiÃ³ a avaluar
**i** una llista, per tant Ã©s tambÃ© un valor, o una dada, de Clojure.
_Code is Data_

---

## Clojure: IntroducciÃ³

### Llistes (II)

Aleshores, **com distingeix Clojure entre una llista que nomÃ©s contÃ© dades i una expressiÃ³?**

```Clojure
(def x (\a "pep" 2 3.141592)) ğŸ‘‰ Execution error
(max 34 -23 1)                ğŸ‘‰ 34
```
Quan Clojure troba una llista (o, ja que hi som, un sÃ­mbol) **sempre l'avalua com si fos una expressiÃ³**. Si volem que una llista 
(o un sÃ­mbol) no s'avalui com una expressiÃ³ **cal dir-ho explÃ­citament** amb `quote`:

```Clojure
(def x (quote (\a "pep" 2 3.141592))) 
x  ğŸ‘‰ (\a "pep" 2 3.141592)
```

Com que `quote` es fa servir molt sovint, tenim una manera d'abreujar-ho:

```Clojure
(def x '(\a "pep" 2 3.141592)) 
x  ğŸ‘‰ (\a "pep" 2 3.141592)
```

El carÃ cter `'` fa el mateix paper que la _special form_ `quote`

---

## Clojure: IntroducciÃ³

### Llistes (III): Operacions sobre llistes:

Suposem que hem fet `(def lst '(\a "c" 20 :k))`

.cols5050[
.col1[
`first` - `(first lst) ğŸ‘‰ \a`

`cons` - `(cons 'a lst)`ğŸ‘‰<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)`

`rest` - `(rest lst) ğŸ‘‰ ("c" 20 :k)`

`next` - `(next lst) ğŸ‘‰ ("c" 20 :k)`

perÃ²

`rest` - `(rest '()) ğŸ‘‰ ()`

`next` - `(next '()) ğŸ‘‰ nil`

]
.col2[
`conj` - `(conj lst 'a)`ğŸ‘‰<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)`

`peek` - `(peek lst) ğŸ‘‰ \a`

`pop` - `(pop lst) ğŸ‘‰ ("c" 20 :k)`

`list` - `(list \a "c" 20 :k)` ğŸ‘‰ 
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(\a "c" 20 :k)` 

`list?` - `(list? lst) ğŸ‘‰ true`

`count` - `(count lst) ğŸ‘‰ 4`

`empty?` - `(empty? lst) ğŸ‘‰ false`
]]

---

## Clojure: IntroducciÃ³

### Estructures de Control Condicionals

**Important!**: <ins>**Les estructures de control tambÃ© sÃ³n expressions**</ins> 

En el cas de les estructures de control condicionals, tenim:

* `(if bool-expr  expr-true   expr-false)` -- `if` Ã©s una _special form_ (tambÃ© existeix la macro `if-not`).

* `(when bool-expr expr)` -- `when` i `when-not` sÃ³n macros definides en termes d'`if`.

* Les macros `when-let` i `if-let` (en parlarem mÃ©s endavant).

* L'expressiÃ³ condicional mÃ©s general Ã©s la macro `cond`:
    ```Clojure
    (cond 
       bool-expr expr 
       bool-expr expr 
       ... 
       bool-expr expr)
    ```

**Important!**: NomÃ©s `false` i `nil` sÃ³n _falsy_. La resta de valors sÃ³n _truthy_.

---

## Clojure: IntroducciÃ³

### Funcions: Funcions anÃ²nimes, l'_special form_ `fn`

Fem servir l'_special form_ `fn` per definir funcions anÃ²nimes:

```Clojure
;;   parÃ metres   cos de la funciÃ³
;;   ----------   ----------------  
(fn [p1 p2 ... pN] expr1 ... exprM)
```
Poden haver $M$ expressions, perÃ² **el valor de retorn de la funciÃ³ Ã©s la darrera expressiÃ³ avaluada** 
(no hi ha `return`).

Per exemple:

```Clojure
(def valor_absolut (fn [x] ((if (> x 0) + -) x)))
(valor_absolut 234)  ğŸ‘‰ 234
(valor_absolut -234) ğŸ‘‰ 234

(def que-fer (fn [temp] (cond
                          (> temp 30) "Em quedo a casa amb l'aire acondicionat"
                          (> temp 15) "Me'n vaig a fer un cafÃ©"
                          :else "Em quedo al llit")))            
(que-fer 31) ğŸ‘‰ "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) ğŸ‘‰ "Me'n vaig a fer un cafÃ©"
(que-fer 10) ğŸ‘‰ "Em quedo al llit"
```
---

## Clojure: IntroducciÃ³

### Funcions: Funcions anÃ²nimes, notaciÃ³ abreujada `#(...)`

Podem escriure les funcions anÃ²nimes amb una notaciÃ³ molt mÃ©s cÃ²mode d'utilitzar. De fet, ho farem servir sovint: 

`#(cos de la funciÃ³)`

I els parÃ metres? Dins el cos de la funciÃ³ podem fer referÃ¨ncia als arguments que passem a la crida a la funciÃ³ amb la notaciÃ³:
`%1`, `%2`, etc.  Si nomÃ©s hi ha un parÃ metre podem fer servir `%`

Per exemple:

```Clojure
(def valor_absolut #((if (> % 0) + -) %) )
(valor_absolut 234)  ğŸ‘‰ 234
(valor_absolut -234) ğŸ‘‰ 234

(def que-fer #(cond (> % 30) "Em quedo a casa amb l'aire acondicionat"
                    (> % 15) "Me'n vaig a fer un cafÃ©"
                    :else "Em quedo al llit") )
(que-fer 31) ğŸ‘‰ "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) ğŸ‘‰ "Me'n vaig a fer un cafÃ©"
(que-fer 10) ğŸ‘‰ "Em quedo al llit"
```
---

## Clojure: IntroducciÃ³

### Funcions: La macro `defn` (I)

Existeix una macro, `defn` amb la que podem definir funcions de manera mÃ©s compacta:

```Clojure
;;                                       parÃ metres     cos de la funciÃ³
;;                                       ----------     ----------------
(defn nom-de-funciÃ³ "Comentari textual" [p1 p2 ... pN]   expr1 ... exprM )
```

Aquesta Ã©s la manera en que habitualment definirem funcions. Per exemple:

```Clojure
(defn valor_absolut "Calcula |x|" [x] ((if (> x 0) + -) x))

(valor_absolut 234)  ğŸ‘‰ 234
(valor_absolut -234) ğŸ‘‰ 234

(defn que-fer [temp] (cond
                       (> temp 30) "Em quedo a casa amb l'aire acondicionat"
                       (> temp 15) "Me'n vaig a fer un cafÃ©"
                       :else "Em quedo al llit"))
                       
(que-fer 31) ğŸ‘‰ "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) ğŸ‘‰ "Me'n vaig a fer un cafÃ©"
(que-fer 10) ğŸ‘‰ "Em quedo al llit"
```



---

## Clojure: IntroducciÃ³

### Funcions: La macro `defn` (II)

Amb `defn` tambÃ© podem definir funcions d'_aritats mÃºltiples_, Ã©s a dir, funcions amb diferent nombre de parÃ metres.

Per exemple:

```Clojure
(defn producte
   "Retorna 1, el parÃ metre o el producte depenent del nombre de parÃ metres"
   ([] 1)
   ([x] x)
   ([x y] (* x y)))
   
(producte)            ğŸ‘‰ 1                                 ;; cap argument
(producte 129)        ğŸ‘‰ 129                               ;; un argument
(producte 23 34)      ğŸ‘‰ 782                               ;; dos arguments
(producte 231 134 23) ğŸ‘‰ Execution error (ArityException)  ;; no mÃ©s

```

---

## Clojure: IntroducciÃ³

### Funcions: Els parÃ metres (I)

Els parÃ metres formals de les funcions (excepte en les funcions anÃ²nimes en notaciÃ³ abreujada) s'especifiquen amb un _vector_.red[*]
de sÃ­mbols. Clojure permet _definir funcions amb un nombre <ins>variable</ins> de parÃ metres_.

La manera de fer-ho Ã©s fent servir el sÃ­mbol especial `&`.

Suposem que definim una funciÃ³ amb parÃ metres formals `[p1...pN & p]`. Aquesta funciÃ³ requereix que la crida es faci amb un mÃ­nim
de $N$ arguments, perÃ² tots els arguments a partir de l'$N+1$ apareixeran dins una seqÃ¼Ã¨ncia.red[*] lligada al sÃ­mbol `p`. 

El sÃ­mbol que segueix a `&` "_recull_" en una seqÃ¼Ã¨ncia tots
els arguments que es passin a la funciÃ³ (mÃ©s enllÃ  dels obligatoris) i
la lliga a aquest sÃ­mbol (dins de la funciÃ³).

.footnote[.red[*] Veurem els vectors i les seqÃ¼Ã¨ncies ben aviat. Ara penseu les seqÃ¼Ã¨ncies com una mena de llista.]

---

## Clojure: IntroducciÃ³

### Funcions: Els parÃ metres (II)

Per exemple:

```Clojure
(defn producte
   "Retorna 1, el parÃ metre o el producte depenent del nombre de parÃ metres"
   ([] 1)
   ([x] x)
   ([x y & z] (apply * x y z)))  ;; z - seqÃ¼Ã¨ncia amb el 3r, 4t, etc. arguments
   
(producte)            ğŸ‘‰ 1                                 ;; cap argument
(producte 129)        ğŸ‘‰ 129                               ;; un argument
(producte 23 34)      ğŸ‘‰ 782                               ;; dos arguments
(producte 231 134 23) ğŸ‘‰ 711942                            ;; tres arguments
```

on `(apply f e1 e2 '(v3 ... vN)) = (f e1 e2 v3 ... vN)`<br> (`e` sÃ³n expressions, `v` sÃ³n valors) 

```Clojure
(apply + 1 2 3 '(4 5 6 7))        ğŸ‘‰ 28
(apply * (- 4 3) 2 3 '())         ğŸ‘‰ 6
(apply producte 1 2 3 '(4 5 6 7)) ğŸ‘‰ 5040
(apply max 10 20 30)              ğŸ‘‰ Execution error (IllegalArgumentException)
(apply max 10 20 30 '())          ğŸ‘‰ 30
```
---

## Clojure: IntroducciÃ³

### La recursivitat (_naÃ¯ve_) 

Ã’bviament les funcions en Clojure poden ser recursives. Una funciÃ³ pot fer servir el seu nom per invocar-se ella mateixa.
De moment farem servir la recursivitat d'aquesta manera. MÃ©s endavant hi tornarem...

### La _special form_ `do` 

La _special form_ `do` serveix per avaluar expressions una darrera l'altra, seqÃ¼encialment: `(do expr1 expr2 ... exprN)`. Aquesta
expressiÃ³ **retorna el valor resultant de l'avaluaciÃ³ de la darrera expressiÃ³**.

I quÃ¨ passa amb els valors retornats per l'avaluaciÃ³ de les altres expressions? **Es perden**. Usualment, es fan servir pels seus
efectes colaterals (_side effects_).

El cos d'una funciÃ³ tÃ© una estructura similar. Direm que **_el cos d'una funciÃ³ Ã©s dins d'un `do` implÃ­cit_**.

---

## Clojure: IntroducciÃ³

### La _special form_ `do` 

```Clojure
(do 
   (println "Efecte colateral: escrivim un missatge") ;; S'escriu el missatge
   (* 5 4 3 2 1)                      ;; Aquest valor, 120, es perd 
   (quot 343 5))                      ;; Aquest valor Ã©s el retorn del do
ğŸ‘‰ 68
ğŸ‘ï¸ Efecte colateral: escrivim un missatge
```
Les funcions tenen un `do` implÃ­cit:

```Clojure
(defn foo [x y & z]
    (println "Els dos primers arguments sÃ³n:",x,y)
    (println "La resta d'arguments:",z)
    :ok)    ;; la funciÃ³ retorna un keyword

(foo 1 2) ğŸ‘‰ :ok
ğŸ‘ï¸ Els dos primers arguments sÃ³n: 1 2
ğŸ‘ï¸ La resta d'arguments: nil

(foo 1 2 3 4 5 6) ğŸ‘‰ :ok
ğŸ‘ï¸ Els dos primers arguments sÃ³n: 1 2
ğŸ‘ï¸ La resta d'arguments: (3 4 5 6)
```

---

## Clojure: IntroducciÃ³

### Lligams locals: La _special form_ `let` (I)

Sovint voldrem lligar localment valors a sÃ­mbols dins una expressiÃ³. AixÃ² ho farem amb el `let`:

```Clojure
;;          binding-forms            cos del let
;;    -------------------------    ---------------
(let [s1 ex1  s2 ex2 ... sN exN]   expr1 ... exprM )
```
Les **_binding forms_** que farem servir de moment sÃ³n sÃ­mbols `s1`,`s2`,...,`sN`. MÃ©s endavant veurem la seva forma general.

S'avaluen, en l'ordre que apareixen, les expressions i es lliguen als sÃ­mbols corresponents: S'avalua `ex1` i es lliga el resultat
al sÃ­mbol `s1`, desprÃ©s s'avalua `ex2` i es lliga el resultat al sÃ­mbol `s2`, etc. A una expressiÃ³ `exj` podem fer servir qualsevol
sÃ­mbol `sk` (amb k < j) que s'hagi lligat abans.

El cos del `let` tÃ© un `do` implÃ­cit, per tant es retorna la darrera expressiÃ³ avaluada.

Els lligams locals nomÃ©s sÃ³n visibles dins el cos del `let` (**_lexical scope_**) i **_no es poden modificar_** dins el cos del `let`. 
Un cop mÃ©s, no estem parlant de variables.

---

## Clojure: IntroducciÃ³

### Lligams locals: La _special form_ `let` (II)

```Clojure
(defn segons-a-setmanes
    "Converteix un cert nombre de segons a setmanes"
    [segons]
    (let [minuts    (/ segons 60)
          hores     (/ minuts 60)
          dies      (/ hores 24)
          setmanes  (/ dies 7) ]
      setmanes))
      
(segons-a-setmanes 0)            ğŸ‘‰ 0
(segons-a-setmanes 604800)       ğŸ‘‰ 1
(segons-a-setmanes (* 4 604800)) ğŸ‘‰ 4
(segons-a-setmanes 60483)        ğŸ‘‰ 20161/201600
```
```Clojure
(defn foo
    "Forma molt tonta de multiplicar per 3 un nombre"
    [n]
    (let [x n
          y x
          z y]
      (+ x y z)))

(foo 9) ğŸ‘‰ 27
```
---

## Clojure: IntroducciÃ³

### Exemple: AproximaciÃ³ de l'arrel quadrada

```Clojure
(def valor-absolut #((if (> % 0) + -) %))

(def mitjana #(/ (+ %1 %2) 2))

(defn prou-bo? 
    "Retorna si l'aproximaciÃ³ Ã©s prou bona" 
    [x aprox]
    (let [diff (- (* aprox aprox) x)]
       (< (valor-absolut diff) 0.001)))

(defn arrel
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    ([x] (arrel x 1.0))
    ([x aprox] 
       (if (prou-bo? x aprox)
          aprox
          (arrel x (mitjana aprox (/ x aprox))))))

(arrel 25)  ğŸ‘‰  5.000023178253949
(arrel 36)  ğŸ‘‰  6.000000005333189
(arrel 100) ğŸ‘‰ 10.000000000139897
```
---

## Clojure: IntroducciÃ³

### Lligams locals: La _special form_ `letfn`

Ã‰s similar al `let`, perÃ² permet definir **_funcions locals_**. Dins les funcions definides amb el `letfn`,
qualsevol funciÃ³ pot referenciar qualsevol altre.

```Clojure
(defn arrel
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    ([x] (arrel x 1.0))
    ([x aprox] 
       (letfn [(prou-bo? [x aprox]
                    (let [diff (- (* aprox aprox) x)]
                        (< (valor-absolut diff) 0.001)))
               (valor-absolut [x] ((if (> x 0) + -) x))
               (mitjana [x y] (/ (+ x y) 2))]
           (if (prou-bo? x aprox)
              aprox
              (arrel x (mitjana aprox (/ x aprox)))))))

(arrel 25)  ğŸ‘‰  5.000023178253949
(arrel 36)  ğŸ‘‰  6.000000005333189
(arrel 100) ğŸ‘‰ 10.000000000139897
```

.small[**Exercici**: Per quina raÃ³ cal el `letfn`? No en tenim prou amb el `let` per definir funcions locals?
O, dit d'una altra manera, quÃ¨ puc fer amb el `letfn` que no puc fer amb el `let`? Investigueu.]

---

## Clojure: IntroducciÃ³

### Bucles: Las _special forms_ `loop`/`recur` (I)

`loop` Ã©s similar a un `let`, establint al principi el lligam entre sÃ­mbols i els seus _valors inicials_. `loop` estableix
un _punt de retorn_. Tot seguit trobem un `do` implÃ­cit dins el que podem fer servir `recur`. La _special form_ `recur`
fa dues coses: Una Ã©s donar nous valors als sÃ­mbols definits amb `loop`, i una altra Ã©s transferir el control al punt
de retorn definit per `loop`.

```Clojure
(loop [result '(), x 5]
    (if (zero? x)
       result
       (recur (conj result x) (dec x))))
       
ğŸ‘‰ (1 2 3 4 5)
```

```Clojure
(defn arrel-loop
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    [x]
    (loop [aprox 1.0]
       (if (prou-bo? x aprox)  ;; prou-bo? i mitjana ja definides
          aprox
          (recur (mitjana aprox (/ x aprox))))))
          
(arrel-loop 36)  ğŸ‘‰  6.000000005333189
```

---

## Clojure: IntroducciÃ³

### Bucles: Las _special forms_ `loop`/`recur` (II)

Un `factorial` iteratiu:

```Clojure
(defn factorial 
    "calcula el factorial d'un nombre enter positiu o zero"
    [n]
    (loop [i n, r 1]  ;; el valor inicial d'i Ã©s n i el d'r Ã©s 1
       (if (<= i 1)
          r
          (recur (dec i) (* r i)))))
          
(factorial 0) ğŸ‘‰ 1
(factorial 1) ğŸ‘‰ 1
(factorial 4) ğŸ‘‰ 24
(factorial 5) ğŸ‘‰ 120
(factorial 6) ğŸ‘‰ 720
(factorial 1000)  ğŸ‘‰ Execution error (ArithmeticException)
(factorial 1000N) ğŸ‘‰ 4023872600...00000N  (2568 dÃ­gits!)
        
```

Tornarem a trobar `recur` mÃ©s endavant en un context mÃ©s general i entendrem el per quÃ¨ d'aquesta manera 
tan _estranya_ de definir els bucles.

---

## Clojure: IntroducciÃ³

Definim la funciÃ³ _subfactorial_ d'un nombre enter no negatiu:

$$!0 = 1$$ 
$$!1 = 0$$
$$!2 = 1$$
$$!n = (n-1)*(!(n-1) + !(n-2)) \text{  si $n > 2$}$$

SoluciÃ³ recursiva (mÃºltiple, dues crides), ineficient<sup>.red[1]</sup>:

```Clojure
(defn subfact_recursiva [n]
   (cond
      (or (= n 0)  (= n 2))   1
      (= n 1)                 0
      :else (*' (dec n) (+' (subfact_recursiva (dec n)) (subfact_recursiva (- n 2))))))

(subfact_recursiva     0) ğŸ‘‰ 1
(subfact_recursiva    10) ğŸ‘‰ 1334961
(subfact_recursiva    23) ğŸ‘‰ 9510425471055777937262N
(subfact_recursiva 10000) ğŸ‘‰ Execution error (StackOverflowError)
```

.footnote[.red[1] Les operacions `+'` i `*'` sÃ³n per treballar amb nombres enters molt grans. Les operacions `+`
i `*` generen _overflow_.]

---

## Clojure: IntroducciÃ³

Provem de fer-ne una versiÃ³ recursiva final:

```Clojure
(defn subfact_final 
    ([n]  (cond
              (or (= n 0)  (= n 2))   1
              (= n 1)                 0
              :else  (subfact_final n 2 0 1)))
    ([n k nm1 nm2]  (if (> k n)
                       nm1
                       (subfact_final n (inc k) (*' (dec k) (+' nm1 nm2)) nm1))))

(subfact_final     2) ğŸ‘‰ 1
(subfact_final    10) ğŸ‘‰ 1334961
(subfact_final    23) ğŸ‘‰ 9510425471055777937262N
(subfact_final 10000) ğŸ‘‰ Execution error (StackOverflowError)
```

No sembla que les coses hagin millorat gaire, _perÃ² podrien haver-ho fet_!. 

Quan hi ha una crida a funciÃ³ en **_tail position_** no cal crear cap estructura addicional 
(_stack frame_) per a aquella crida, i aixÃ­ no es consumeix espai. D'aixÃ² se'n diu **_tail call optimization_** (TCO).
Una funciÃ³ recursiva final tÃ© la crida recursiva en _tail position_ (Ã©s essencialment una **_iteraciÃ³_**), 
i hi ha llenguatges de programaciÃ³ que optimitzen aquest fet amb TCO. 

Clojure **no tÃ© TCO** en general, per raons que tenen a veure amb l'arquitectura de la JVM.

---

## Clojure: IntroducciÃ³

### La _special form_ `recur`

Podem dir-li a Clojure explÃ­citament que una crida recursiva estÃ  en _tail position_ (una funciÃ³ Ã©s recursiva final
si totes les crides recursives estan en _tail position_) fent servir `recur`:

```Clojure
(defn subfact_recur 
    ([n]  (cond
              (or (= n 0)  (= n 2))   1
              (= n 1)                 0
              :else  (subfact_recur n 2 0 1)))
    ([n k nm1 nm2]  (if (> k n)
                       nm1
                       (recur n (inc k) (*' (dec k) (+' nm1 nm2)) nm1))))

(subfact_recur     2) ğŸ‘‰ 1
(subfact_recur    10) ğŸ‘‰ 1334961
(subfact_recur    23) ğŸ‘‰ 9510425471055777937262N
(subfact_recur 10000) ğŸ‘‰ 10470804208445737513419...39696860001N (35660 dÃ­gits!)
```

Ara evitem l'`StackOverflowError`, ja que l'avaluaciÃ³ de `subfact_recur` no consumeix espai addicional. `recur`
serveix per dir-li a Clojure que faci TCO.

---

## Clojure: IntroducciÃ³

### _Tail Position_

 Ara bÃ©, `recur` _nomÃ©s es pot fer servir en tail position i fent referÃ¨ncia a una crida recursiva_. `recur`
 no serveix per fer TCO en general:

.center[![:scale 90%](figures/tail_position.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 160]

---

## Clojure: IntroducciÃ³

### La _special form_ `recur`

Finalment, podem fer una versiÃ³ _iterativa_:

```Clojure
(defn subfact_iter
    [n]
    (cond
       (or (= n 0)  (= n 2))   1
       (= n 1)                 0
       :else (loop [k 2, nm1 0, nm2 1]
                 (if (> k n)
                    nm1
                    (recur (inc k) (*' (dec k) (+' nm1 nm2)) nm1)))))

(subfact_iter     2) ğŸ‘‰ 1
(subfact_iter    10) ğŸ‘‰ 1334961
(subfact_iter    23) ğŸ‘‰ 9510425471055777937262N
(subfact_iter 10000) ğŸ‘‰ 10470804208445737513419...39696860001N (35660 dÃ­gits!)
```

.small[Ara podem entendre millor el sentit de `recur`. En realitat el que fa Ã©s 
considerar un bucle com una mena de funciÃ³ recursiva final _implÃ­cita_. O bÃ©, tambÃ© podrÃ­em entendre que els parÃ metres 
d'una funciÃ³ defineixen un _loop implÃ­cit_, fent d'una funciÃ³ recursiva final un bucle. Sigui com sigui,
l'Ãºs de `recur` Ã©s _equivalent_ en tots dos casos.]


.small[**Exercici**: Compareu la versiÃ³ iterativa amb la recursiva final.]

---

## Clojure: IntroducciÃ³

### Les colÂ·leccions: Vectors

SÃ³n colÂ·leccions d'elements en un ordre determinat, similars a les llistes, perÃ² sÃ³n **_molt mÃ©s eficients_**. 
Els preferirem a les llistes, ja que l'accÃ©s a un element via un **_Ã­ndex_** tÃ© un cost quasi-constant, i no sÃ³n
expressions, per tant no cal fer servir `quote`.

Un vector literal tÃ© la notaciÃ³ `[1 2 \t "hi" :k]`, Ã©s a dir, elements entre claudÃ tors. El primer element tÃ© Ã­ndex 0.

```Clojure
[1 2 (+ 1 2)] ğŸ‘‰ [1 2 3]

(def nums (vec '(1 2 3 4 5))) ğŸ‘‰ #'user/nums  ;; convertim llista en vector`
nums ğŸ‘‰ [1 2 3 4 5]
(get nums 3) ğŸ‘‰ 4
(nums 3)     ğŸ‘‰ 4
(nth nums 3) ğŸ‘‰ 4

(nth nums 10 :no-hi-soc) ğŸ‘‰ :no-hi-soc  ;; nth - argument per si l'Ã­ndex no hi Ã©s
(get nums 10 :no-hi-soc) ğŸ‘‰ :no-hi-soc  ;; get - argument per si l'Ã­ndex no hi Ã©s

(conj nums 6 7) ğŸ‘‰ [1 2 3 4 5 6 7]
(conj '(1 2 3 4 5) 6 7) ğŸ‘‰ (7 6 1 2 3 4 5) ;; ep!!
```
---

## Clojure: IntroducciÃ³

### Les colÂ·leccions: AccÃ©s als elements dels vectors


![:scale 100%](figures/index_access.png)

.tiny[.red[Font]: _The Joy of Clojure_, p. 93]

---

## Clojure: IntroducciÃ³

### Les colÂ·leccions:  Operacions sobre Vectors

Suposem que hem fet `(def v [\a "c" 20 :k])`

.cols5050[
.col1[
`first` - `(first v) ğŸ‘‰ \a`

`cons` - `(cons 'a v)`ğŸ‘‰<br>
&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)` .red[**(!)**]

`rest` - `(rest v) ğŸ‘‰ ("c" 20 :k)` .red[**(!)**]

`next` - `(next v) ğŸ‘‰ ("c" 20 :k)` .red[**(!)**]

perÃ²

`rest` - `(rest []) ğŸ‘‰ ()` .red[**(!)**]

`next` - `(next []) ğŸ‘‰ nil`

`conj` - `(conj v 'a)`ğŸ‘‰<br>
&emsp;&emsp;&emsp;&emsp;&emsp;`[\a "c" 20 :k a]`
]
.col2[
`peek` - `(peek v) ğŸ‘‰ :k`

`pop` - `(pop v) ğŸ‘‰ [\a "c" 20]`

`vector` - `(vector \a "c" 20 :k)` ğŸ‘‰ 
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`[\a "c" 20 :k]` 

`vector?` - `(vector? v) ğŸ‘‰ true`

`count` - `(count v) ğŸ‘‰ 4`

`empty?` - `(empty? v) ğŸ‘‰ false`

`subvec` - `(subvec v 2 4) ğŸ‘‰ [20 :k]`

`assoc` - `(assoc v 1 -100) ğŸ‘‰ `
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`[\a -100 20 :k]`
]]

---

## Clojure: IntroducciÃ³

### Les colÂ·leccions:  Misteri (I)

Hem vist que hi ha operacions que _aparentment_ retornen una llista, ja operin sobre llistes o vectors:

```Clojure
(def lst '(:a :b :c))      ğŸ‘‰ #'user/lst
(def vct  [:a :b :c])      ğŸ‘‰ #'user/vct

(list? lst)                ğŸ‘‰ true
(vector? vct)              ğŸ‘‰ true

(rest lst)                 ğŸ‘‰ (:b :c)
(rest vct)                 ğŸ‘‰ (:b :c)

(= (rest lst) (rest vct))  ğŸ‘‰ true
```

Fins aquÃ­ tot s'entÃ©n. PerÃ²...

```Clojure
(list? (rest lst))         ğŸ‘‰ true
(list? (rest vct))         ğŸ‘‰ false
(vector? (rest vct))       ğŸ‘‰ false
```

Si `(rest lst)` Ã©s una llista i `(rest vct)` no ho Ã©s, **com poden ser `=`?**

---

## Clojure: IntroducciÃ³

### Les colÂ·leccions:  Maps (diccionaris) (I)

Un diccionari, **_map_** Ã©s com els anomena Clojure, Ã©s una colÂ·lecciÃ³ de parelles clau-valor entre _tirants_
(_curly braces_):

```Clojure
(def my-array-map (array-map :dos 2 :tres 3 :un 1)) ;; array-map, ordre d'inserciÃ³

(def my-hash-map {:un 1 :tres 3 :dos 2})  ;; tambÃ© (hash-map :un 1 :tres 3 :dos 2)

(def my-sorted-map (sorted-map :un 1 :dos 2 :tres 3)) ;; sorted-map segons claus

(my-array-map :dos)     ğŸ‘‰ 2
(get my-array-map :dos) ğŸ‘‰ 2
(:dos my-array-map)     ğŸ‘‰ 2  ;; nomÃ©s si les claus sÃ³n keywords
(my-hash-map :tres)     ğŸ‘‰ 3
(get my-hash-map :tres) ğŸ‘‰ 3
(:tres my-hash-map)     ğŸ‘‰ 3  ;; nomÃ©s si les claus sÃ³n keywords
(my-sorted-map :un)     ğŸ‘‰ 1
(get my-sorted-map :un) ğŸ‘‰ 1
(:un my-sorted-map)     ğŸ‘‰ 1  ;; nomÃ©s si les claus sÃ³n keywords
(my-sorted-map :zero)   ğŸ‘‰ nil
(get my-hash-map :zero) ğŸ‘‰ nil
```

Les claus i els valors poden ser qualsevol objecte de Clojure, perÃ² Ã©s habitual fer servir _keywords_ per
a les claus, tal i com hem fet a l'exemple.

---

## Clojure: IntroducciÃ³

### Les colÂ·leccions:  Maps (diccionaris) (II)

Veiem algunes de les operacions mÃ©s bÃ siques:

```Clojure
(assoc my-hash-map :quatre 4)   ğŸ‘‰ {:un 1, :tres 3, :dos 2, :quatre 4}
(assoc my-sorted-map :quatre 4) ğŸ‘‰ {:dos 2, :quatre 4, :tres 3, :un 1} 
;; tambÃ©
(assoc my-hash-map "a" \a "b" \b)   ğŸ‘‰ {:un 1, :tres 3, :dos 2, "a" \a, "b" \b}
(assoc my-sorted-map "a" \a "b" \b) ğŸ‘‰ Execution error (ClassCastException)

(dissoc my-array-map :un :tres) ğŸ‘‰ {:dos 2}
(dissoc my-array-map :zero)     ğŸ‘‰ {:dos 2, :tres 3, :un 1}

(conj my-hash-map {:quatre 4})  ğŸ‘‰ {:un 1, :tres 3, :dos 2, :quatre 4}
(conj my-hash-map [:quatre 4])  ğŸ‘‰ {:un 1, :tres 3, :dos 2, :quatre 4}

(keys my-hash-map)  ğŸ‘‰ (:un :tres :dos)  ;; quÃ¨ retorna keys?
(vals my-array-map) ğŸ‘‰ (2 3 1)           ;; quÃ¨ retorna vals?

(contains? my-sorted-map :un)   ğŸ‘‰ true
(contains? my-sorted-map :zero) ğŸ‘‰ false

(empty? my-hash-map) ğŸ‘‰ false
(empty? {})          ğŸ‘‰ true
``` 

---

## Clojure: IntroducciÃ³

### Les colÂ·leccions:  Maps (diccionaris) (III)

Veiem exemples mÃ©s enrevessats:

```Clojure
(let [m {:a 1, 1 :b, [1 2 3] "4 5 6"}]
    [(m :a) (m [1 2 3])])
ğŸ‘‰ [1 "4 5 6"]

(into (sorted-map) [ [:a 1] [:c 3] [:b 2] ] ) ğŸ‘‰ {:a 1, :b 2, :c 3}
(into (hash-map)   [ [:a 1] [:c 3] [:b 2] ] ) ğŸ‘‰ {:a 1, :c 3, :b 2}

(zipmap [:a :b :c :d :e] [1 2 3 4 5]) ğŸ‘‰ {:a 1, :b 2, :c 3, :d 4, :e 5}

;; Les claus sÃ³n nombres i els valors keywords! ğŸ¤¯, cap problema
(assoc {1 :int} 1.0 :float)            ğŸ‘‰ {1 :int, 1.0 :float}
(assoc (sorted-map 1 :int) 1.0 :float) ğŸ‘‰ {1 :float}  ;; (== 1 1.0) ğŸ‘‰ true

(assoc (array-map :a 1 :c 3 :b 2) :e 5 :d 4)  ğŸ‘‰ {:a 1, :c 3, :b 2, :e 5, :d 4}
(assoc (sorted-map :a 1 :c 3 :b 2) :e 5 :d 4) ğŸ‘‰ {:a 1, :b 2, :c 3, :d 4, :e 5}
```

.small[**Exercici:** Mirar [**into**](https://clojuredocs.org/clojure.core/into) i
[**zipmap**](https://clojuredocs.org/clojure.core/zipmap) amb una mica de detall.]

---

## Clojure: IntroducciÃ³

### Les colÂ·leccions:  Sets (conjunts) (I)

Els conjunts sÃ³n colÂ·leccions d'elements Ãºnics (no poden haver elements repetits, Ã©s a dir, que
siguin `=`). Es corresponen forÃ§a bÃ© a la intuiciÃ³ que ja teniu del concepte de conjunt en 
matemÃ tiques. Els conjunts es defineixen literalment amb `#{ ... }` o amb `(sorted-set ...)` (i en aquest
cas els seus elements han de ser comparables).

```Clojure
(def s #{\a 3 "foo"})                ğŸ‘‰ #'user/s
s                                    ğŸ‘‰ #{"foo" \a 3}
(def ss (sorted-set \a 3 "foo"))     ğŸ‘‰ Execution error (ClassCastException)
(def ss (sorted-set \k \l \a \d \v)) ğŸ‘‰ #'user/ss
ss                                   ğŸ‘‰ #{\a \d \k \l \v}

#{:a :b :c :b}                   ğŸ‘‰ (...) Duplicate key: :b
(sorted-set :a :b :c :b)         ğŸ‘‰ #{:a :b :c}

(conj s  :nou)                   ğŸ‘‰ #{"foo" \a :nou 3}
(conj ss \y)                     ğŸ‘‰ #{\a \d \k \l \v \y}
 
(disj s "foo")                   ğŸ‘‰ #{\a 3}
(disj ss \k)                     ğŸ‘‰ #{\a \d \l \v}
(disj ss \m)                     ğŸ‘‰ #{\a \d \k \l \v}
```
---

## Clojure: IntroducciÃ³

### Les colÂ·leccions:  Sets (conjunts) (II)

Les operacions matemÃ tiques tÃ­piques dels conjunts requereixen un afegit:

```Clojure
(require 'clojure.set)

(clojure.set/intersection #{:a :b :c} #{:c :d :e}) ğŸ‘‰ #{:c}
(clojure.set/union #{:a :b :c} #{:c :d :e})        ğŸ‘‰ #{:e :c :b :d :a}
(clojure.set/difference #{:a :b :c} #{:c :d :e})   ğŸ‘‰ #{:b :a}

(def s1 (sorted-set :a :b :c))  ğŸ‘‰  #'user/s1
(def s2 (sorted-set :c :e :d))  ğŸ‘‰  #'user/s2

(clojure.set/intersection s1 s2) ğŸ‘‰ #{:c}
(clojure.set/union s1 s2)        ğŸ‘‰ #{:a :b :c :d :e}
(clojure.set/difference s1 s2)   ğŸ‘‰ #{:a :b}
```
---

## Clojure: IntroducciÃ³

### Les colÂ·leccions:  Misteri (II)

```Clojure
(def lst '(:a 1 :b 2 :c 3 :d 4))        lst  ğŸ‘‰ (:a 1 :b 2 :c 3 :d 4)
(def vct [:a 1 :b 2 :c 3 :d 4])         vct  ğŸ‘‰ [:a 1 :b 2 :c 3 :d 4]
(def dic {:a 1 :b 2 :c 3 :d 4})         dic  ğŸ‘‰ {:a 1, :b 2, :c 3, :d 4}
(def con #{:a 1 :b 2 :c 3 :d 4})        con  ğŸ‘‰ #{1 4 :c 3 2 :b :d :a}

(first lst)  ğŸ‘‰ :a
(first vct)  ğŸ‘‰ :a
(first dic)  ğŸ‘‰ [:a 1]
(first con)  ğŸ‘‰ 1

(rest lst)  ğŸ‘‰ (1 :b 2 :c 3 :d 4)
(rest vct)  ğŸ‘‰ (1 :b 2 :c 3 :d 4)
(rest dic)  ğŸ‘‰ ([:b 2] [:c 3] [:d 4])
(rest con)  ğŸ‘‰ (4 :c 3 2 :b :d :a)

(list? (rest lst))   ğŸ‘‰ true
(vector? (rest vct)) ğŸ‘‰ false   ;; perÃ² (list? (rest vct))   ğŸ‘‰ false
(map? (rest dic))    ğŸ‘‰ false   ;; perÃ² (list? (rest dic))   ğŸ‘‰ false
(set? (rest con))    ğŸ‘‰ false   ;; perÃ² (list? (rest con))   ğŸ‘‰ false
```

**SoluciÃ³:** _La propera plana_ ğŸ˜„

---

## Clojure: IntroducciÃ³

### Les SeqÃ¼Ã¨ncies (I):

Clojure posa a disposiciÃ³ del programador una _abstracciÃ³_ que permet tractar de
manera similar diferents colÂ·leccions: **La SeqÃ¼Ã¨ncia**.

Totes les colÂ·leccions de Clojure que hem vist (llistes, vectors, diccionaris, conjunts, _strings_) sÃ³n
el que s'anomena **_seqable_**, Ã©s a dir, podem utilitzar amb aquestes estructures
les funcions que defineixen l'API de les seqÃ¼Ã¨ncies.

Resolguem els misteris:

```Clojure
(list? (rest lst))   ğŸ‘‰ true
(vector? (rest vct)) ğŸ‘‰ false   ;; perÃ² (list? (rest vct))   ğŸ‘‰ false
(map? (rest dic))    ğŸ‘‰ false   ;; perÃ² (list? (rest dic))   ğŸ‘‰ false
(set? (rest con))    ğŸ‘‰ false   ;; perÃ² (list? (rest con))   ğŸ‘‰ false

;; En realitat, rest, next, cons retornen seqÃ¼Ã¨ncies

(seq? (rest lst))   ğŸ‘‰ true
(seq? (rest vct))   ğŸ‘‰ true
(seq? (rest dic))   ğŸ‘‰ true
(seq? (rest con))   ğŸ‘‰ true
```
---

## Clojure: IntroducciÃ³

### Les SeqÃ¼Ã¨ncies (II):

Les operacions principals sobre seqÃ¼Ã¨ncies sÃ³n:

`first`: Obtenir el primer element d'una seqÃ¼Ã¨ncia

`rest`: Obtenir una seqÃ¼Ã¨ncia nova amb els mateixos elements que la seqÃ¼Ã¨ncia original, 
menys el primer element. Retorna `()` (seqÃ¼Ã¨ncia buida) si no hi ha mÃ©s elements

`cons`: Obtenir una seqÃ¼Ã¨ncia nova amb un element afegit al davant dels elements de la seqÃ¼Ã¨ncia original.

```Clojure
;;; continuant amb l'exemple dels misteris...
(cons :u lst) ğŸ‘‰ (:u :a 1 :b 2 :c 3 :d 4)
(cons :u vct) ğŸ‘‰ (:u :a 1 :b 2 :c 3 :d 4)
(cons :u dic) ğŸ‘‰ (:u [:a 1] [:b 2] [:c 3] [:d 4])
(cons :u con) ğŸ‘‰ (:u 1 4 :c 3 2 :b :d :a)
```

`seq`: retorna la seqÃ¼Ã¨ncia corresponent a la colÂ·lecciÃ³ que rep com a argument.

`next`: el mateix que `rest`, excepte que si no hi ha mÃ©s elements retorna `nil`. Si `s` Ã©s una seqÃ¼Ã¨ncia,
`(next s) = (seq (rest s))`

---

## Clojure: IntroducciÃ³

### Les SeqÃ¼Ã¨ncies (III):

```Clojure
;;; continuant amb l'exemple dels misteris...

(seq lst) ğŸ‘‰ (:a 1 :b 2 :c 3 :d 4)
(seq vct) ğŸ‘‰ (:a 1 :b 2 :c 3 :d 4)
(seq dic) ğŸ‘‰ ([:a 1] [:b 2] [:c 3] [:d 4])
(seq con) ğŸ‘‰ (1 4 :c 3 2 :b :d :a)
```
La _Clojure sequence library_ Ã©s una colÂ·lecciÃ³ de funcions que operen sobre qualsevol
seqÃ¼Ã¨ncia. Vegem-ne alguns exemples:

```Clojure
;; (range start? end? step?)
(range 10)      ğŸ‘‰ (0 1 2 3 4 5 6 7 8 9)
(range 5 10)    ğŸ‘‰ (5 6 7 8 9)
(range 10 0 -2) ğŸ‘‰ (10 8 6 4 2)

;; (repeat n x)
(repeat 5 :abc) ğŸ‘‰ (:abc :abc :abc :abc :abc)

;; (take n sequence)
(take 3 (range 100)) ğŸ‘‰ (0 1 2)

;; etc. Anirem veient aquestes funcions durant el curs...
```
---

## Clojure: IntroducciÃ³

### Les SeqÃ¼Ã¨ncies (IV):

El que Ã©s interessant Ã©s que qualsevol estructura de dades que sigui susceptible de
ser argument de `first`/`rest`/`cons` (i totes les que hem vist ho sÃ³n) pot fer
servir la _Clojure sequence library_.

De fet, aixÃ² ens permet crear funcions molt generals, que treballin sobre qualsevol 
seqÃ¼Ã¨ncia.

```Clojure
(defn nombre-elements
    "compta quants elements tÃ© la seqÃ¼Ã¨ncia"
    [sequencia]
    (loop [c 0, s sequencia]
       (if (not (seq s))
           c
           (recur (inc c) (rest s)))))

(nombre-elements '(1 2 3 4))             ğŸ‘‰ 4
(nombre-elements [1 2 3 4])              ğŸ‘‰ 4
(nombre-elements {:a 1 :b 2 :c 3 :d 4})  ğŸ‘‰ 4
(nombre-elements #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ 8
```

---

## Clojure: IntroducciÃ³

### Les SeqÃ¼Ã¨ncies (V): Aclarint terminologia...

![:scale 100%](figures/sequencies.png)

.tiny[.red[Font]: _The Joy of Clojure_, p. 87]

---

## Clojure: IntroducciÃ³

### Les SeqÃ¼Ã¨ncies (VI): Exemples (amb el que sabem fins ara.red[*]!)

Fusionar (_merge_) dues seqÃ¼Ã¨ncies ordenades:

```Clojure
(defn fusiona
    "Fusiona (merge) dues seqÃ¼Ã¨ncies que suposem ordenades"
    [s1 s2]
    (loop [seq1 s1, seq2 s2, resultat ()]
       (let [p1 (first seq1) p2 (first seq2)]
         (cond
           (nil? p1)   (concat resultat seq2)
           (nil? p2)   (concat resultat seq1)
           (= p1 p2)   (recur (rest seq1) (rest seq2) (concat resultat [p1] [p2]))
           (< p1 p2)   (recur (rest seq1) seq2 (concat resultat [p1]))
           :else       (recur seq1 (rest seq2) (concat resultat [p2]))))))

(fusiona (range 1 20 4) (range 1 20 3)) ğŸ‘‰ (1 1 4 5 7 9 10 13 13 16 17 19)
(fusiona [1 3 5 7 9] [2 4 6]) ğŸ‘‰ (1 2 3 4 5 6 7 9)
(fusiona {:a 1 :b 2} [10 20 30]) ğŸ‘‰ Execution error (ClassCastException)
(fusiona (sorted-set 100 2 200 3 300) [10 20 30]) ğŸ‘‰ (2 3 10 20 30 100 200 300)
```

Si volguÃ©ssim fusionar _vectors_ en lloc de seqÃ¼Ã¨ncies generals, podrÃ­em fer mÃ©s eficient aquesta
funciÃ³ fent servir `conj` en lloc de `concat`.

.footnote[.red[*] No farÃ­em aquests exemples d'aquesta manera si sabÃ©ssim mÃ©s Clojure.]

---

## Clojure: IntroducciÃ³

### Les SeqÃ¼Ã¨ncies (VII): Exemples (amb el que sabem fins ara!)

Comprovar si una seqÃ¼Ã¨ncia de carÃ cters `(,),[,]` estÃ  ben balancejada.

```Clojure
(defn balancejat
    [sequencia]
    (let [obrir #{ \[ \( } ]
       (loop [s sequencia, pila []]   ;; fem servir un vector com a pila
          (if (empty? s)
             (empty? pila)
             (let [c (first s)]
                (cond
                   (obrir c)       (recur (rest s) (conj pila c))
                   (empty? pila)   false
                   :else           (let [t (peek pila)]
                                      (if (or (and (= t \[) (= c \]))
                                              (and (= t \() (= c \))))
                                         (recur (rest s) (pop pila))
                                         false))))))))
(balancejat "()") ğŸ‘‰ true
(balancejat "[](") ğŸ‘‰ false
(balancejat "([()][()()[]])") ğŸ‘‰ true
(balancejat "[]()[(())]([]") ğŸ‘‰ false
(balancejat '(\[ \( \) \( \) \])) ğŸ‘‰ true
```
---

## Clojure: IntroducciÃ³

### MÃ©s Exemples (amb el que sabem fins ara!):

Suposem que representem grafs amb llistes d'adjacÃ¨ncia de la segÃ¼ent manera:


.cols5050[
.col1[
```Clojure
(def G {:A [:B :C]
        :B [:A :X]
        :X [:B :Y]
        :Y [:X]
        :C [:A :D]
        :D [:C :E :F]
        :E [:D :G]
        :F [:D :G]
        :G [:E :F]})
```
]
.col2[
![:scale 60%](figures/graf1.png)
]]
Podem fer servir com a exemples alguns algorismes que haurien de ser vells coneguts...
<br>
<br>
.tiny[[.red[Font]](https://dnaeon.github.io/graphs-and-clojure/)]

---

## Clojure: IntroducciÃ³

### MÃ©s Exemples (amb el que sabem fins ara!):

.small[Recorregut en profunditat des d'un node inicial. Retorna els nodes visitats, accessibles des del node inicial, en
l'ordre en que han estat visitats.]

```Clojure
(defn recorregut-profunditat
  "graf Ã©s un graf representat com hem vist a la transparÃ¨ncia anterior"
  "primer Ã©s el node del que es parteix per fer el recorregut"
  [graf primer]
  (loop [pendents   [primer]  ;; vector amb conj/pop/peek = Pila
         visitats   #{}
         recorregut []]
    (cond
      (empty? pendents)          recorregut
      (visitats (peek pendents)) (recur (pop pendents) visitats recorregut)
      :else (let [actual     (peek pendents)
                  pendents   (into (pop pendents) (actual graf)) ;; Apila veÃ¯ns
                  visitats   (conj visitats actual)
                  recorregut (conj recorregut actual)]
              (recur pendents visitats recorregut)))))
              
(recorregut-profunditat G :A) ğŸ‘‰ [:A :C :D :F :G :E :B :X :Y]

```

.tiny[Estem acostumats a veure versions recursives del recorregut en profunditat. Aquesta versiÃ³, en ser iterativa,
necessita una pila auxiliar. Aquest Ã©s el paper del vector `pendents`. En ser un vector sobre el que nomÃ©s
farem servir les operacions `conj`/`peek`/`pop`/`into`, es comporta com una pila on el cim Ã©s el _final_ del
vector (el cim Ã©s l'element amb l'Ã­ndex mÃ©s gran).]
