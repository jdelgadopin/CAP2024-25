class: center, up

# Conceptes AvanÃ§ats de ProgramaciÃ³

![:scale 50%](figures/lambda.png)

**Jordi Delgado**, **Gerard Escudero**,

**Curs 2024-25**: Sessions 1 i 2

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# SessiÃ³ 01

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Expressions, avaluaciÃ³, valors

Un programa funcional (no trivial) estÃ  format d'**_expressions_**, que s'**_avaluen_**, i retornen un **_valor_**.

Si aquest programa estÃ  escrit en un llenguatge funcional _pur_ (p.ex. Haskell), aixÃ² Ã©s tot. En canvi
si el llenguatge de programaciÃ³ no Ã©s funcional pur (p.ex. Clojure), aquestes expressions poden tenir
_side effects_.

Hi ha expressions que es poden considerar _constants_, Ã©s a dir, valors l'avaluaciÃ³ dels quals 
Ã©s precisament ells mateixos:

.cols5050[
.col1[
```Clojure
$ clj
Clojure 1.11.4
user=> 
(require '[clojure.math :as math])
nil
user=> 
math/PI
3.141592653589793
user=> 
2356785874320357840840324758576859043N
2356785874320357840840324758576859043N
user=>
```
]
.col2[
```Clojure
user=> 
1567843
1567843
user=> 
\t
\t
user=> 
:clau
:clau
user=> 
true
true
```
]]

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Expressions, avaluaciÃ³, valors

En general, perÃ², una **_expressiÃ³_** en Clojure o bÃ© Ã©s un **_sÃ­mbol_**, o be tÃ© la forma d'una **_llista_**.red[*] `(f e1 e2 ... eN)`,  on:

* Si Ã©s un **_sÃ­mbol_**, s'avalua i es retorna el valor al que estÃ  lligat (_bound_). Error si no estÃ  lligat a cap valor.

* Si Ã©s una **_llista_**, l'expressiÃ³ `f` Ã©s una **_funciÃ³_**, un **_sÃ­mbol_** que s'avalui en una funciÃ³, 
  una [**_special form_**](https://clojure.org/reference/special_forms) o el nom d'una **_macro_**.
  
* Si l'expressiÃ³ `f` Ã©s una **_funciÃ³_** o un **_sÃ­mbol_** que
  s'avalua en una funciÃ³, el resultat d'aquesta avaluaciÃ³ Ã©s un
  **_valor-funciÃ³_**, que anomenarem `fv`. Les expressions `e1 e2 ...
  eN` s'avaluen i resulten en valors `v1 v2 ... vN`. En aquest cas, el
  resultat de l'expressiÃ³ Ã©s l'aplicaciÃ³ del valor-funciÃ³ sobre els valors que es passen com a arguments:
  `fv(v1 v2 ... vN)`.

* Si l'expressiÃ³ `f` Ã©s una [**_special
  form_**](https://clojure.org/reference/special_forms) o el nom d'una
  **_macro_**, els arguments no tenen per quÃ¨ avaluar-se i cal veure com es defineix
  l'**_special form_** o la macro en qÃ¼estiÃ³.
  
.footnote[.red[*] Veurem les llistes de seguida, de moment penseu-hi com un contenidor d'elements entre parÃ¨ntesi]

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Expressions, avaluaciÃ³, valors

* Si l'expressiÃ³ `f` Ã©s una **_funciÃ³_** o un **_sÃ­mbol_** que
  s'avalua en una funciÃ³, el resultat d'aquesta avaluaciÃ³ Ã©s un
  **_valor-funciÃ³_**, que anomenarem `fv`. Les expressions `e1 e2 ...
  eN` s'avaluen i resulten en valors `v1 v2 ... vN`. En aquest cas, el
  resultat de l'expressiÃ³ Ã©s l'aplicaciÃ³ del valor-funciÃ³ sobre els valors que es passen com a arguments:
  `fv(v1 v2 ... vN)`.

Per exemple,

```Clojure
$ clj
Clojure 1.11.4 
user=> 
(+ 10 20 30 40) ;; el sÃ­mbol '+' s'avalua en el valor-funciÃ³ de la funciÃ³ de suma
100
user=> 
(+ 1)
1
user=> 
(+)
0
user=> 
(max (+ 3 4) (* (- 4 2) (+ 8 10)) 10) ;; altres expressions com a arguments
36
user=> 
```

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Expressions, avaluaciÃ³, valors

* Si l'expressiÃ³ `f` Ã©s una [**_special
  form_**](https://clojure.org/reference/special_forms) o el nom d'una
  **_macro_**, els arguments no tenen per quÃ¨ avaluar-se i cal veure com es defineix
  l'**_special form_** o la macro en qÃ¼estiÃ³.

Exemple: La **_special form_** `def`. 

Per lligar (_bind_) valors a noms (sÃ­mbols) fem servir la _special form_ `def`.

`(def s (max (+ 23 10) (- 100 85)))` lliga el sÃ­mbol `s` al valor `33`. Podem veure que 
`def` avalua el seu segon argument, perÃ² <ins>NO</ins> avalua el primer argument, 
que ha de ser un sÃ­mbol.

EstÃ  pensat per modificar sÃ­mbols _globals_, i usualment no modificarem un lligam creat amb `def`.

Al sÃ­mbol creat amb `def` se'l coneix com a **var**, i _no Ã©s el mateix que una variable_ (tal i com 
les entenem en altres llenguatges de programaciÃ³).

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Expressions, avaluaciÃ³, valors

A Clojure tenim **Nombres** (enters, reals, tambÃ© tenim fraccions), **CarÃ cters** (notaciÃ³ `\a`), **Booleans**,
**_keywords_** (notaciÃ³ `:s`), **sÃ­mbols** i **_strings_** (que tambÃ© sÃ³n colÂ·leccions).

Operacions _habituals_ on la seva funcionalitat Ã©s (mÃ©s o menys) Ã²bvia: `+`, `-`, `*`, `/`, `quot`, `rem`, `mod`, `inc`, `dec`,
 `=`, `not=`, `<`, `<=`, `>`, `>=`, `zero?`, `pos?`, `neg?`, `number?`, `min`, `max`, `not`, `and`, `or`, `print`,
 `println`, `char`, `keyword`, `keyword?`, `str`, `subs`, `string?`

**Exercici**: Obriu un _repl_ de Clojure i feu-les servir. Exploreu.

.cols5050[
.col1[
```Clojure
$ clj
Clojure 1.11.4
user=> 
(- 10 9 8)
-7
user=> 
(/ 100 10 2)
5
user=> 
(number? "no")
false
user=> 
```
]
.col2[
```Clojure
$ clj
Clojure 1.11.4
user=>
(def v 7)
#'user/v
user=> 
(inc v)
8
user=> 
v
7
user=>
```
]]

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Llistes (I)

Hem vist que les expressions sÃ³n llistes, perÃ² les llistes sÃ³n un dels contenidors de dades que podem fer servir
a Clojure. La **_Llista_** no Ã©s mÃ©s que una colÂ·lecciÃ³ d'elements en un ordre determinat, delimitada entre parÃ¨ntesi:

.cols5050[
.col1[
`(1 2 3 4)` -- Llista amb `1`, `2`, `3`, `4`

`(\a "pep" 2 3.141592)` -- Elements de diferents tipus

`()` -- Llista buida
]
.col2[
`(def tt 2.781)` -- Una expressiÃ³ Ã©s una llista

`(max 34 -23 1)` -- Una expressiÃ³ Ã©s una llista

]]

**Homoiconicitat**: Un programa Clojure Ã©s una expressiÃ³ i una llista, per tant Ã©s tambÃ© un valor, o una dada, de Clojure.
_Code is Data_

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Llistes (II)

Aleshores, **com distingeix Clojure entre una llista que nomÃ©s contÃ© dades i una expressiÃ³?**

```Clojure
(def x (\a "pep" 2 3.141592)) ğŸ‘‰ Execution error
(max 34 -23 1)                ğŸ‘‰ 34
```
Quan Clojure troba una llista (o, ja que hi som, un sÃ­mbol) **sempre l'avalua com si fos una expressiÃ³**. Si volem que una llista 
(o un sÃ­mbol) no s'avalui com una expressiÃ³ **cal dir-ho explÃ­citament** amb `quote`:

```Clojure
(def x (quote (\a "pep" 2 3.141592))) 
x  ğŸ‘‰ (\a "pep" 2 3.141592)
```

Com que `quote` es fa servir molt sovint, tenim una manera d'abreujar-ho:

```Clojure
(def x '(\a "pep" 2 3.141592)) 
x  ğŸ‘‰ (\a "pep" 2 3.141592)
```

El carÃ cter `'` fa el mateix paper que la _special form_ `quote`

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Llistes (III): Operacions sobre llistes:

Suposem que hem fet `(def lst '(\a "c" 20 :k))`

.cols5050[
.col1[
`first` - `(first lst) ğŸ‘‰ \a`

`cons` - `(cons 'a lst)`ğŸ‘‰<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)`

`rest` - `(rest lst) ğŸ‘‰ ("c" 20 :k)`

`next` - `(next lst) ğŸ‘‰ ("c" 20 :k)`

perÃ²

`rest` - `(rest '()) ğŸ‘‰ ()`

`next` - `(next '()) ğŸ‘‰ nil`

]
.col2[
`conj` - `(conj lst 'a)`ğŸ‘‰<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)`

`peek` - `(peek lst) ğŸ‘‰ \a`

`pop` - `(pop lst) ğŸ‘‰ ("c" 20 :k)`

`list` - `(list \a "c" 20 :k)` ğŸ‘‰ 
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(\a "c" 20 :k)` 

`list?` - `(list? lst) ğŸ‘‰ true`

`count` - `(count lst) ğŸ‘‰ 4`

`empty?` - `(empty? lst) ğŸ‘‰ false`
]]

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Estructures de Control Condicionals

**Important!**: <ins>**Les estructures de control tambÃ© sÃ³n expressions**</ins> 

En el cas de les estructures de control condicionals, tenim:

* `(if bool-expr  expr-true   expr-false)` -- `if` Ã©s una _special form_ (tambÃ© existeix la macro `if-not`).

* `(when bool-expr expr)` -- `when` i `when-not` sÃ³n macros definides en termes d'`if`.

* Les macros `when-let` i `if-let` (en parlarem mÃ©s endavant).

* L'expressiÃ³ condicional mÃ©s general Ã©s la macro `cond`:
    ```Clojure
    (cond 
       bool-expr expr 
       bool-expr expr 
       ... 
       bool-expr expr)
    ```

**Important!**: NomÃ©s `false` i `nil` sÃ³n _falsy_. La resta de valors sÃ³n _truthy_.

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Funcions: Funcions anÃ²nimes, l'_special form_ `fn`

Fem servir l'_special form_ `fn` per definir funcions anÃ²nimes:

```Clojure
;;   parÃ metres   cos de la funciÃ³
;;   ----------   ----------------  
(fn [p1 p2 ... pN] expr1 ... exprM)
```
Poden haver $M$ expressions, perÃ² **el valor de retorn de la funciÃ³ Ã©s la darrera expressiÃ³ avaluada** 
(no hi ha `return`).

Per exemple:

```Clojure
(def valor_absolut (fn [x] ((if (> x 0) + -) x)))
(valor_absolut 234)  ğŸ‘‰ 234
(valor_absolut -234) ğŸ‘‰ 234

(def que-fer (fn [temp] (cond
                          (> temp 30) "Em quedo a casa amb l'aire acondicionat"
                          (> temp 15) "Me'n vaig a fer un cafÃ©"
                          :else "Em quedo al llit")))            
(que-fer 31) ğŸ‘‰ "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) ğŸ‘‰ "Me'n vaig a fer un cafÃ©"
(que-fer 10) ğŸ‘‰ "Em quedo al llit"
```
---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Funcions: Funcions anÃ²nimes, notaciÃ³ abreujada `#(...)`

Podem escriure les funcions anÃ²nimes amb una notaciÃ³ molt mÃ©s cÃ²mode d'utilitzar. De fet, ho farem servir sovint: 

`#(cos de la funciÃ³)`

I els parÃ metres? Dins el cos de la funciÃ³ podem fer referÃ¨ncia als arguments que passem a la crida a la funciÃ³ amb la notaciÃ³:
`%1`, `%2`, etc.  Si nomÃ©s hi ha un parÃ metre podem fer servir `%`

Per exemple:

```Clojure
(def valor_absolut #((if (> % 0) + -) %) )
(valor_absolut 234)  ğŸ‘‰ 234
(valor_absolut -234) ğŸ‘‰ 234

(def que-fer #(cond (> % 30) "Em quedo a casa amb l'aire acondicionat"
                    (> % 15) "Me'n vaig a fer un cafÃ©"
                    :else "Em quedo al llit") )
(que-fer 31) ğŸ‘‰ "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) ğŸ‘‰ "Me'n vaig a fer un cafÃ©"
(que-fer 10) ğŸ‘‰ "Em quedo al llit"
```
---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Funcions: La macro `defn` (I)

Existeix una macro, `defn` amb la que podem definir funcions de manera mÃ©s compacta:

```Clojure
;;                                       parÃ metres     cos de la funciÃ³
;;                                       ----------     ----------------
(defn nom-de-funciÃ³ "Comentari textual" [p1 p2 ... pN]   expr1 ... exprM )
```

Aquesta Ã©s la manera en que habitualment definirem funcions. Per exemple:

```Clojure
(defn valor_absolut "Calcula |x|" [x] ((if (> x 0) + -) x))

(valor_absolut 234)  ğŸ‘‰ 234
(valor_absolut -234) ğŸ‘‰ 234

(defn que-fer [temp] (cond
                       (> temp 30) "Em quedo a casa amb l'aire acondicionat"
                       (> temp 15) "Me'n vaig a fer un cafÃ©"
                       :else "Em quedo al llit"))
                       
(que-fer 31) ğŸ‘‰ "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) ğŸ‘‰ "Me'n vaig a fer un cafÃ©"
(que-fer 10) ğŸ‘‰ "Em quedo al llit"
```



---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Funcions: La macro `defn` (II)

Amb `defn` tambÃ© podem definir funcions d'_aritats mÃºltiples_, Ã©s a dir, funcions amb diferent nombre de parÃ metres.

Per exemple:

```Clojure
(defn producte
   "Retorna 1, el parÃ metre o el producte depenent del nombre de parÃ metres"
   ([] 1)
   ([x] x)
   ([x y] (* x y)))
   
(producte)            ğŸ‘‰ 1                                 ;; cap argument
(producte 129)        ğŸ‘‰ 129                               ;; un argument
(producte 23 34)      ğŸ‘‰ 782                               ;; dos arguments
(producte 231 134 23) ğŸ‘‰ Execution error (ArityException)  ;; no mÃ©s

```

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Funcions: Els parÃ metres (I)

Els parÃ metres formals de les funcions (excepte en les funcions anÃ²nimes en notaciÃ³ abreujada) s'especifiquen amb un _vector_.red[*]
de sÃ­mbols. Clojure permet _definir funcions amb un nombre <ins>variable</ins> de parÃ metres_.

La manera de fer-ho Ã©s fent servir el sÃ­mbol especial `&`.

Suposem que definim una funciÃ³ amb parÃ metres formals `[p1...pN & p]`. Aquesta funciÃ³ requereix que la crida es faci amb un mÃ­nim
de $N$ arguments, perÃ² tots els arguments a partir de l'$N+1$ apareixeran dins una seqÃ¼Ã¨ncia.red[*] lligada al sÃ­mbol `p`. 

El sÃ­mbol que segueix a `&` "_recull_" en una seqÃ¼Ã¨ncia tots
els arguments que es passin a la funciÃ³ (mÃ©s enllÃ  dels obligatoris) i
la lliga a aquest sÃ­mbol (dins de la funciÃ³).

.footnote[.red[*] Veurem els vectors i les seqÃ¼Ã¨ncies ben aviat. Ara penseu les seqÃ¼Ã¨ncies com una mena de llista.]

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Funcions: Els parÃ metres (II)

Per exemple:

```Clojure
(defn producte
   "Retorna 1, el parÃ metre o el producte depenent del nombre de parÃ metres"
   ([] 1)
   ([x] x)
   ([x y & z] (apply * x y z)))  ;; z - seqÃ¼Ã¨ncia amb el 3r, 4t, etc. arguments
   
(producte)            ğŸ‘‰ 1                                 ;; cap argument
(producte 129)        ğŸ‘‰ 129                               ;; un argument
(producte 23 34)      ğŸ‘‰ 782                               ;; dos arguments
(producte 231 134 23) ğŸ‘‰ 711942                            ;; tres arguments
```

on `(apply f e1 e2 '(v3 ... vN)) = (f e1 e2 v3 ... vN)`<br> (`e` sÃ³n expressions, `v` sÃ³n valors) 

```Clojure
(apply + 1 2 3 '(4 5 6 7))        ğŸ‘‰ 28
(apply * (- 4 3) 2 3 '())         ğŸ‘‰ 6
(apply producte 1 2 3 '(4 5 6 7)) ğŸ‘‰ 5040
(apply max 10 20 30)              ğŸ‘‰ Execution error (IllegalArgumentException)
(apply max 10 20 30 '())          ğŸ‘‰ 30
```
---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## La recursivitat (_naÃ¯ve_) 

Ã’bviament les funcions en Clojure poden ser recursives. Una funciÃ³ pot fer servir el seu nom per invocar-se ella mateixa.
De moment farem servir la recursivitat d'aquesta manera. MÃ©s endavant hi tornarem...

## La _special form_ `do` 

La _special form_ `do` serveix per avaluar expressions una darrera l'altra, seqÃ¼encialment: `(do expr1 expr2 ... exprN)`. Aquesta
expressiÃ³ **retorna el valor resultant de l'avaluaciÃ³ de la darrera expressiÃ³**.

I quÃ¨ passa amb els valors retornats per l'avaluaciÃ³ de les altres expressions? **Es perden**. Usualment, es fan servir pels seus
efectes colaterals (_side effects_).

El cos d'una funciÃ³ tÃ© una estructura similar. Direm que **_el cos d'una funciÃ³ Ã©s dins d'un `do` implÃ­cit_**.

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## La _special form_ `do` 

```Clojure
(do 
   (println "Efecte colateral: escrivim un missatge") ;; S'escriu el missatge
   (* 5 4 3 2 1)                      ;; Aquest valor, 120, es perd 
   (quot 343 5))                      ;; Aquest valor Ã©s el retorn del do
ğŸ‘‰ 68
ğŸ‘ï¸ Efecte colateral: escrivim un missatge
```
Les funcions tenen un `do` implÃ­cit:

```Clojure
(defn foo [x y & z]
    (println "Els dos primers arguments sÃ³n:",x,y)
    (println "La resta d'arguments:",z)
    :ok)    ;; la funciÃ³ retorna un keyword

(foo 1 2) ğŸ‘‰ :ok
ğŸ‘ï¸ Els dos primers arguments sÃ³n: 1 2
ğŸ‘ï¸ La resta d'arguments: nil

(foo 1 2 3 4 5 6) ğŸ‘‰ :ok
ğŸ‘ï¸ Els dos primers arguments sÃ³n: 1 2
ğŸ‘ï¸ La resta d'arguments: (3 4 5 6)
```

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Lligams locals: La _special form_ `let` (I)

Sovint voldrem lligar localment valors a sÃ­mbols dins una expressiÃ³. AixÃ² ho farem amb el `let`:

```Clojure
;;          binding-forms            cos del let
;;    -------------------------    ---------------
(let [s1 ex1  s2 ex2 ... sN exN]   expr1 ... exprM )
```
Les **_binding forms_** que farem servir de moment sÃ³n sÃ­mbols `s1`,`s2`,...,`sN`. MÃ©s endavant veurem la seva forma general.

S'avaluen, en l'ordre que apareixen, les expressions i es lliguen als sÃ­mbols corresponents: S'avalua `ex1` i es lliga el resultat
al sÃ­mbol `s1`, desprÃ©s s'avalua `ex2` i es lliga el resultat al sÃ­mbol `s2`, etc. A una expressiÃ³ `exj` podem fer servir qualsevol
sÃ­mbol `sk` (amb k < j) que s'hagi lligat abans.

El cos del `let` tÃ© un `do` implÃ­cit, per tant es retorna la darrera expressiÃ³ avaluada.

Els lligams locals nomÃ©s sÃ³n visibles dins el cos del `let` (**_lexical scope_**) i **_no es poden modificar_** dins el cos del `let`. 
Un cop mÃ©s, no estem parlant de variables.

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Lligams locals: La _special form_ `let` (II)

```Clojure
(defn segons-a-setmanes
    "Converteix un cert nombre de segons a setmanes"
    [segons]
    (let [minuts    (/ segons 60)
          hores     (/ minuts 60)
          dies      (/ hores 24)
          setmanes  (/ dies 7) ]
      setmanes))
      
(segons-a-setmanes 0)            ğŸ‘‰ 0
(segons-a-setmanes 604800)       ğŸ‘‰ 1
(segons-a-setmanes (* 4 604800)) ğŸ‘‰ 4
(segons-a-setmanes 60483)        ğŸ‘‰ 20161/201600
```
```Clojure
(defn foo
    "Forma molt tonta de multiplicar per 3 un nombre"
    [n]
    (let [x n
          y x
          z y]
      (+ x y z)))

(foo 9) ğŸ‘‰ 27
```
---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Exemple: Aproximar l'arrel quadrada

```Clojure
(def valor-absolut #((if (> % 0) + -) %))

(def mitjana #(/ (+ %1 %2) 2))

(defn prou-bo? 
    "Retorna si l'aproximaciÃ³ Ã©s prou bona" 
    [x aprox]
    (let [diff (- (* aprox aprox) x)]
       (< (valor-absolut diff) 0.001)))

(defn arrel
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    ([x] (arrel x 1.0))
    ([x aprox] 
       (if (prou-bo? x aprox)
          aprox
          (arrel x (mitjana aprox (/ x aprox))))))

(arrel 25)  ğŸ‘‰  5.000023178253949
(arrel 36)  ğŸ‘‰  6.000000005333189
(arrel 100) ğŸ‘‰ 10.000000000139897
```
---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Lligams locals: La _special form_ `letfn`

Ã‰s similar al `let`, perÃ² permet definir **_funcions locals_**. Dins les funcions definides amb el `letfn`,
qualsevol funciÃ³ pot referenciar qualsevol altre.

```Clojure
(defn arrel
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    ([x] (arrel x 1.0))
    ([x aprox] 
       (letfn [(prou-bo? [x aprox]
                    (let [diff (- (* aprox aprox) x)]
                        (< (valor-absolut diff) 0.001)))
               (valor-absolut [x] ((if (> x 0) + -) x))
               (mitjana [x y] (/ (+ x y) 2))]
           (if (prou-bo? x aprox)
              aprox
              (arrel x (mitjana aprox (/ x aprox)))))))

(arrel 25)  ğŸ‘‰  5.000023178253949
(arrel 36)  ğŸ‘‰  6.000000005333189
(arrel 100) ğŸ‘‰ 10.000000000139897
```

**Exercici**: Per quina raÃ³ cal el `letfn`? No en tenim prou amb el `let` per definir funcions locals?
O, dit d'una altra manera, quÃ¨ puc fer amb el `letfn` que no puc fer amb el `let`? Investigueu.

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Bucles: Las _special forms_ `loop`/`recur` (I)

`loop` Ã©s similar a un `let`, establint al principi el lligam entre sÃ­mbols i els seus _valors inicials_. `loop` estableix
un _punt de retorn_. Tot seguit trobem un `do` implÃ­cit dins el que podem fer servir `recur`. La _special form_ `recur`
fa dues coses: Una Ã©s donar nous valors als sÃ­mbols definits amb `loop`, i una altra Ã©s transferir el control al punt
de retorn definit per `loop`.

```Clojure
(loop [result '() x 5]
    (if (zero? x)
       result
       (recur (conj result x) (dec x))))
       
ğŸ‘‰ (1 2 3 4 5)
```

```Clojure
(defn arrel-loop
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    [x]
    (loop [aprox 1.0]
       (if (prou-bo? x aprox)  ;; prou-bo? i mitjana ja definides
          aprox
          (recur (mitjana aprox (/ x aprox))))))
          
(arrel-loop 36)  ğŸ‘‰  6.000000005333189
```

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Bucles: Las _special forms_ `loop`/`recur` (II)

Un `factorial` iteratiu:

```Clojure
(defn factorial 
    "calcula el factorial d'un nombre enter positiu o zero"
    [n]
    (loop [i n r 1]  ;; el valor inicial d'i i r Ã©s 1
       (if (<= i 1)
          r
          (recur (dec i) (* r i)))))
          
(factorial 0) ğŸ‘‰ 1
(factorial 1) ğŸ‘‰ 1
(factorial 4) ğŸ‘‰ 24
(factorial 5) ğŸ‘‰ 120
(factorial 6) ğŸ‘‰ 720
(factorial 1000)  ğŸ‘‰ Execution error (ArithmeticException)
(factorial 1000N) ğŸ‘‰ 4023872600...00000N  (2568 dÃ­gits!)
        
```

Tornarem a trobar `recur` mÃ©s endavant en un context mÃ©s general i entendrem el per quÃ¨ d'aquesta manera 
tan _estranya_ de definir els bucles.

---

class: center, middle

# SessiÃ³ 02

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

Definim la funciÃ³ _subfactorial_ d'un nombre enter no negatiu:

$$!0 = 1$$ 
$$!1 = 0$$
$$!2 = 1$$
$$!n = (n-1)*(!(n-1) + !(n-2)) \text{  si $n > 2$}$$

SoluciÃ³ recursiva lineal, ineficient<sup>.red[1]</sup>:

```Clojure
(defn subfact_lineal [n]
   (cond
      (or (= n 0)  (= n 2))   1
      (= n 1)                 0
      :else (*' (dec n) (+' (subfact_lineal (dec n)) (subfact_lineal (- n 2))))))

(subfact_lineal     2) ğŸ‘‰ 1
(subfact_lineal    10) ğŸ‘‰ 1334961
(subfact_lineal    23) ğŸ‘‰ 9510425471055777937262N
(subfact_lineal 10000) ğŸ‘‰ Execution error (StackOverflowError)
```

.footnote[.red[1] Les operacions `+'` i `*'` sÃ³n per treballar amb nombres enters molt grans. Les operacions `+`
i `*` generen _overflow_.]

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

Provem de fer-ne una versiÃ³ recursiva final:

```Clojure
(defn subfact_final 
    ([n]  (cond
              (or (= n 0)  (= n 2))   1
              (= n 1)                 0
              :else  (subfact_final n 2 0 1)))
    ([n k nm1 nm2]  (if (> k n)
                       nm1
                       (subfact_final n (inc k) (*' (dec k) (+' nm1 nm2)) nm1))))

(subfact_final     2) ğŸ‘‰ 1
(subfact_final    10) ğŸ‘‰ 1334961
(subfact_final    23) ğŸ‘‰ 9510425471055777937262N
(subfact_final 10000) ğŸ‘‰ Execution error (StackOverflowError)
```

No sembla que les coses hagin millorat gaire, _perÃ² podrien haver-ho fet_!. 

Una funciÃ³ recursiva final Ã©s essencialment una **_iteraciÃ³_**, i hi ha llenguatges de programaciÃ³ que optimitzen 
aquest fet: Quan hi ha una crida a funciÃ³ en **_tail position_** no cal crear cap estructura addicional 
(_stack frame_) per a aquella crida, i aixÃ­ no es consumeix espai. D'aixÃ² se'n diu **_tail call optimization_** (TCO).

Clojure **no tÃ© TCO**, en general, per raons que tenen a veure amb l'arquitectura de la JVM.

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## La _special form_ `recur`

Podem dir-li a Clojure explÃ­citament que una crida recursiva estÃ  en _tail position_ (una funciÃ³ Ã©s recursiva final
si totes les crides recursives estan en _tail position_) fent servir `recur`:

```Clojure
(defn subfact_recur 
    ([n]  (cond
              (or (= n 0)  (= n 2))   1
              (= n 1)                 0
              :else  (subfact_recur n 2 0 1)))
    ([n k nm1 nm2]  (if (> k n)
                       nm1
                       (recur n (inc k) (*' (dec k) (+' nm1 nm2)) nm1))))

(subfact_recur     2) ğŸ‘‰ 1
(subfact_recur    10) ğŸ‘‰ 1334961
(subfact_recur    23) ğŸ‘‰ 9510425471055777937262N
(subfact_recur 10000) ğŸ‘‰ 10470804208445737513419...39696860001N (35660 dÃ­gits!)
```

Ara evitem l'_StackOverflowError_, ja que l'avaluaciÃ³ de `subfact_recur` no consumeix espai addicional. `recur`
serveix per dir-li a Clojure que faci TCO. Ara bÃ©, `recur` _nomÃ©s es pot fer servir en tail position_!

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## _Tail Position_

![:scale 100%](figures/tail_position.png)

.tiny[.red[Source]: _The Joy of Clojure_, p. 160]

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## La _special form_ `recur`

Finalment, podem fer una versiÃ³ _iterativa_:

```Clojure
(defn subfact_iter
    [n]
    (cond
       (or (= n 0)  (= n 2))   1
       (= n 1)                 0
       :else (loop [k 2 nm1 0 nm2 1]
                 (if (> k n)
                    nm1
                    (recur (inc k) (*' (dec k) (+' nm1 nm2)) nm1)))))

(subfact_iter     2) ğŸ‘‰ 1
(subfact_iter    10) ğŸ‘‰ 1334961
(subfact_iter    23) ğŸ‘‰ 9510425471055777937262N
(subfact_iter 10000) ğŸ‘‰ 10470804208445737513419...39696860001N (35660 dÃ­gits!)
```

Ara podem entendre millor l'Ãºs de `recur` per definir les iteracions a Clojure. En realitat el que es fa Ã©s 
considerar un bucle com una mena de funciÃ³ recursiva final _implÃ­cita_.


**Exercici**: Compareu la versiÃ³ iterativa amb la recursiva final.

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Les colÂ·leccions: Vectors (I)

SÃ³n colÂ·leccions d'elements en un ordre determinat, similars a les llistes, perÃ² sÃ³n **_molt mÃ©s eficients_**. 
Els preferirem a les llistes, ja que l'accÃ©s a un element via un **_Ã­ndex_** tÃ© un cost quasi-constant, i no sÃ³n
expressions, per tant no cal fer servir `quote`.

Un vector literal tÃ© la notaciÃ³ `[1 2 \t "hi" :k]`, Ã©s a dir, elements entre claudÃ tors. El primer element tÃ© Ã­ndex 0.

Exemples:

```Clojure
[1 2 (+ 1 2)] ğŸ‘‰ [1 2 3]

(def nums (vec '(1 2 3 4 5))) ğŸ‘‰ #'user/nums  ;; convertim llista en vector`
nums ğŸ‘‰ [1 2 3 4 5]
(get nums 3) ğŸ‘‰ 4
(nums 3)     ğŸ‘‰ 4

(vector \a \b \c) ğŸ‘‰ [\a \b \c]

(conj nums 6 7) ğŸ‘‰ [1 2 3 4 5 6 7]
(conj '(1 2 3 4 5) 6 7) ğŸ‘‰ (7 6 1 2 3 4 5) ;; ep!!
```

---

# Conceptes AvanÃ§ats de ProgramaciÃ³

## Les colÂ·leccions: Vectors (II)

Suposem que hem fet `(def v [\a "c" 20 :k])`

.cols5050[
.col1[
`first` - `(first v) ğŸ‘‰ \a`

`cons` - `(cons 'a v)`ğŸ‘‰<br>
&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)` **(!)**

`rest` - `(rest v) ğŸ‘‰ ("c" 20 :k)` **(!)**

`next` - `(next v) ğŸ‘‰ ("c" 20 :k)` **(!)**

perÃ²

`rest` - `(rest []) ğŸ‘‰ ()` **(!)**

`next` - `(next []) ğŸ‘‰ nil`

`conj` - `(conj v 'a)`ğŸ‘‰<br>
&emsp;&emsp;&emsp;&emsp;&emsp;`[\a "c" 20 :k a]`
]
.col2[
`peek` - `(peek v) ğŸ‘‰ :k`

`pop` - `(pop v) ğŸ‘‰ [\a "c" 20]`

`vector` - `(vector \a "c" 20 :k)` ğŸ‘‰ 
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`[\a "c" 20 :k]` 

`vector?` - `(vector? v) ğŸ‘‰ true`

`count` - `(count v) ğŸ‘‰ 4`

`empty?` - `(empty? v) ğŸ‘‰ false`

`subvec` - `(subvec v 2 4) ğŸ‘‰ [20 :k]`

`assoc` - `(assoc v 1 -100) ğŸ‘‰ `
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`[\a -100 20 :k]`
]]
