class: center, up

# Conceptes Avançats de Programació

![:scale 50%](figures/lambda.png)

**Jordi Delgado**, **Gerard Escudero**,

**Curs 2024-25**: Sessions 1 i 2

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# Sessió 01

---

# Conceptes Avançats de Programació

## Expressions, avaluació, valors

Un programa funcional (no trivial) està format d'**_expressions_**, que s'**_avaluen_**, i retornen un **_valor_**.

Si aquest programa està escrit en un llenguatge funcional _pur_ (p.ex. Haskell), això és tot. En canvi
si el llenguatge de programació no és funcional pur (p.ex. Clojure), aquestes expressions poden tenir
_side effects_.

Hi ha expressions que es poden considerar _constants_, és a dir, valors l'avaluació dels quals 
és precisament ells mateixos:

.cols5050[
.col1[
```Clojure
$ clj
Clojure 1.11.4
user=> 
(require '[clojure.math :as math])
nil
user=> 
math/PI
3.141592653589793
user=> 
2356785874320357840840324758576859043N
2356785874320357840840324758576859043N
user=>
```
]
.col2[
```Clojure
user=> 
1567843
1567843
user=> 
\t
\t
user=> 
:clau
:clau
user=> 
true
true
```
]]

---

# Conceptes Avançats de Programació

## Expressions, avaluació, valors

En general, però, una **_expressió_** en Clojure o bé és un **_símbol_**, o be té la forma d'una **_llista_**.red[*] `(f e1 e2 ... eN)`,  on:

* Si és un **_símbol_**, s'avalua i es retorna el valor al que està lligat (_bound_). Error si no està lligat a cap valor.

* Si és una **_llista_**, l'expressió `f` és una **_funció_**, un **_símbol_** que s'avalui en una funció, 
  una [**_special form_**](https://clojure.org/reference/special_forms) o el nom d'una **_macro_**.
  
* Si l'expressió `f` és una **_funció_** o un **_símbol_** que
  s'avalua en una funció, el resultat d'aquesta avaluació és un
  **_valor-funció_**, que anomenarem `fv`. Les expressions `e1 e2 ...
  eN` s'avaluen i resulten en valors `v1 v2 ... vN`. En aquest cas, el
  resultat de l'expressió és l'aplicació del valor-funció sobre els valors que es passen com a arguments:
  `fv(v1 v2 ... vN)`.

* Si l'expressió `f` és una [**_special
  form_**](https://clojure.org/reference/special_forms) o el nom d'una
  **_macro_**, els arguments no tenen per què avaluar-se i cal veure com es defineix
  l'**_special form_** o la macro en qüestió.
  
.footnote[.red[*] Veurem les llistes de seguida, de moment penseu-hi com un contenidor d'elements entre parèntesi]

---

# Conceptes Avançats de Programació

## Expressions, avaluació, valors

* Si l'expressió `f` és una **_funció_** o un **_símbol_** que
  s'avalua en una funció, el resultat d'aquesta avaluació és un
  **_valor-funció_**, que anomenarem `fv`. Les expressions `e1 e2 ...
  eN` s'avaluen i resulten en valors `v1 v2 ... vN`. En aquest cas, el
  resultat de l'expressió és l'aplicació del valor-funció sobre els valors que es passen com a arguments:
  `fv(v1 v2 ... vN)`.

Per exemple,

```Clojure
$ clj
Clojure 1.11.4 
user=> 
(+ 10 20 30 40) ;; el símbol '+' s'avalua en el valor-funció de la funció de suma
100
user=> 
(+ 1)
1
user=> 
(+)
0
user=> 
(max (+ 3 4) (* (- 4 2) (+ 8 10)) 10) ;; altres expressions com a arguments
36
user=> 
```

---

# Conceptes Avançats de Programació

## Expressions, avaluació, valors

* Si l'expressió `f` és una [**_special
  form_**](https://clojure.org/reference/special_forms) o el nom d'una
  **_macro_**, els arguments no tenen per què avaluar-se i cal veure com es defineix
  l'**_special form_** o la macro en qüestió.

Exemple: La **_special form_** `def`. 

Per lligar (_bind_) valors a noms (símbols) fem servir la _special form_ `def`.

`(def s (max (+ 23 10) (- 100 85)))` lliga el símbol `s` al valor `33`. Podem veure que 
`def` avalua el seu segon argument, però <ins>NO</ins> avalua el primer argument, 
que ha de ser un símbol.

Està pensat per modificar símbols _globals_, i usualment no modificarem un lligam creat amb `def`.

Al símbol creat amb `def` se'l coneix com a **var**, i _no és el mateix que una variable_ (tal i com 
les entenem en altres llenguatges de programació).

---

# Conceptes Avançats de Programació

## Expressions, avaluació, valors

A Clojure tenim **Nombres** (enters, reals, també tenim fraccions), **Caràcters** (notació `\a`), **Booleans**,
**_keywords_** (notació `:s`), **símbols** i **_strings_** (que també són col·leccions).

Operacions _habituals_ on la seva funcionalitat és (més o menys) òbvia: `+`, `-`, `*`, `/`, `quot`, `rem`, `mod`, `inc`, `dec`,
 `=`, `not=`, `<`, `<=`, `>`, `>=`, `zero?`, `pos?`, `neg?`, `number?`, `min`, `max`, `not`, `and`, `or`, `print`,
 `println`, `char`, `keyword`, `keyword?`, `str`, `subs`, `string?`

**Exercici**: Obriu un _repl_ de Clojure i feu-les servir. Exploreu.

.cols5050[
.col1[
```Clojure
$ clj
Clojure 1.11.4
user=> 
(- 10 9 8)
-7
user=> 
(/ 100 10 2)
5
user=> 
(number? "no")
false
user=> 
```
]
.col2[
```Clojure
$ clj
Clojure 1.11.4
user=>
(def v 7)
#'user/v
user=> 
(inc v)
8
user=> 
v
7
user=>
```
]]

---

# Conceptes Avançats de Programació

## Llistes (I)

Hem vist que les expressions són llistes, però les llistes són un dels contenidors de dades que podem fer servir
a Clojure. La **_Llista_** no és més que una col·lecció d'elements en un ordre determinat, delimitada entre parèntesi:

.cols5050[
.col1[
`(1 2 3 4)` -- Llista amb `1`, `2`, `3`, `4`

`(\a "pep" 2 3.141592)` -- Elements de diferents tipus

`()` -- Llista buida
]
.col2[
`(def tt 2.781)` -- Una expressió és una llista

`(max 34 -23 1)` -- Una expressió és una llista

]]

**Homoiconicitat**: Un programa Clojure és una expressió i una llista, per tant és també un valor, o una dada, de Clojure.
_Code is Data_

---

# Conceptes Avançats de Programació

## Llistes (II)

Aleshores, **com distingeix Clojure entre una llista que només conté dades i una expressió?**

```Clojure
(def x (\a "pep" 2 3.141592)) 👉 Execution error
(max 34 -23 1)                👉 34
```
Quan Clojure troba una llista (o, ja que hi som, un símbol) **sempre l'avalua com si fos una expressió**. Si volem que una llista 
(o un símbol) no s'avalui com una expressió **cal dir-ho explícitament** amb `quote`:

```Clojure
(def x (quote (\a "pep" 2 3.141592))) 
x  👉 (\a "pep" 2 3.141592)
```

Com que `quote` es fa servir molt sovint, tenim una manera d'abreujar-ho:

```Clojure
(def x '(\a "pep" 2 3.141592)) 
x  👉 (\a "pep" 2 3.141592)
```

El caràcter `'` fa el mateix paper que la _special form_ `quote`

---

# Conceptes Avançats de Programació

## Llistes (III): Operacions sobre llistes:

Suposem que hem fet `(def lst '(\a "c" 20 :k))`

.cols5050[
.col1[
`first` - `(first lst) 👉 \a`

`cons` - `(cons 'a lst)`👉<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)`

`rest` - `(rest lst) 👉 ("c" 20 :k)`

`next` - `(next lst) 👉 ("c" 20 :k)`

però

`rest` - `(rest '()) 👉 ()`

`next` - `(next '()) 👉 nil`

]
.col2[
`conj` - `(conj lst 'a)`👉<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)`

`peek` - `(peek lst) 👉 \a`

`pop` - `(pop lst) 👉 ("c" 20 :k)`

`list` - `(list \a "c" 20 :k)` 👉 
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`(\a "c" 20 :k)` 

`list?` - `(list? lst) 👉 true`

`count` - `(count lst) 👉 4`

`empty?` - `(empty? lst) 👉 false`
]]

---

# Conceptes Avançats de Programació

## Estructures de Control Condicionals

**Important!**: <ins>**Les estructures de control també són expressions**</ins> 

En el cas de les estructures de control condicionals, tenim:

* `(if bool-expr  expr-true   expr-false)` -- `if` és una _special form_ (també existeix la macro `if-not`).

* `(when bool-expr expr)` -- `when` i `when-not` són macros definides en termes d'`if`.

* Les macros `when-let` i `if-let` (en parlarem més endavant).

* L'expressió condicional més general és la macro `cond`:
    ```Clojure
    (cond 
       bool-expr expr 
       bool-expr expr 
       ... 
       bool-expr expr)
    ```

**Important!**: Només `false` i `nil` són _falsy_. La resta de valors són _truthy_.

---

# Conceptes Avançats de Programació

## Funcions: Funcions anònimes, l'_special form_ `fn`

Fem servir l'_special form_ `fn` per definir funcions anònimes:

```Clojure
;;   paràmetres   cos de la funció
;;   ----------   ----------------  
(fn [p1 p2 ... pN] expr1 ... exprM)
```
Poden haver $M$ expressions, però **el valor de retorn de la funció és la darrera expressió avaluada** 
(no hi ha `return`).

Per exemple:

```Clojure
(def valor_absolut (fn [x] ((if (> x 0) + -) x)))
(valor_absolut 234)  👉 234
(valor_absolut -234) 👉 234

(def que-fer (fn [temp] (cond
                          (> temp 30) "Em quedo a casa amb l'aire acondicionat"
                          (> temp 15) "Me'n vaig a fer un café"
                          :else "Em quedo al llit")))            
(que-fer 31) 👉 "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) 👉 "Me'n vaig a fer un café"
(que-fer 10) 👉 "Em quedo al llit"
```
---

# Conceptes Avançats de Programació

## Funcions: Funcions anònimes, notació abreujada `#(...)`

Podem escriure les funcions anònimes amb una notació molt més còmode d'utilitzar. De fet, ho farem servir sovint: 

`#(cos de la funció)`

I els paràmetres? Dins el cos de la funció podem fer referència als arguments que passem a la crida a la funció amb la notació:
`%1`, `%2`, etc.  Si només hi ha un paràmetre podem fer servir `%`

Per exemple:

```Clojure
(def valor_absolut #((if (> % 0) + -) %) )
(valor_absolut 234)  👉 234
(valor_absolut -234) 👉 234

(def que-fer #(cond (> % 30) "Em quedo a casa amb l'aire acondicionat"
                    (> % 15) "Me'n vaig a fer un café"
                    :else "Em quedo al llit") )
(que-fer 31) 👉 "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) 👉 "Me'n vaig a fer un café"
(que-fer 10) 👉 "Em quedo al llit"
```
---

# Conceptes Avançats de Programació

## Funcions: La macro `defn` (I)

Existeix una macro, `defn` amb la que podem definir funcions de manera més compacta:

```Clojure
;;                                       paràmetres     cos de la funció
;;                                       ----------     ----------------
(defn nom-de-funció "Comentari textual" [p1 p2 ... pN]   expr1 ... exprM )
```

Aquesta és la manera en que habitualment definirem funcions. Per exemple:

```Clojure
(defn valor_absolut "Calcula |x|" [x] ((if (> x 0) + -) x))

(valor_absolut 234)  👉 234
(valor_absolut -234) 👉 234

(defn que-fer [temp] (cond
                       (> temp 30) "Em quedo a casa amb l'aire acondicionat"
                       (> temp 15) "Me'n vaig a fer un café"
                       :else "Em quedo al llit"))
                       
(que-fer 31) 👉 "Em quedo a casa amb l'aire acondicionat"
(que-fer 25) 👉 "Me'n vaig a fer un café"
(que-fer 10) 👉 "Em quedo al llit"
```



---

# Conceptes Avançats de Programació

## Funcions: La macro `defn` (II)

Amb `defn` també podem definir funcions d'_aritats múltiples_, és a dir, funcions amb diferent nombre de paràmetres.

Per exemple:

```Clojure
(defn producte
   "Retorna 1, el paràmetre o el producte depenent del nombre de paràmetres"
   ([] 1)
   ([x] x)
   ([x y] (* x y)))
   
(producte)            👉 1                                 ;; cap argument
(producte 129)        👉 129                               ;; un argument
(producte 23 34)      👉 782                               ;; dos arguments
(producte 231 134 23) 👉 Execution error (ArityException)  ;; no més

```

---

# Conceptes Avançats de Programació

## Funcions: Els paràmetres (I)

Els paràmetres formals de les funcions (excepte en les funcions anònimes en notació abreujada) s'especifiquen amb un _vector_.red[*]
de símbols. Clojure permet _definir funcions amb un nombre <ins>variable</ins> de paràmetres_.

La manera de fer-ho és fent servir el símbol especial `&`.

Suposem que definim una funció amb paràmetres formals `[p1...pN & p]`. Aquesta funció requereix que la crida es faci amb un mínim
de $N$ arguments, però tots els arguments a partir de l'$N+1$ apareixeran dins una seqüència.red[*] lligada al símbol `p`. 

El símbol que segueix a `&` "_recull_" en una seqüència tots
els arguments que es passin a la funció (més enllà dels obligatoris) i
la lliga a aquest símbol (dins de la funció).

.footnote[.red[*] Veurem els vectors i les seqüències ben aviat. Ara penseu les seqüències com una mena de llista.]

---

# Conceptes Avançats de Programació

## Funcions: Els paràmetres (II)

Per exemple:

```Clojure
(defn producte
   "Retorna 1, el paràmetre o el producte depenent del nombre de paràmetres"
   ([] 1)
   ([x] x)
   ([x y & z] (apply * x y z)))  ;; z - seqüència amb el 3r, 4t, etc. arguments
   
(producte)            👉 1                                 ;; cap argument
(producte 129)        👉 129                               ;; un argument
(producte 23 34)      👉 782                               ;; dos arguments
(producte 231 134 23) 👉 711942                            ;; tres arguments
```

on `(apply f e1 e2 '(v3 ... vN)) = (f e1 e2 v3 ... vN)`<br> (`e` són expressions, `v` són valors) 

```Clojure
(apply + 1 2 3 '(4 5 6 7))        👉 28
(apply * (- 4 3) 2 3 '())         👉 6
(apply producte 1 2 3 '(4 5 6 7)) 👉 5040
(apply max 10 20 30)              👉 Execution error (IllegalArgumentException)
(apply max 10 20 30 '())          👉 30
```
---

# Conceptes Avançats de Programació

## La recursivitat (_naïve_) 

Òbviament les funcions en Clojure poden ser recursives. Una funció pot fer servir el seu nom per invocar-se ella mateixa.
De moment farem servir la recursivitat d'aquesta manera. Més endavant hi tornarem...

## La _special form_ `do` 

La _special form_ `do` serveix per avaluar expressions una darrera l'altra, seqüencialment: `(do expr1 expr2 ... exprN)`. Aquesta
expressió **retorna el valor resultant de l'avaluació de la darrera expressió**.

I què passa amb els valors retornats per l'avaluació de les altres expressions? **Es perden**. Usualment, es fan servir pels seus
efectes colaterals (_side effects_).

El cos d'una funció té una estructura similar. Direm que **_el cos d'una funció és dins d'un `do` implícit_**.

---

# Conceptes Avançats de Programació

## La _special form_ `do` 

```Clojure
(do 
   (println "Efecte colateral: escrivim un missatge") ;; S'escriu el missatge
   (* 5 4 3 2 1)                      ;; Aquest valor, 120, es perd 
   (quot 343 5))                      ;; Aquest valor és el retorn del do
👉 68
👁️ Efecte colateral: escrivim un missatge
```
Les funcions tenen un `do` implícit:

```Clojure
(defn foo [x y & z]
    (println "Els dos primers arguments són:",x,y)
    (println "La resta d'arguments:",z)
    :ok)    ;; la funció retorna un keyword

(foo 1 2) 👉 :ok
👁️ Els dos primers arguments són: 1 2
👁️ La resta d'arguments: nil

(foo 1 2 3 4 5 6) 👉 :ok
👁️ Els dos primers arguments són: 1 2
👁️ La resta d'arguments: (3 4 5 6)
```

---

# Conceptes Avançats de Programació

## Lligams locals: La _special form_ `let` (I)

Sovint voldrem lligar localment valors a símbols dins una expressió. Això ho farem amb el `let`:

```Clojure
;;          binding-forms            cos del let
;;    -------------------------    ---------------
(let [s1 ex1  s2 ex2 ... sN exN]   expr1 ... exprM )
```
Les **_binding forms_** que farem servir de moment són símbols `s1`,`s2`,...,`sN`. Més endavant veurem la seva forma general.

S'avaluen, en l'ordre que apareixen, les expressions i es lliguen als símbols corresponents: S'avalua `ex1` i es lliga el resultat
al símbol `s1`, després s'avalua `ex2` i es lliga el resultat al símbol `s2`, etc. A una expressió `exj` podem fer servir qualsevol
símbol `sk` (amb k < j) que s'hagi lligat abans.

El cos del `let` té un `do` implícit, per tant es retorna la darrera expressió avaluada.

Els lligams locals només són visibles dins el cos del `let` (**_lexical scope_**) i **_no es poden modificar_** dins el cos del `let`. 
Un cop més, no estem parlant de variables.

---

# Conceptes Avançats de Programació

## Lligams locals: La _special form_ `let` (II)

```Clojure
(defn segons-a-setmanes
    "Converteix un cert nombre de segons a setmanes"
    [segons]
    (let [minuts    (/ segons 60)
          hores     (/ minuts 60)
          dies      (/ hores 24)
          setmanes  (/ dies 7) ]
      setmanes))
      
(segons-a-setmanes 0)            👉 0
(segons-a-setmanes 604800)       👉 1
(segons-a-setmanes (* 4 604800)) 👉 4
(segons-a-setmanes 60483)        👉 20161/201600
```
```Clojure
(defn foo
    "Forma molt tonta de multiplicar per 3 un nombre"
    [n]
    (let [x n
          y x
          z y]
      (+ x y z)))

(foo 9) 👉 27
```
---

# Conceptes Avançats de Programació

## Exemple: Aproximar l'arrel quadrada

```Clojure
(def valor-absolut #((if (> % 0) + -) %))

(def mitjana #(/ (+ %1 %2) 2))

(defn prou-bo? 
    "Retorna si l'aproximació és prou bona" 
    [x aprox]
    (let [diff (- (* aprox aprox) x)]
       (< (valor-absolut diff) 0.001)))

(defn arrel
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    ([x] (arrel x 1.0))
    ([x aprox] 
       (if (prou-bo? x aprox)
          aprox
          (arrel x (mitjana aprox (/ x aprox))))))

(arrel 25)  👉  5.000023178253949
(arrel 36)  👉  6.000000005333189
(arrel 100) 👉 10.000000000139897
```
---

# Conceptes Avançats de Programació

## Lligams locals: La _special form_ `letfn`

És similar al `let`, però permet definir **_funcions locals_**. Dins les funcions definides amb el `letfn`,
qualsevol funció pot referenciar qualsevol altre.

```Clojure
(defn arrel
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    ([x] (arrel x 1.0))
    ([x aprox] 
       (letfn [(prou-bo? [x aprox]
                    (let [diff (- (* aprox aprox) x)]
                        (< (valor-absolut diff) 0.001)))
               (valor-absolut [x] ((if (> x 0) + -) x))
               (mitjana [x y] (/ (+ x y) 2))]
           (if (prou-bo? x aprox)
              aprox
              (arrel x (mitjana aprox (/ x aprox)))))))

(arrel 25)  👉  5.000023178253949
(arrel 36)  👉  6.000000005333189
(arrel 100) 👉 10.000000000139897
```

**Exercici**: Per quina raó cal el `letfn`? No en tenim prou amb el `let` per definir funcions locals?
O, dit d'una altra manera, què puc fer amb el `letfn` que no puc fer amb el `let`? Investigueu.

---

# Conceptes Avançats de Programació

## Bucles: Las _special forms_ `loop`/`recur` (I)

`loop` és similar a un `let`, establint al principi el lligam entre símbols i els seus _valors inicials_. `loop` estableix
un _punt de retorn_. Tot seguit trobem un `do` implícit dins el que podem fer servir `recur`. La _special form_ `recur`
fa dues coses: Una és donar nous valors als símbols definits amb `loop`, i una altra és transferir el control al punt
de retorn definit per `loop`.

```Clojure
(loop [result '() x 5]
    (if (zero? x)
       result
       (recur (conj result x) (dec x))))
       
👉 (1 2 3 4 5)
```

```Clojure
(defn arrel-loop
    "Retorna l'arrel quadrada aproximada d'un nombre positiu"
    [x]
    (loop [aprox 1.0]
       (if (prou-bo? x aprox)  ;; prou-bo? i mitjana ja definides
          aprox
          (recur (mitjana aprox (/ x aprox))))))
          
(arrel-loop 36)  👉  6.000000005333189
```

---

# Conceptes Avançats de Programació

## Bucles: Las _special forms_ `loop`/`recur` (II)

Un `factorial` iteratiu:

```Clojure
(defn factorial 
    "calcula el factorial d'un nombre enter positiu o zero"
    [n]
    (loop [i n r 1]  ;; el valor inicial d'i i r és 1
       (if (<= i 1)
          r
          (recur (dec i) (* r i)))))
          
(factorial 0) 👉 1
(factorial 1) 👉 1
(factorial 4) 👉 24
(factorial 5) 👉 120
(factorial 6) 👉 720
(factorial 1000)  👉 Execution error (ArithmeticException)
(factorial 1000N) 👉 4023872600...00000N  (2568 dígits!)
        
```

Tornarem a trobar `recur` més endavant en un context més general i entendrem el per què d'aquesta manera 
tan _estranya_ de definir els bucles.

---

class: center, middle

# Sessió 02

---

# Conceptes Avançats de Programació

Definim la funció _subfactorial_ d'un nombre enter no negatiu:

$$!0 = 1$$ 
$$!1 = 0$$
$$!2 = 1$$
$$!n = (n-1)*(!(n-1) + !(n-2)) \text{  si $n > 2$}$$

Solució recursiva lineal, ineficient<sup>.red[1]</sup>:

```Clojure
(defn subfact_lineal [n]
   (cond
      (or (= n 0)  (= n 2))   1
      (= n 1)                 0
      :else (*' (dec n) (+' (subfact_lineal (dec n)) (subfact_lineal (- n 2))))))

(subfact_lineal     2) 👉 1
(subfact_lineal    10) 👉 1334961
(subfact_lineal    23) 👉 9510425471055777937262N
(subfact_lineal 10000) 👉 Execution error (StackOverflowError)
```

.footnote[.red[1] Les operacions `+'` i `*'` són per treballar amb nombres enters molt grans. Les operacions `+`
i `*` generen _overflow_.]

---

# Conceptes Avançats de Programació

Provem de fer-ne una versió recursiva final:

```Clojure
(defn subfact_final 
    ([n]  (cond
              (or (= n 0)  (= n 2))   1
              (= n 1)                 0
              :else  (subfact_final n 2 0 1)))
    ([n k nm1 nm2]  (if (> k n)
                       nm1
                       (subfact_final n (inc k) (*' (dec k) (+' nm1 nm2)) nm1))))

(subfact_final     2) 👉 1
(subfact_final    10) 👉 1334961
(subfact_final    23) 👉 9510425471055777937262N
(subfact_final 10000) 👉 Execution error (StackOverflowError)
```

No sembla que les coses hagin millorat gaire, _però podrien haver-ho fet_!. 

Una funció recursiva final és essencialment una **_iteració_**, i hi ha llenguatges de programació que optimitzen 
aquest fet: Quan hi ha una crida a funció en **_tail position_** no cal crear cap estructura addicional 
(_stack frame_) per a aquella crida, i així no es consumeix espai. D'això se'n diu **_tail call optimization_** (TCO).

Clojure **no té TCO**, en general, per raons que tenen a veure amb l'arquitectura de la JVM.

---

# Conceptes Avançats de Programació

## La _special form_ `recur`

Podem dir-li a Clojure explícitament que una crida recursiva està en _tail position_ (una funció és recursiva final
si totes les crides recursives estan en _tail position_) fent servir `recur`:

```Clojure
(defn subfact_recur 
    ([n]  (cond
              (or (= n 0)  (= n 2))   1
              (= n 1)                 0
              :else  (subfact_recur n 2 0 1)))
    ([n k nm1 nm2]  (if (> k n)
                       nm1
                       (recur n (inc k) (*' (dec k) (+' nm1 nm2)) nm1))))

(subfact_recur     2) 👉 1
(subfact_recur    10) 👉 1334961
(subfact_recur    23) 👉 9510425471055777937262N
(subfact_recur 10000) 👉 10470804208445737513419...39696860001N (35660 dígits!)
```

Ara evitem l'_StackOverflowError_, ja que l'avaluació de `subfact_recur` no consumeix espai addicional. `recur`
serveix per dir-li a Clojure que faci TCO. Ara bé, `recur` _només es pot fer servir en tail position_!

---

# Conceptes Avançats de Programació

## _Tail Position_

![:scale 100%](figures/tail_position.png)

.tiny[.red[Source]: _The Joy of Clojure_, p. 160]

---

# Conceptes Avançats de Programació

## La _special form_ `recur`

Finalment, podem fer una versió _iterativa_:

```Clojure
(defn subfact_iter
    [n]
    (cond
       (or (= n 0)  (= n 2))   1
       (= n 1)                 0
       :else (loop [k 2 nm1 0 nm2 1]
                 (if (> k n)
                    nm1
                    (recur (inc k) (*' (dec k) (+' nm1 nm2)) nm1)))))

(subfact_iter     2) 👉 1
(subfact_iter    10) 👉 1334961
(subfact_iter    23) 👉 9510425471055777937262N
(subfact_iter 10000) 👉 10470804208445737513419...39696860001N (35660 dígits!)
```

Ara podem entendre millor l'ús de `recur` per definir les iteracions a Clojure. En realitat el que es fa és 
considerar un bucle com una mena de funció recursiva final _implícita_.


**Exercici**: Compareu la versió iterativa amb la recursiva final.

---

# Conceptes Avançats de Programació

## Les col·leccions: Vectors (I)

Són col·leccions d'elements en un ordre determinat, similars a les llistes, però són **_molt més eficients_**. 
Els preferirem a les llistes, ja que l'accés a un element via un **_índex_** té un cost quasi-constant, i no són
expressions, per tant no cal fer servir `quote`.

Un vector literal té la notació `[1 2 \t "hi" :k]`, és a dir, elements entre claudàtors. El primer element té índex 0.

Exemples:

```Clojure
[1 2 (+ 1 2)] 👉 [1 2 3]

(def nums (vec '(1 2 3 4 5))) 👉 #'user/nums  ;; convertim llista en vector`
nums 👉 [1 2 3 4 5]
(get nums 3) 👉 4
(nums 3)     👉 4

(vector \a \b \c) 👉 [\a \b \c]

(conj nums 6 7) 👉 [1 2 3 4 5 6 7]
(conj '(1 2 3 4 5) 6 7) 👉 (7 6 1 2 3 4 5) ;; ep!!
```

---

# Conceptes Avançats de Programació

## Les col·leccions: Vectors (II)

Suposem que hem fet `(def v [\a "c" 20 :k])`

.cols5050[
.col1[
`first` - `(first v) 👉 \a`

`cons` - `(cons 'a v)`👉<br>
&emsp;&emsp;&emsp;&emsp;&emsp;`(a \a "c" 20 :k)` **(!)**

`rest` - `(rest v) 👉 ("c" 20 :k)` **(!)**

`next` - `(next v) 👉 ("c" 20 :k)` **(!)**

però

`rest` - `(rest []) 👉 ()` **(!)**

`next` - `(next []) 👉 nil`

`conj` - `(conj v 'a)`👉<br>
&emsp;&emsp;&emsp;&emsp;&emsp;`[\a "c" 20 :k a]`
]
.col2[
`peek` - `(peek v) 👉 :k`

`pop` - `(pop v) 👉 [\a "c" 20]`

`vector` - `(vector \a "c" 20 :k)` 👉 
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`[\a "c" 20 :k]` 

`vector?` - `(vector? v) 👉 true`

`count` - `(count v) 👉 4`

`empty?` - `(empty? v) 👉 false`

`subvec` - `(subvec v 2 4) 👉 [20 :k]`

`assoc` - `(assoc v 1 -100) 👉 `
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`[\a -100 20 :k]`
]]
