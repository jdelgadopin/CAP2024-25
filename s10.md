class: center, up

# CAP - Avaluaci贸 Mandrosa

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Avaluaci贸 mandrosa (_lazy_) vs. Avaluaci贸 Ansiosa (_eager_)

Clojure **NO** 茅s un llenguatge amb [avaluaci贸 mandrosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

Quan s'invoca una funci贸 en Clojure, els seus parmetres s'avaluen abans de la crida. 
En aquest context, podr铆em dir que el contrari de _mandr贸s_ (_lazy_) 茅s _ansi贸s_ (_eager_).
Aix铆 doncs, Clojure 茅s un llenguatge amb avaluaci贸 _ansiosa_.

Els llenguatges de programaci贸 amb avaluaci贸 mandrosa, p.ex. Haskell, nom茅s avaluen
els arguments d'una funci贸 si cal. Per exemple:

```Haskell
f = \x y -> x

f 2 3      2
f 2 (1/0)  2
```
En canvi, en Clojure:

```Clojure
(defn f [x y] x)

(f 2 3)        2
(f 2 (/ 1 0))  Execution error (ArithmeticException)
```
El que s铆 fa Clojure 茅s permetre utilitzar **_lazy sequences_**.

---

## _Lazy Sequences_

Una **_lazy _sequence_** (**_seq眉猫ncia mandrosa_** (!?)) 茅s aquella en
que els elements de la seq眉猫ncia no estan disponibles amb antelaci贸 i
es produeixen com a resultat d'un clcul. El clcul es realitza segons
calgui. L'avaluaci贸 de seq眉猫ncies mandroses es coneix com a **_realitzaci贸_**.

