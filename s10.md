class: center, up

# CAP - Avaluació Mandrosa

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Avaluació mandrosa (_lazy_) vs. Avaluació Ansiosa (_eager_)

Clojure **NO** és un llenguatge amb [avaluació mandrosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

Quan s'invoca una funció en Clojure, els seus paràmetres s'avaluen abans de la crida. 
En aquest context, podríem dir que el contrari de _mandrós_ (_lazy_) és _ansiós_ (_eager_).
Així doncs, Clojure és un llenguatge amb avaluació _ansiosa_.

Els llenguatges de programació amb avaluació mandrosa, p.ex. Haskell, només avaluen
els arguments d'una funció si cal. Per exemple:

```Haskell
f = \x y -> x

f 2 3     👉 2
f 2 (1/0) 👉 2
```
En canvi, en Clojure:

```Clojure
(defn f [x y] x)

(f 2 3)       👉 2
(f 2 (/ 1 0)) 👉 Execution error (ArithmeticException)
```
El que sí fa Clojure és permetre utilitzar **_lazy sequences_**.

---

## _Lazy Sequences_

Una **_lazy _sequence_** (**_seqüència mandrosa_** (!?)) és aquella en
que els elements de la seqüència no estan disponibles amb antelació i
es produeixen com a resultat d'un càlcul. El càlcul es realitza segons
calgui. L'avaluació de seqüències mandroses es coneix com a **_realització_**.

