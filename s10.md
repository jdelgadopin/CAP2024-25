class: center, up

# CAP - Avaluaci√≥ Mandrosa

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Avaluaci√≥ mandrosa (_lazy_) vs. Avaluaci√≥ Ansiosa (_eager_)

Clojure **NO** √©s un llenguatge amb [avaluaci√≥ mandrosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

Quan s'invoca una funci√≥ en Clojure, els seus par√†metres s'avaluen abans de la crida. 
En aquest context, podr√≠em dir que el contrari de _mandr√≥s_ (_lazy_) √©s _ansi√≥s_ (_eager_).
Aix√≠ doncs, Clojure √©s un llenguatge amb avaluaci√≥ _ansiosa_.

Els llenguatges de programaci√≥ amb avaluaci√≥ mandrosa, p.ex. Haskell, nom√©s avaluen
els arguments d'una funci√≥ si cal. Per exemple:

```Haskell
f = \x y -> x

f 2 3     üëâ 2
f 2 (1/0) üëâ 2
```
En canvi, en Clojure:

```Clojure
(defn f [x y] x)

(f 2 3)       üëâ 2
(f 2 (/ 1 0)) üëâ Execution error (ArithmeticException)
```
El que s√≠ fa Clojure √©s permetre utilitzar **_lazy sequences_**.

---

## _Lazy Sequences_

Una **_lazy sequence_** (**_seq√º√®ncia mandrosa_** (!?)) √©s aquella en
que els elements de la seq√º√®ncia no estan disponibles amb antelaci√≥ i
es produeixen com a resultat d'un c√†lcul. El c√†lcul es realitza segons
calgui. L'avaluaci√≥ de seq√º√®ncies mandroses es coneix com a **_realitzaci√≥_**.

Cal considerar un aspecte subtil: Parlem de _lazy **sequences**_
perqu√® les seq√º√®ncies s√≥n les √∫niques que s√≥n _lazy_. Els vectors no
ho s√≥n. Els diccionaris no ho s√≥n. D'aqu√≠ que moltes de les funcions
d'ordre superior que hem vist retornin seq√º√®ncies.

Les funcions de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
(com per exemple `map`, `filter`, `concat`, `take`, etc.) s√≥n **_lazy-friendly_**: Aix√≤ vol dir que si reben com a argument una seq√º√®ncia _lazy_ 
no imposen la seva realitzaci√≥, i que generen seq√º√®ncies _lazy_ (fins i tot si han 
rebut un vector o una col¬∑lecci√≥ no-_lazy_ com a argument). 

Tamb√© generen seq√º√®ncies _lazy_ aquelles funcions que retornen
seq√º√®ncies "infinites" (`iterate`, `repeat`, `range`, etc.)

Finalment, els nostres programes poden generar seq√º√®ncies _lazy_ fent servir constructors
de seq√º√®ncies _lazy_:
`lazy-seq` o `lazy-cat`, per exemple.

---

## _Lazy Sequences_

Veiem alguns exemples:

```Clojure
;;     Multipliquem per 2 a tots els naturals. Obviament √©s lazy
;;             ------------------------------
(let [seqlazy1 (map #(* % 2) (iterate inc 1))

;;     Aquesta seq√º√®ncia tamb√© √©s lazy, encara que no sigui "infinita"
;;             -------------------
      seqlazy2 (take 100 seqlazy1)

;;     El resultat √©s lazy, encara que l'argument no ho sigui
;;             -------------------
      seqlazy3 (map inc [1 2 3 4])]

;; Aquest resultat ja NO √©s lazy, tot i que l'argument s√≠ que ho √©s
;; --------------
   (vec seqlazy3)) üëâ [2 3 4 5]
```
---

## _Lazy Sequences_

En un intent de fer l'√∫s de seq√º√®ncies _lazy_ m√©s eficient, Clojure fa el que s'anomena 
**_sequence chunking_**. Aix√≤ vol dir que quan es demana la realitzaci√≥ d'elements
de seq√º√®ncies _lazy_, aix√≤ es fa en blocs de 32 elements:

```Clojure
;; |--- Nom√©s demano el primer element de la seq√º√®ncia lazy!
;; v
(first (map #(do (print % " ") (identity %)) (range 100)))
üëÅÔ∏è 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 
üëâ 0
```
Hem demanat el primer element de la seq√º√®ncia, per tant nom√©s calia que es realitz√©s
aquest. Fixem-nos, per√≤, que s'han realitzat els 32 primers, √©s a dir, s'ha calculat el resultat
d'aplicar la funci√≥ `#(do (print % " ") (identity %))` als 32 primers elements
de `(range 100)`).

