class: center, up

# CAP - AvaluaciÃ³ Mandrosa

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## AvaluaciÃ³ mandrosa (_lazy_) vs. AvaluaciÃ³ Ansiosa (_eager_)

Clojure **NO** Ã©s un llenguatge amb [avaluaciÃ³ mandrosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

Quan s'invoca una funciÃ³ en Clojure, els seus parÃ metres s'avaluen abans de la crida. 
En aquest context, podrÃ­em dir que el contrari de _mandrÃ³s_ (_lazy_) Ã©s _ansiÃ³s_ (_eager_).
AixÃ­ doncs, Clojure Ã©s un llenguatge amb avaluaciÃ³ _ansiosa_.

Els llenguatges de programaciÃ³ amb avaluaciÃ³ mandrosa, p.ex. Haskell, nomÃ©s avaluen
els arguments d'una funciÃ³ si cal. Per exemple:

```Haskell
f = \x y -> x

f 2 3     ğŸ‘‰ 2
f 2 (1/0) ğŸ‘‰ 2
```
En canvi, en Clojure:

```Clojure
(defn f [x y] x)

(f 2 3)       ğŸ‘‰ 2
(f 2 (/ 1 0)) ğŸ‘‰ Execution error (ArithmeticException)
```
El que sÃ­ fa Clojure Ã©s permetre utilitzar **_lazy sequences_**.

---

## _Lazy Sequences_

Una **_lazy sequence_** (**_seqÃ¼Ã¨ncia mandrosa_** (!?)) Ã©s aquella en
que els elements de la seqÃ¼Ã¨ncia no estan disponibles amb antelaciÃ³ i
es produeixen com a resultat d'un cÃ lcul. El cÃ lcul es realitza segons
calgui. L'avaluaciÃ³ de seqÃ¼Ã¨ncies mandroses es coneix com a **_realitzaciÃ³_**.

Cal considerar un aspecte subtil: Parlem de _lazy **sequences**_
perquÃ¨ les seqÃ¼Ã¨ncies sÃ³n les Ãºniques que sÃ³n _lazy_. Els vectors no
ho sÃ³n. Els diccionaris no ho sÃ³n. D'aquÃ­ que moltes de les funcions
d'ordre superior que hem vist retornin seqÃ¼Ã¨ncies.

Les funcions de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
(com per exemple `map`, `filter`, `concat`, `take`, etc.) sÃ³n **_lazy-friendly_**: AixÃ² vol dir que si reben com a argument una seqÃ¼Ã¨ncia _lazy_ 
no imposen la seva realitzaciÃ³, i que generen seqÃ¼Ã¨ncies _lazy_ (fins i tot si han 
rebut un vector o una colÂ·lecciÃ³ no-_lazy_ com a argument). 

TambÃ© generen seqÃ¼Ã¨ncies _lazy_ aquelles funcions que retornen
seqÃ¼Ã¨ncies "infinites" (`iterate`, `repeat`, `range`, etc.)

Finalment, els nostres programes poden generar seqÃ¼Ã¨ncies _lazy_ fent servir constructors
de seqÃ¼Ã¨ncies _lazy_:
`lazy-seq` o `lazy-cat`, per exemple.

---

## _Lazy Sequences_

El fet que la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
tingui funcions _lazy-friendly_ tÃ© conseqÃ¼Ã¨ncies importants, com per exemple que poguÃ©ssim
manipular llistes (aparentment!) infinites, o que puguem ajornar cÃ lculs "cars" fins el punt que
siguin realment imprescindibles.

Veiem alguns exemples:

```Clojure
;;     Multipliquem per 2 a tots els naturals. Obviament Ã©s lazy
;;             ------------------------------
(let [seqlazy1 (map #(* % 2) (iterate inc 1))

;;     Aquesta seqÃ¼Ã¨ncia tambÃ© Ã©s lazy, encara que no sigui "infinita"
;;             -------------------
      seqlazy2 (take 100 seqlazy1)

;;     El resultat Ã©s lazy, encara que l'argument no ho sigui
;;             -------------------
      seqlazy3 (map inc [1 2 3 4])]

;; Aquest resultat ja NO Ã©s lazy, tot i que l'argument sÃ­ que ho Ã©s
;; --------------
   (vec seqlazy3)) ğŸ‘‰ [2 3 4 5]

```
---

## _Lazy Sequences_

GrÃ cies als efectes colaterals (_side effects_) Ã©s fÃ cil veure que
les funcions que ja coneixem de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
generen en realitat seqÃ¼Ã¨ncies _lazy_.

```Clojure
user=> (def result (map println [:a :b :c]))
#'user/result
user=> 
```
Com? No s'ha aplicat la funciÃ³ `println` als elements del vector `[1 2 3]`?

El que ha passat Ã©s que la seqÃ¼Ã¨ncia resultant del `map` Ã©s _lazy_, per tant no
es realitzarÃ  mentre no faci falta. Si forcem la realitzaciÃ³:

```Clojure
user=> result
:a
:b
:c
(nil nil nil)

user=> result
(nil nil nil)
```
Ara s'ha executat `println` per a cada
un dels elements de `[1 2 3]`. `(nil nil nil)` Ã©s resultat de que el valor de 
retorn de `println` Ã©s `nil`.


---

## _Lazy Sequences_: _doall_

**`doall` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. El podem fer servir per fer alguns experiments
per veure que manipular seqÃ¼Ã¨ncies _lazy_ i realitzar-les nomÃ©s _quan_ (o _si_) cal pot resultar
en programes mÃ©s eficients:

```Clojure
(time (doall (map (fn [x] 
                    (loop [i 1] (if (> i 1E+9) 1 (recur (inc i))))) 
                  (range 10))))
ğŸ‘ï¸ "Elapsed time: 8746.204096 msecs" ;; 8 segons!
ğŸ‘‰ (1 1 1 1 1 1 1 1 1 1)
```
Com hem dit abans, `map` retorna una seqÃ¼Ã¨ncia _lazy_, per tant fixem-nos que si no realitzem el
resultat...

```Clojure
(time (def no-realitzada 
           (map (fn [x] 
                  (loop [i 1] (if (> i 1E+9) 1 (recur (inc i))))) 
                (range 10))))
ğŸ‘ï¸ "Elapsed time: 0.038851 msecs"
ğŸ‘‰ #'user/no-realitzada

no-realitzada ğŸ‘‰ (1 1 1 1 1 1 1 1 1 1) ;; i ara sÃ­ que ha trigat 8 segons
```
... no s'inverteix temps en cap cÃ lcul. Senzillament es construeix una seqÃ¼Ã¨ncia _lazy_ que
estÃ  _pendent_ de realitzaciÃ³.

---

## _Lazy Sequences_: _Sequence Chunking_

En un intent de fer l'Ãºs de seqÃ¼Ã¨ncies _lazy_ mÃ©s eficient, Clojure fa el que s'anomena 
**_sequence chunking_**. AixÃ² vol dir que quan es demana la realitzaciÃ³ d'elements
de seqÃ¼Ã¨ncies _lazy_, aixÃ² es fa en blocs de 32 elements:

```Clojure
;; |--- NomÃ©s demano el primer element de la seqÃ¼Ã¨ncia lazy!
;; v
(first (map #(do (print % " ") (identity %)) (range 100)))
ğŸ‘ï¸ 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 
ğŸ‘‰ 0
```
Hem demanat el primer element de la seqÃ¼Ã¨ncia, per tant nomÃ©s calia que es realitzÃ©s
aquest. Fixem-nos, perÃ², que s'han realitzat els 32 primers, Ã©s a dir, s'ha calculat el resultat
d'aplicar la funciÃ³ `#(do (print % " ") (identity %))` als 32 primers elements
de `(range 100)`).

Ã‰s una manera d'_amortitzar_ el cost -per element- de generar elements. Per exemple,
fixem-nos que si demanem 33 elements, acabem realitzant-ne 64.

---

## _Lazy Sequences_: _lazy-seq_

---

## _Lazy Sequences_: _dorun_

---

## _Lazy Sequences_: _delay_ & _force_

---

## _Lazy Sequences_: SeqÃ¼Ã¨ncies "infinites"

---

## _Lazy Sequences_: Exercicis Recapitulatoris

---

