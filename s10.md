class: center, up

# CAP - Avaluació Mandrosa

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Avaluació mandrosa (_lazy_) vs. Avaluació Ansiosa (_eager_)

Clojure **NO** és un llenguatge amb [avaluació mandrosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

Quan s'invoca una funció en Clojure, els seus paràmetres s'avaluen abans de la crida. 
En aquest context, podríem dir que el contrari de _mandrós_ (_lazy_) és _ansiós_ (_eager_).
Així doncs, Clojure és un llenguatge amb avaluació _ansiosa_.

Els llenguatges de programació amb avaluació mandrosa, p.ex. Haskell, només avaluen
els arguments d'una funció si cal. Per exemple:

```Haskell
f = \x y -> x

f 2 3     👉 2
f 2 (1/0) 👉 2
```
En canvi, en Clojure:

```Clojure
(defn f [x y] x)

(f 2 3)       👉 2
(f 2 (/ 1 0)) 👉 Execution error (ArithmeticException)
```
El que sí fa Clojure és permetre utilitzar **_lazy sequences_**.

---

## _Lazy Sequences_

Una **_lazy sequence_** (**_seqüència mandrosa_** (!?)) és aquella en
que els elements de la seqüència no estan disponibles amb antelació i
es produeixen com a resultat d'un càlcul. El càlcul es realitza segons
calgui. L'avaluació de seqüències mandroses es coneix com a **_realització_**.

Cal considerar un aspecte subtil: Parlem de _lazy **sequences**_
perquè les seqüències són les úniques que són _lazy_. Els vectors no
ho són. Els diccionaris no ho són. D'aquí que moltes de les funcions
d'ordre superior que hem vist retornin seqüències.

Les funcions de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
(com per exemple `map`, `filter`, `concat`, `take`, etc.) són **_lazy-friendly_**: Això vol dir que si reben com a argument una seqüència _lazy_ 
no imposen la seva realització, i que generen seqüències _lazy_ (fins i tot si han 
rebut un vector o una col·lecció no-_lazy_ com a argument). 

També generen seqüències _lazy_ aquelles funcions que retornen
seqüències "infinites" (`iterate`, `repeat`, `range`, etc.)

Finalment, els nostres programes poden generar seqüències _lazy_ fent servir constructors
de seqüències _lazy_:
`lazy-seq` o `lazy-cat`, per exemple.

---

## _Lazy Sequences_

El fet que la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
tingui funcions _lazy-friendly_ té conseqüències importants, com per exemple que poguéssim
manipular llistes (aparentment!) infinites, o que puguem ajornar càlculs "cars" fins el punt que
siguin realment imprescindibles.

Veiem alguns exemples:

```Clojure
;;     Multipliquem per 2 a tots els naturals. Obviament és lazy
;;             ------------------------------
(let [seqlazy1 (map #(* % 2) (iterate inc 1))

;;     Aquesta seqüència també és lazy, encara que no sigui "infinita"
;;             -------------------
      seqlazy2 (take 100 seqlazy1)

;;     El resultat és lazy, encara que l'argument no ho sigui
;;             -------------------
      seqlazy3 (map inc [1 2 3 4])]

;; Aquest resultat ja NO és lazy, tot i que l'argument sí que ho és
;; --------------
   (vec seqlazy3)) 👉 [2 3 4 5]

```
---

## _Lazy Sequences_

Gràcies als efectes colaterals (_side effects_) és fàcil veure que
les funcions que ja coneixem de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
generen en realitat seqüències _lazy_.

```Clojure
user=> (def result (map println [:a :b :c]))
#'user/result
user=> 
```
Com? No s'ha aplicat la funció `println` als elements del vector `[1 2 3]`?

El que ha passat és que la seqüència resultant del `map` és _lazy_, per tant no
es realitzarà mentre no faci falta. Si forcem la realització:

```Clojure
user=> result
:a
:b
:c
(nil nil nil)

user=> result
(nil nil nil)
```
Ara s'ha executat `println` per a cada
un dels elements de `[1 2 3]`. `(nil nil nil)` és resultat de que el valor de 
retorn de `println` és `nil`.


---

## _Lazy Sequences_: _doall_

**`doall` serveix per realitzar una seqüència _lazy_**. El podem fer servir per fer alguns experiments
per veure que manipular seqüències _lazy_ i realitzar-les només _quan_ (o _si_) cal pot resultar
en programes més eficients:

```Clojure
(time (doall (map (fn [x] 
                    (loop [i 1] (if (> i 1E+9) 1 (recur (inc i))))) 
                  (range 10))))
👁️ "Elapsed time: 8746.204096 msecs" ;; 8 segons!
👉 (1 1 1 1 1 1 1 1 1 1)
```
Com hem dit abans, `map` retorna una seqüència _lazy_, per tant fixem-nos que si no realitzem el
resultat...

```Clojure
(time (def no-realitzada 
           (map (fn [x] 
                  (loop [i 1] (if (> i 1E+9) 1 (recur (inc i))))) 
                (range 10))))
👁️ "Elapsed time: 0.038851 msecs"
👉 #'user/no-realitzada

no-realitzada 👉 (1 1 1 1 1 1 1 1 1 1) ;; i ara sí que ha trigat 8 segons
```
... no s'inverteix temps en cap càlcul. Senzillament es construeix una seqüència _lazy_ que
està _pendent_ de realització.

---

## _Lazy Sequences_: _Sequence Chunking_

En un intent de fer l'ús de seqüències _lazy_ més eficient, Clojure fa el que s'anomena 
**_sequence chunking_**. Això vol dir que quan es demana la realització d'elements
de seqüències _lazy_, això es fa en blocs de 32 elements:

```Clojure
;; |--- Només demano el primer element de la seqüència lazy!
;; v
(first (map #(do (print % " ") (identity %)) (range 100)))
👁️ 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 
👉 0
```
Hem demanat el primer element de la seqüència, per tant només calia que es realitzés
aquest. Fixem-nos, però, que s'han realitzat els 32 primers, és a dir, s'ha calculat el resultat
d'aplicar la funció `#(do (print % " ") (identity %))` als 32 primers elements
de `(range 100)`).

És una manera d'_amortitzar_ el cost -per element- de generar elements. Per exemple,
fixem-nos que si demanem 33 elements, acabem realitzant-ne 64.

---

## _Lazy Sequences_: _lazy-seq_

---

## _Lazy Sequences_: _dorun_

---

## _Lazy Sequences_: _delay_ & _force_

---

## _Lazy Sequences_: Seqüències "infinites"

---

## _Lazy Sequences_: Exercicis Recapitulatoris

---

