class: center, up

# CAP - AvaluaciÃ³ Mandrosa

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## AvaluaciÃ³ mandrosa (_lazy_) vs. AvaluaciÃ³ Ansiosa (_eager_)

Clojure **NO** Ã©s un llenguatge amb [avaluaciÃ³ mandrosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

Quan s'invoca una funciÃ³ en Clojure, els seus parÃ metres s'avaluen abans de la crida. 
En aquest context, podrÃ­em dir que el contrari de _mandrÃ³s_ (_lazy_) Ã©s _ansiÃ³s_ (_eager_).
AixÃ­ doncs, Clojure Ã©s un llenguatge amb avaluaciÃ³ _ansiosa_.

Els llenguatges de programaciÃ³ amb avaluaciÃ³ mandrosa, p.ex. Haskell, nomÃ©s avaluen
els arguments d'una funciÃ³ si cal. Per exemple:

```Haskell
f = \x y -> x

f 2 3     ğŸ‘‰ 2
f 2 (1/0) ğŸ‘‰ 2
```
En canvi, en Clojure:

```Clojure
(defn f [x y] x)

(f 2 3)       ğŸ‘‰ 2
(f 2 (/ 1 0)) ğŸ‘‰ Execution error (ArithmeticException)
```
El que sÃ­ fa Clojure Ã©s permetre utilitzar **_lazy sequences_**.

---

## _Lazy Sequences_

Una **_lazy sequence_** (**_seqÃ¼Ã¨ncia mandrosa_** (!?)) Ã©s aquella en
que els elements de la seqÃ¼Ã¨ncia no estan disponibles amb antelaciÃ³ i
es produeixen com a resultat d'un cÃ lcul. El cÃ lcul es realitza segons
calgui. L'avaluaciÃ³ de seqÃ¼Ã¨ncies mandroses es coneix com a **_realitzaciÃ³_**.

Cal considerar un aspecte subtil: Parlem de _lazy **sequences**_
perquÃ¨ les seqÃ¼Ã¨ncies sÃ³n les Ãºniques que sÃ³n _lazy_. Els vectors no
ho sÃ³n. Els diccionaris no ho sÃ³n. D'aquÃ­ que moltes de les funcions
d'ordre superior que hem vist retornin seqÃ¼Ã¨ncies.

Les funcions de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
(com per exemple `map`, `filter`, `concat`, `take`, etc.) sÃ³n **_lazy-friendly_**: AixÃ² vol dir que si reben com a argument una seqÃ¼Ã¨ncia _lazy_ 
no imposen la seva realitzaciÃ³, i que generen seqÃ¼Ã¨ncies _lazy_ (fins i tot si han 
rebut un vector o una colÂ·lecciÃ³ no-_lazy_ com a argument). 

TambÃ© generen seqÃ¼Ã¨ncies _lazy_ aquelles funcions que retornen
seqÃ¼Ã¨ncies "infinites" (`iterate`, `repeat`, `range`, etc.)

Finalment, els nostres programes poden generar seqÃ¼Ã¨ncies _lazy_ fent servir constructors
de seqÃ¼Ã¨ncies _lazy_:
`lazy-seq` o `lazy-cat`, per exemple.

---

## _Lazy Sequences_

El fet que la [_Clojure sequence
library_](https://clojure.org/reference/sequences#_the_seq_library)
tingui funcions _lazy-friendly_ tÃ© conseqÃ¼Ã¨ncies importants. Fins ara
hem fet servir aquestes funcions ignorant la seva _laziness_ implÃ­cita. Cal, perÃ², que
coneguem finalment quin Ã©s el funcionament real d'aquestes funcions.

Veiem alguns exemples (haver d'escriure -_print_- les seqÃ¼Ã¨ncies _lazy_ al REPL fa
que es realitzin):

```Clojure
;; Multipliquem per 2 a tots els naturals. Obviament Ã©s lazy
;;
(def sl1 (map #(* % 2) (iterate inc 1)))

;; Aquesta seqÃ¼Ã¨ncia tambÃ© Ã©s lazy, encara que no sigui "infinita"
;;
(take 15 sl1) ğŸ‘‰ (2 4 6 8 10 12 14 16 18 20 22 24 26 28 30)

;; El resultat Ã©s lazy, encara que l'argument no ho sigui
;;
(def sl2 (map inc [1 2 3 4])

;; Aquest resultat ja NO Ã©s lazy, tot i que l'argument sÃ­ que ho Ã©s
;;
(vec sl2) ğŸ‘‰ [2 3 4 5]

;; Obtenir 10 nombres enters aleatoris entre 0 i 99
;;
(take 10 (repeatedly #(rand-int 100))) ğŸ‘‰ (80 52 30 29 10 52 39 69 22 53)

```
---

## _Lazy Sequences_

GrÃ cies als efectes colaterals (_side effects_) Ã©s fÃ cil veure que
les funcions que ja coneixem de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
generen en realitat seqÃ¼Ã¨ncies _lazy_.

```Clojure
user=> (def result (map println [:a :b :c]))
#'user/result
user=> 
```
Com? No s'ha aplicat la funciÃ³ `println` als elements del vector `[1 2 3]`?

El que ha passat Ã©s que la seqÃ¼Ã¨ncia resultant del `map` Ã©s _lazy_, per tant no
es realitzarÃ  mentre no faci falta. Si forcem la realitzaciÃ³:

```Clojure
user=> result
:a
:b
:c
(nil nil nil)

user=> result
(nil nil nil)
```
Ara s'ha executat `println` per a cada
un dels elements de `[1 2 3]`. `(nil nil nil)` Ã©s resultat de que el valor de 
retorn de `println` Ã©s `nil`.

---

## _Lazy Sequences_: _doall_

**`doall` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. 

Veiem-ne exemples:

En aquest exemple, `take` rep una seqÃ¼Ã¨ncia _lazy_ i retorna una
seqÃ¼Ã¨ncia _lazy_, per tant no s'executa res fins que no es realitza:

```Clojure
(let [x (atom 0)]
   (take 10 (repeatedly #(swap! x inc)))
   @x) ğŸ‘‰ 0
```
`doall` serveix per forÃ§ar la realitzaciÃ³ de la seqÃ¼Ã¨ncia:

```Clojure
(let [x (atom 0)]
   (doall (take 10 (repeatedly #(swap! x inc))))
   @x) ğŸ‘‰ 10
```

Un altre exemple, `range` Ã©s _lazy_:

```Clojure
(time (nth (range 1 100000000 4) 16)) ğŸ‘‰ 65
ğŸ‘ï¸ "Elapsed time: 0.017652 msecs"
(time (nth (doall (range 1 100000000 4)) 16)) ğŸ‘‰ 65
ğŸ‘ï¸ "Elapsed time: 1686.357028 msecs"
```
.tiny[.red[Font]: [clojuredocs.org/clojure.core/doall](https://clojuredocs.org/clojure.core/doall)]

---

## _Lazy Sequences_: _doall_

**`doall` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. 

El podem fer servir per fer alguns experiments interessants:

```Clojure
(time (doall (map (fn [x] 
                    (loop [i 1] (if (> i 1E+9) 1 (recur (inc i))))) 
                  (range 10))))
ğŸ‘ï¸ "Elapsed time: 8746.204096 msecs" ;; 8 segons!
ğŸ‘‰ (1 1 1 1 1 1 1 1 1 1)
```
Com hem dit abans, `map` retorna una seqÃ¼Ã¨ncia _lazy_, per tant fixem-nos que si no realitzem el
resultat...

```Clojure
(time (def no-realitzada 
           (map (fn [x] 
                  (loop [i 1] (if (> i 1E+9) 1 (recur (inc i))))) 
                (range 10))))
ğŸ‘ï¸ "Elapsed time: 0.038851 msecs"
ğŸ‘‰ #'user/no-realitzada

no-realitzada ğŸ‘‰ (1 1 1 1 1 1 1 1 1 1) ;; i ara sÃ­ que ha trigat 8 segons
```
... no s'inverteix temps en cap cÃ lcul. Senzillament es construeix una seqÃ¼Ã¨ncia _lazy_ que
estÃ  _pendent_ de realitzaciÃ³.

---

## _Lazy Sequences_: _doall_

**`doall` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. 

El podem fer servir per fer alguns experiments interessants: 

En aquest experiment podem veure que les seqÃ¼Ã¨ncies _lazy_ en Clojure es guarden en memÃ²ria
(sÃ³n _cached_):

```Clojure
(let [s (time (map #(Thread/sleep %) (range 0 150 10)))]
  (time (doall s))
  (time (doall s)))
  
"Elapsed time: 0.029905 msecs"
"Elapsed time: 1903.846528 msecs"
"Elapsed time: 0.021917 msecs"
ğŸ‘‰ (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)

```
Si ens fixem, el segon cop que realitzem `s` no es triguen els 1.9 segons que triguem
el primer cop. El resultat de realitzar `s` s'ha guardat.

<br>
.tiny[<ins>Nota</ins>: Hem fet servir `Thread/sleep` nomÃ©s per provocar un alentiment 
de l'execuciÃ³ del codi. Aquesta funciÃ³, sense entrar en detalls, fa que el _thread_ 
s'aturi un cert nombre de milisegons (aproximadament).]

---

## _Lazy Sequences_: _lazy-seq_

En Clojure es poden fer funcions que generin seqÃ¼Ã¨ncies _lazy_ amb `lazy-seq`.

Per exemple, podrÃ­em fer la nostra versiÃ³ de `iterate` i utilitzar-la en
diversos exemples:

```Clojure
(defn my-iterate [f x] ;; f ha de ser pura
  (lazy-seq
    (cons x (my-iterate f (f x)))))  ;; no hi ha cas base

(def powers-of-two (my-iterate (partial * 2) 1))

(nth powers-of-two 10) ğŸ‘‰ 1024

;; Calculem Ï€ amb la fÃ²rmula de Leibniz:
;; Ï€/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + 1/13...
(defn pi [n]
  (let [termes (map #(/ 4 %) (my-iterate #(* ((if (pos? %) + -) % 2) -1) 1.0))]
    (apply + (take n termes))))
    
;; Convergeix molt lentament. Segons la Wikipedia:
;; Calculating Ï€ to 10 correct decimal places using direct summation of the series
;; requires precisely five billion terms
(pi 1e7) ğŸ‘‰ 3.1415925535897915
```
---

## _Lazy Sequences_: _lazy-seq_

Durant el curs hem fet les nostres versions de `map`, `filter`, etc. per ilÂ·lustrar diverses tÃ¨cniques. 
Naturalment no hem tingut en compte com de _lazy-friendly_ sÃ³n aquestes funcions. Fent
servir `lazy-seq` sÃ­ que podem fer-ne una implementaciÃ³ prÃ²pia i fidel a l'original:

```Clojure
(defn my-filter [pred coll]
  (let [step (fn [p c]
                 (when-let [s (seq c)]
                   (if (p (first s))
                     (cons (first s) (my-filter p (rest s)))
                     (recur p (rest s)))))]
    (lazy-seq (step pred coll))))

(def s (my-filter #(when (even? %) (do (println %) %)) (range 100))) ğŸ‘‰ #'user/s
(take 5 s) ğŸ‘‰ ;; es confonen l'output de la crida a take i els println
(0
2
0 4
2 6
4 8
6 8)
;; perÃ² el segon cop ja hem realitzat aquest tros de la seqÃ¼Ã¨ncia
(take 5 s) ğŸ‘‰ (0 2 4 6 8)
```
---

## _Lazy Sequences_: _lazy-seq_

Els autors de _The Joy of Clojure_ ens diuen:

_(...) the `lazy-seq` recipe for applying laziness to your own functions:_

1. _Use the `lazy-seq` macro at the outermost level of your lazy sequenceâ€“producing
expression(s)._

2. _If you happen to be consuming another sequence during your operations, then
use `rest` instead of `next`._

3. _Prefer higher-order functions when processing sequences._

4. _Donâ€™t hold on to your head._

<br>.tiny[.red[Font]: _The Joy of Clojure_, p. 126]

---

## _Lazy Sequences_: _dorun_

**`dorun` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. 

PerÃ²..., hem escrit aixÃ² tambÃ© per a `doall`. Quina Ã©s la diferÃ¨ncia?

* `doall` - Guarda en memÃ²ria la seqÃ¼Ã¨ncia mentre forÃ§a la realitzaciÃ³ dels elements. Retorna la seqÃ¼Ã¨ncia.

* `dorun` - No guarda la seqÃ¼Ã¨ncia en memÃ²ria mentre forÃ§a la realitzaciÃ³ dels diversos elements. Retorna `nil`.

PodrÃ­em ilÂ·lustrar la diferÃ¨ncia amb una implementaciÃ³ (simplificada):

```Clojure
(defn dorun [coll]                                   (defn doall [coll] 
  (when (seq coll) (recur (next coll))))               (dorun coll) coll)

user=> (doall (map #(do (prn %) %) [1 2 3]))
1
2
3
(1 2 3)
user=> (dorun (map #(do (prn %) %) [1 2 3]))
1
2
3
nil
```


---

## _Lazy Sequences_: _delay_ & _force_

---

## _Lazy Sequences_: SeqÃ¼Ã¨ncies "infinites"

---

## _Lazy Sequences_: _Sequence Chunking_

En un intent de fer l'Ãºs de seqÃ¼Ã¨ncies _lazy_ mÃ©s eficient, Clojure fa el que s'anomena 
**_sequence chunking_**. AixÃ² vol dir que quan es demana la realitzaciÃ³ d'elements
de seqÃ¼Ã¨ncies _lazy_, aixÃ² es fa en blocs de 32 elements:

```Clojure
;; |--- NomÃ©s demano el primer element de la seqÃ¼Ã¨ncia lazy!
;; v
(first (map #(do (print % " ") (identity %)) (range 100)))
ğŸ‘ï¸ 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 
ğŸ‘‰ 0
```
Hem demanat el primer element de la seqÃ¼Ã¨ncia, per tant nomÃ©s calia que es realitzÃ©s
aquest. Fixem-nos, perÃ², que s'han realitzat els 32 primers, Ã©s a dir, s'ha calculat el resultat
d'aplicar la funciÃ³ `#(do (print % " ") (identity %))` als 32 primers elements
de `(range 100)`).

Ã‰s una manera d'_amortitzar_ el cost -per element- de generar elements. Per exemple,
fixem-nos que si demanem 33 elements, acabem realitzant-ne 64.

---

## _Lazy Sequences_: Exercicis Recapitulatoris

* Fes una funciÃ³ per generar la seqÃ¼Ã¨ncia _ordenada_ dels **nombres de Hamming**:
  [1,2,3,4,5,6,8,9,...]. Els nombres de Hamming sÃ³n aquells que tenen nomÃ©s 2, 3, i/o 5
  com a divisors primers.




---

## _Lazy Sequences_

Per saber-ne mÃ©s:

* _The Joy of Clojure_, seccions 6.3, p. 123, i 6.4, p. 132

* [_Language: Laziness_](https://clojure-doc.org/articles/language/laziness/)

Per a una visiÃ³ crÃ­tica de la _laziness_ i el seu Ãºs a Clojure:

* [_Clojure's Deadly Sin_](https://clojure-goes-fast.com/blog/clojures-deadly-sin/),
entrada del blog d'Oleksandr Yakushev el 27 de Juliol de 2023.


