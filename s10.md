class: center, up

# CAP - SeqÃ¼Ã¨ncies _Lazy_

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## AvaluaciÃ³ mandrosa (_lazy_) vs. AvaluaciÃ³ Ansiosa (_eager_)

Clojure **NO** Ã©s un llenguatge amb [avaluaciÃ³ mandrosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

Quan s'invoca una funciÃ³ en Clojure, els seus parÃ metres s'avaluen abans de la crida. 
En aquest context, podrÃ­em dir que el contrari de _mandrÃ³s_ (_lazy_) Ã©s _ansiÃ³s_ (_eager_).
AixÃ­ doncs, Clojure Ã©s un llenguatge amb avaluaciÃ³ _ansiosa_.

Els llenguatges de programaciÃ³ amb avaluaciÃ³ mandrosa, p.ex. Haskell, nomÃ©s avaluen
els arguments d'una funciÃ³ si cal. Per exemple:

```Haskell
f = \x y -> x

f 2 3     ğŸ‘‰ 2
f 2 (1/0) ğŸ‘‰ 2
```
En canvi, en Clojure:

```Clojure
(defn f [x y] x)

(f 2 3)       ğŸ‘‰ 2
(f 2 (/ 1 0)) ğŸ‘‰ Execution error (ArithmeticException)
```
El que sÃ­ fa Clojure Ã©s permetre utilitzar **_lazy sequences_**.

---

## _Lazy Sequences_

Una **_lazy sequence_** (**_seqÃ¼Ã¨ncia mandrosa_** (!?)) Ã©s aquella en
que els elements de la seqÃ¼Ã¨ncia no estan disponibles amb antelaciÃ³ i
es produeixen com a resultat d'un cÃ lcul. El cÃ lcul es realitza segons
calgui. L'avaluaciÃ³ de seqÃ¼Ã¨ncies mandroses es coneix com a **_realitzaciÃ³_**.

Cal considerar un aspecte subtil: Parlem de _lazy **sequences**_
perquÃ¨ les seqÃ¼Ã¨ncies sÃ³n les Ãºniques que sÃ³n _lazy_. Els vectors no
ho sÃ³n. Els diccionaris no ho sÃ³n. D'aquÃ­ que moltes de les funcions
d'ordre superior que hem vist retornin seqÃ¼Ã¨ncies.

Les funcions de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
(com per exemple `map`, `filter`, `concat`, `take`, etc.) sÃ³n **_lazy-friendly_**: AixÃ² vol dir que si reben com a argument una seqÃ¼Ã¨ncia _lazy_ 
no imposen la seva realitzaciÃ³, i que generen seqÃ¼Ã¨ncies _lazy_ (fins i tot si han 
rebut un vector o una colÂ·lecciÃ³ no-_lazy_ com a argument). 

TambÃ© generen seqÃ¼Ã¨ncies _lazy_ aquelles funcions que retornen
seqÃ¼Ã¨ncies "infinites" (`iterate`, `repeat`, `range`, etc.)

Finalment, els nostres programes poden generar seqÃ¼Ã¨ncies _lazy_ fent servir constructors
de seqÃ¼Ã¨ncies _lazy_:
`lazy-seq` o `lazy-cat`, per exemple.

---

## _Lazy Sequences_

El fet que la [_Clojure sequence
library_](https://clojure.org/reference/sequences#_the_seq_library)
tingui funcions _lazy-friendly_ tÃ© conseqÃ¼Ã¨ncies importants. Fins ara
hem fet servir aquestes funcions ignorant la seva _laziness_ implÃ­cita. Cal, perÃ², que
coneguem finalment quin Ã©s el funcionament real d'aquestes funcions.

Veiem alguns exemples (haver d'escriure -_print_- les seqÃ¼Ã¨ncies _lazy_ al REPL fa
que es realitzin):

```Clojure
;; Multipliquem per 2 a tots els naturals. Obviament Ã©s lazy
;;
(def sl1 (map #(* % 2) (iterate inc 1)))

;; Aquesta seqÃ¼Ã¨ncia tambÃ© Ã©s lazy, encara que no sigui "infinita"
;;
(take 15 sl1) ğŸ‘‰ (2 4 6 8 10 12 14 16 18 20 22 24 26 28 30)

;; El resultat Ã©s lazy, encara que l'argument no ho sigui
;;
(def sl2 (map inc [1 2 3 4])

;; Aquest resultat ja NO Ã©s lazy, tot i que l'argument sÃ­ que ho Ã©s
;;
(vec sl2) ğŸ‘‰ [2 3 4 5]

;; Obtenir 10 nombres enters aleatoris entre 0 i 99
;;
(take 10 (repeatedly #(rand-int 100))) ğŸ‘‰ (80 52 30 29 10 52 39 69 22 53)

```
---

## _Lazy Sequences_

GrÃ cies als efectes colaterals (_side effects_) Ã©s fÃ cil veure que
les funcions que ja coneixem de la [_Clojure sequence library_](https://clojure.org/reference/sequences#_the_seq_library)
generen en realitat seqÃ¼Ã¨ncies _lazy_.

```Clojure
user=> (def result (map println [:a :b :c]))
#'user/result
user=> 
```
Com? No s'ha aplicat la funciÃ³ `println` als elements del vector `[:a :b :c]`?

El que ha passat Ã©s que la seqÃ¼Ã¨ncia resultant del `map` Ã©s _lazy_, per tant no
es realitzarÃ  mentre no faci falta. Si forcem la realitzaciÃ³:

```Clojure
user=> result
ğŸ‘ï¸ :a
ğŸ‘ï¸ :b
ğŸ‘ï¸ :c
ğŸ‘‰ (nil nil nil)

user=> result
ğŸ‘‰ (nil nil nil)
```
Ara s'ha executat `println` per a cada
un dels elements de `[:a :b :c]`. `(nil nil nil)` Ã©s resultat de que el valor de 
retorn de `println` Ã©s `nil`.

---

## _Lazy Sequences_: _doall_

**`doall` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. 

Veiem-ne exemples:

En aquest exemple, `take` rep una seqÃ¼Ã¨ncia _lazy_ i retorna una
seqÃ¼Ã¨ncia _lazy_, per tant no s'executa res fins que no es realitza:

```Clojure
(let [x (atom 0)]
   (take 10 (repeatedly #(swap! x inc)))
   @x) ğŸ‘‰ 0
```
`doall` serveix per forÃ§ar la realitzaciÃ³ de la seqÃ¼Ã¨ncia:

```Clojure
(let [x (atom 0)]
   (doall (take 10 (repeatedly #(swap! x inc))))
   @x) ğŸ‘‰ 10
```

Un altre exemple, `range` Ã©s _lazy_:

```Clojure
(time (nth (range 1 100000000 4) 16)) ğŸ‘‰ 65
ğŸ‘ï¸ "Elapsed time: 0.017652 msecs"
(time (nth (doall (range 1 100000000 4)) 16)) ğŸ‘‰ 65
ğŸ‘ï¸ "Elapsed time: 1686.357028 msecs"
```
.tiny[.red[Font]: [clojuredocs.org/clojure.core/doall](https://clojuredocs.org/clojure.core/doall)]

---

## _Lazy Sequences_: _doall_

**`doall` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. 

El podem fer servir per fer alguns experiments interessants:

```Clojure
(time (doall (map (fn [x] 
                    (loop [i 1] (if (> i 1E+9) 1 (recur (inc i))))) 
                  (range 10))))
ğŸ‘ï¸ "Elapsed time: 8746.204096 msecs" ;; 8 segons!
ğŸ‘‰ (1 1 1 1 1 1 1 1 1 1)
```
Com hem dit abans, `map` retorna una seqÃ¼Ã¨ncia _lazy_, per tant fixem-nos que si no realitzem el
resultat...

```Clojure
(time (def no-realitzada 
           (map (fn [x] 
                  (loop [i 1] (if (> i 1E+9) 1 (recur (inc i))))) 
                (range 10))))
ğŸ‘ï¸ "Elapsed time: 0.038851 msecs"
ğŸ‘‰ #'user/no-realitzada

no-realitzada ğŸ‘‰ (1 1 1 1 1 1 1 1 1 1) ;; i ara sÃ­ que ha trigat 8 segons
```
... no s'inverteix temps en cap cÃ lcul. Senzillament es construeix una seqÃ¼Ã¨ncia _lazy_ que
estÃ  _pendent_ de realitzaciÃ³.

---

## _Lazy Sequences_: _doall_

**`doall` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. 

El podem fer servir per fer alguns experiments interessants: 

En aquest experiment podem veure que les seqÃ¼Ã¨ncies _lazy_ en Clojure es guarden en memÃ²ria
(sÃ³n _cached_):

```Clojure
(let [s (time (map #(Thread/sleep %) (range 0 150 10)))]
  (time (doall s))
  (time (doall s))) 
ğŸ‘‰ (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)

ğŸ‘ï¸ "Elapsed time: 0.029905 msecs"
ğŸ‘ï¸ "Elapsed time: 1903.846528 msecs"
ğŸ‘ï¸ "Elapsed time: 0.021917 msecs"

```
Si ens fixem, el segon cop que realitzem `s` no es triguen els 1.9 segons que triguem
el primer cop. El resultat de realitzar `s` s'ha guardat.

<br>
.tiny[<ins>Nota</ins>: Hem fet servir `Thread/sleep` nomÃ©s per provocar un alentiment 
de l'execuciÃ³ del codi. Aquesta funciÃ³, sense entrar en detalls, fa que el _thread_ 
s'aturi un cert nombre de milisegons (aproximadament).]

---

## _Lazy Sequences_: _lazy-seq_

En Clojure es poden fer funcions que generin seqÃ¼Ã¨ncies _lazy_ amb `lazy-seq`.

Per exemple, podrÃ­em fer la nostra versiÃ³ de `iterate` i utilitzar-la en
diversos exemples:

```Clojure
(defn my-iterate [f x] ;; f ha de ser pura
  (lazy-seq
    (cons x (my-iterate f (f x)))))  ;; no hi ha cas base

(def powers-of-two (my-iterate (partial * 2) 1))
(nth powers-of-two 10) ğŸ‘‰ 1024

;; Recordeu l'exemple de l'aproximaciÃ³ a l'arrel quadrada del tema 1??
;; Sabent (mÃ©s) Clojure, ara l'escriurem aixÃ­...

(defn arrel [x]
  (letfn [(arrels [x] (my-iterate #(float (/ (+ % (float (/ x %))) 2)) x))]
    (nth (arrels x) 100))) ;; suposem que 100 termes sÃ³n suficients

(arrel 25)  ğŸ‘‰  5.0
(arrel 36)  ğŸ‘‰  6.0
(arrel 100) ğŸ‘‰ 10.0

```
Fixem-nos que ja no Ã©s un problema fer definicions recursives _sense cas base_ (!)


---

## _Lazy Sequences_: _lazy-seq_

Durant el curs hem fet les nostres versions de `map`, `filter`, etc. per ilÂ·lustrar diverses tÃ¨cniques. 
Naturalment no hem tingut en compte com de _lazy-friendly_ sÃ³n aquestes funcions. Fent
servir `lazy-seq` sÃ­ que podem fer-ne una implementaciÃ³ prÃ²pia i fidel a l'original:

```Clojure
(defn my-filter [pred coll]
  (let [step (fn [p c]
                 (when-let [s (seq c)]
                   (if (p (first s))
                     (cons (first s) (my-filter p (rest s)))
                     (recur p (rest s)))))]
    (lazy-seq (step pred coll))))

(def s (my-filter #(when (even? %) (do (println %) %)) (range 100))) ğŸ‘‰ #'user/s
(take 5 s) ğŸ‘‰ ;; es confonen l'output de la crida a take i els println
(0
2
0 4
2 6
4 8
6 8)
;; perÃ² el segon cop ja hem realitzat aquest tros de la seqÃ¼Ã¨ncia
(take 5 s) ğŸ‘‰ (0 2 4 6 8)
```
---

## _Lazy Sequences_: _lazy-seq_

Els autors de _The Joy of Clojure_ ens diuen.red[*]:

_(...) the `lazy-seq` recipe for applying laziness to your own functions:_

1. _Use the `lazy-seq` macro at the outermost level of your lazy sequenceâ€“producing
expression(s)._

2. _If you happen to be consuming another sequence during your operations, then
use `rest` instead of `next`._

3. _Prefer higher-order functions when processing sequences._

4. _Donâ€™t hold on to your head._

Tots aquests punts s'entenen forÃ§a bÃ©... excepte el 4rt: QuÃ¨ vol dir _Donâ€™t hold on to your head_?

<br>.tiny[.red[*].red[Font]: _The Joy of Clojure_, p. 126]

---

## _Lazy Sequences_: _lazy-seq_

A quÃ¨ es refereixen amb l'expressiÃ³ _Donâ€™t hold on to your head_?

_If you manage to hold on to the head of a sequence somewhere within a
function, then that sequence will be prevented from being garbage
collected. The simplest way to retain the head of a sequence is to
bind it to a local._

.tiny[.red[Font]: _The Joy of Clojure_, p. 128]

La idea Ã©s que hem d'evitar de retenir el primer element d'una seqÃ¼Ã¨ncia ja que aixÃ²
impedirÃ , mentre es processa la resta de la seqÃ¼Ã¨ncia, que el que no es necessita
sigui _garbage collected_:

```Clojure
;; Recordem que els rangs sÃ³n lazy

(let [r (range 1e8)] (first r) (last r)) ğŸ‘‰ 99999999

(let [r (range 1e8)] (last r) (first r)) ğŸ‘‰ Execution error (OutOfMemoryError)
                                            Java heap space
```
En el primer cas, Clojure sap que no cal retenir el `first` per calcular el `last`, aixÃ­
que tot el que cal generar per arribar al `last` pot ser _garbage collected_.

AixÃ² no passa en el segon cas. En voler retenir tot allÃ² que cal generar per arribar al `last`,
de cara a poder retornar el `first`, esgotem el _heap_ de Java ğŸ˜†

---

## _Lazy Sequences_: _dorun_

**`dorun` serveix per realitzar una seqÃ¼Ã¨ncia _lazy_**. 

PerÃ²..., hem escrit aixÃ² tambÃ© per a `doall`. Quina Ã©s la diferÃ¨ncia?

* `doall` - Guarda en memÃ²ria la seqÃ¼Ã¨ncia mentre forÃ§a la realitzaciÃ³ dels elements. Retorna la seqÃ¼Ã¨ncia.

* `dorun` - No guarda la seqÃ¼Ã¨ncia en memÃ²ria mentre forÃ§a la realitzaciÃ³ dels diversos elements. Retorna `nil`.

PodrÃ­em ilÂ·lustrar la diferÃ¨ncia amb una implementaciÃ³ (simplificada):

```Clojure
(defn dorun [coll]                                   (defn doall [coll] 
  (when (seq coll) (recur (next coll))))               (dorun coll) coll)

user=> (doall (map #(do (println %) %) [1 2 3]))
ğŸ‘ï¸ 1
ğŸ‘ï¸ 2
ğŸ‘ï¸ 3
ğŸ‘‰ (1 2 3)  ;; valor de retorn
user=> (dorun (map #(do (println %) %) [1 2 3]))
ğŸ‘ï¸ 1
ğŸ‘ï¸ 2
ğŸ‘ï¸ 3
ğŸ‘‰ nil      ;; valor de retorn
```


---

## _Lazy Sequences_: _delay_ & _force_

Malgrat la _laziness_ de les seqÃ¼Ã¨ncies a Clojure, pot passar que vulguem tenir mÃ©s control
sobre l'avaluaciÃ³ d'expressions. Les macros `delay` i `force` serveixen precisament per a aixÃ².

* `(delay & expressions)`: Pren un grup d'expressions i produeix un
  objecte que invocarÃ  les expressions nomÃ©s la primera vegada que
  forcem la seva avaluaciÃ³ (amb `force` o `deref/@`). Aquest resultat
  es guarda en una _cache_ i serÃ  retornat, sense re-avaluar les
  expressions, les segÃ¼ents vegades que es demani l'avaluaciÃ³ del
  `delay`.
  
* `(force x)` Si `x` Ã©s resultat d'un `delay` anterior, `force` retorna el resultat
  d'avaluar el `delay`, possiblement retornant l'objecte en la _cache_

```Clojure
user=> (def my-delay (delay (println "escric al terminal") 100))
ğŸ‘‰ #'user/my-delay
user=> (force my-delay)
ğŸ‘ï¸ escric al terminal
ğŸ‘‰ 100
user=> (force my-delay)  ;; no torna a executar, s'escriu la cache
ğŸ‘‰ 100

```
---

## _Lazy Sequences_: _delay_ & _force_

Per exemple, suposem que volem una seqÃ¼Ã¨ncia _lazy_ dels nombres triangulars:
```Clojure
(defn triangle [n] (/ (* n (+ n 1)) 2)) ;; nombres triangulars
(def tri-nums (map triangle (iterate inc 1)))

(take 10 tri-nums) ğŸ‘‰ (1 3 6 10 15 21 28 36 45 55)
(take 10 (filter even? tri-nums)) ğŸ‘‰ (6 10 28 36 66 78 120 136 190 210)
```
Podem fer-ho de manera alternativa amb `delay`/`force`:
```Clojure
(defn inf-triangles [n]
  {:head (triangle n) :tail (delay (inf-triangles (inc n)))})
  
(defn head [l] (:head l))
(defn tail [l] (force (:tail l)))

(def tri-nums (inf-triangles 1))

(head tri-nums) ğŸ‘‰ 1
(head (tail tri-nums)) ğŸ‘‰ 3
(head (tail (tail tri-nums))) ğŸ‘‰ 6
```
.right[(continua â¡ï¸)]
.tiny[.red[Font]: _The Joy of Clojure_, p. 129]

---

## _Lazy Sequences_: _delay_ & _force_

Podem fer servir `head` i `tail` com a primitives per fer funcions que permetin tenir accÃ©s
als elements de la seqÃ¼Ã¨ncia de la mateixa manera que tenÃ­em amb les seqÃ¼Ã¨ncies _lazy_.

Per exemple:
```Clojure
(defn taker [n l]
  (loop [t n, src l, ret []]
    (if (zero? t)
      ret
      (recur (dec t) (tail src) (conj ret (head src))))))
      
(taker 10 tri-nums) ğŸ‘‰ [1 3 6 10 15 21 28 36 45 55]

(defn nthr [l n]
  (if (zero? n)
    (head l)
    (recur (tail l) (dec n))))

(nthr tri-nums 99)  ğŸ‘‰ 5050
(nthr tri-nums 110) ğŸ‘‰ 6216
```

.small[**Exercici**: Proposeu una manera alternativa de fer quasi bÃ© el mateix que la parella
`delay`/`force`. Diem _quasi bÃ©_ ja que no demanem que es memoritzi el resultat. Modifiqueu 
la vostra proposta per a que ara sÃ­ es memoritzi el resultat.]

.tiny[.red[Font]: _The Joy of Clojure_, p. 129]

---

## _Lazy Sequences_: SeqÃ¼Ã¨ncies "infinites"

La possibilitat d'escriure programes com a accessos _finits_ a seqÃ¼Ã¨ncies _"infinites"_ 
afegeix forÃ§a expressivitat al llenguatge.

Per exemple, si volem tenir els primers $k$ mÃºltiples d'un nombre $n$ (problema trivial
per altra part) podem fer:

```Clojure
(def multiples 
  (for [n (iterate inc 2)] (map #(* n %) (iterate inc 1)))) ğŸ‘‰ #'user/multiples

;; i ara en tinc prou fent (suposem que k Ã©s 10 i n Ã©s 154):
 
(take 10 (nth multiples 152)) ğŸ‘‰ (154 308 462 616 770 924 1078 1232 1386 1540)
```
Podem implementar un _merge lazy_ per poder treballar amb seqÃ¼Ã¨ncies _lazy_:

```Clojure
(defn my-merge [[cap1 & cua1 :as lst1] [cap2 & cua2 :as lst2]]
  (lazy-seq
   (cond
     (< cap1 cap2) (cons cap1 (my-merge cua1 lst2))
     (= cap1 cap2) (cons cap1 (my-merge cua1 cua2))   ;; elimina duplicats
     (> cap1 cap2) (cons cap2 (my-merge lst1 cua2)))))

(def p (my-merge (range) (range -50 100 10))) ğŸ‘‰ #'user/p
(take 10 p) ğŸ‘‰ (-50 -40 -30 -20 -10 0 1 2 3 4)
```

---

## _Lazy Sequences_: mapv / filterv

`mapv` i `filterv` sÃ³n les versions no-_lazy_ de `map` i `filter`. SÃ³n
no-_lazy_ ja que retornen un vector. Ja hem dit abans que els vectors en
Clojure no sÃ³n _lazy_.

Tornant a l'exemple de `map` amb `println`:
```Clojure
user=> (def result (map println [:a :b :c]))
ğŸ‘‰ #'user/result
user=> (def result (mapv println [:a :b :c]))
ğŸ‘ï¸ :a
ğŸ‘ï¸ :b
ğŸ‘ï¸ :c
ğŸ‘‰ #'user/result 

```

A banda d'aquest fet, el seu comportament Ã©s el mateix que les seves contrapartides _lazy_.

```Clojure
;; filter retorna seqÃ¼Ã¨ncia
;;
(filter #(= (count %) 1) ["a" "aa" "b" "n" "f" "lisp" "clojure" "q" ""]) 
ğŸ‘‰ ("a" "b" "n" "f" "q")

;; filterv retorna vector
;;
(filterv #(= (count %) 1) ["a" "aa" "b" "n" "f" "lisp" "clojure" "q" ""]) 
ğŸ‘‰ ["a" "b" "n" "f" "q"]
```

---

## _Lazy Sequences_: _Sequence Chunking_

En un intent de fer l'Ãºs de seqÃ¼Ã¨ncies _lazy_ mÃ©s eficient, Clojure fa el que s'anomena 
**_sequence chunking_**. AixÃ² vol dir que quan es demana la realitzaciÃ³ d'elements
de seqÃ¼Ã¨ncies _lazy_, aixÃ² es fa en blocs de 32 elements:

```Clojure
;; |--- NomÃ©s demano el primer element de la seqÃ¼Ã¨ncia lazy!
;; v
(first (map #(do (print % " ") (identity %)) (range 100)))
ğŸ‘ï¸ 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31 
ğŸ‘‰ 0
```
Hem demanat el primer element de la seqÃ¼Ã¨ncia, per tant nomÃ©s calia que es realitzÃ©s
aquest. Fixem-nos, perÃ², que s'han realitzat els 32 primers, Ã©s a dir, s'ha calculat el resultat
d'aplicar la funciÃ³ `#(do (print % " ") (identity %))` als 32 primers elements
de `(range 100)`).

Ã‰s una manera d'_amortitzar_ el cost -per element- de generar elements. Per exemple,
fixem-nos que si demanem 33 elements, acabem realitzant-ne 64.

---

## _Lazy Sequences_: Exercicis Recapitulatoris

* Implementa `my-map`, ara tenint en compte la _laziness_ del `map` original.

* Fes una funciÃ³ per generar la seqÃ¼Ã¨ncia _ordenada_ dels **nombres de Hamming**:
  [1,2,3,4,5,6,8,9,...]. Els nombres de Hamming sÃ³n aquells que tenen nomÃ©s 2, 3, i/o 5
  com a divisors primers.
  ```Clojure
  ;; si la seqÃ¼Ã¨ncia s'anomena hammings...
  (def hammings ...)
  (take 15 hammings) ğŸ‘‰ (1 2N 3N 4N 5N 6N 8N 9N 10N 12N 15N 16N 18N 20N 24N)
  ```
* Donat un nombre qualsevol de seqÃ¼Ã¨ncies no buides, cadascuna ordenada de mÃ©s
  petit a mÃ©s gran, trobeu el nombre mÃ©s petit que apareix a totes les
  seqÃ¼Ã¨ncies (suposeu que aquest existeix). Les seqÃ¼Ã¨ncies poden ser infinites, aixÃ­ que aneu amb
  compte i feu cerques _lazy_.
  ```Clojure
  ;; si la funciÃ³ s'anomena cerca-lazy
  (cerca-lazy (map #(* % % %) (range)) (iterate inc 20)) ğŸ‘‰ 27
  ```
---

## _Lazy Sequences_: Exercicis Recapitulatoris
.small[
* En el que segueix, `m`, `n`, `s`, `t` denoten nombres enters no negatius, `f`
  denota una funciÃ³ que accepta dos arguments i es defineix per a tots
  els nombres enters no negatius dels dos arguments. En matemÃ tiques,
  la funciÃ³ `f` es pot interpretar com una matriu infinita amb infinites
  files i columnes que, quan s'escriu, sembla una matriu ordinÃ ria,
  perÃ² les seves files i columnes no es poden escriure completament,
  de manera que s'acaben amb elÂ·lipses. A Clojure, aquesta matriu
  infinita es pot representar com una seqÃ¼Ã¨ncia _lazy_ infinita de
  seqÃ¼Ã¨ncies _lazy_ infinites, on les seqÃ¼Ã¨ncies interiors
  representen files. Escriu una funciÃ³ que accepti 1, 3 i 5
  arguments:
  
  * amb l'argument `f`, retorna la matriu infinita `A` que tÃ©
  l'entrada a la fila `i` i la columna `j` Ã©s igual a `f(i,j)` per a `i, j =
  0,1,2,...` 
  
  * amb els arguments `f`, `m`, `n`, retorna la matriu infinita `B`
  que Ã©s igual a la resta de la matriu `A` desprÃ©s de l'eliminaciÃ³ de
  les primeres `m` files i les primeres `n` columnes
  
  * amb els arguments
  `f`, `m`, `n`, `s`, `t`, retorna la matriu finita `s`$\times$`t` que consta de les
  primeres `t` entrades de cadascuna de les primeres `s` files de la
  matriu `B` o, de manera equivalent, que consta de la primeres `s`
  entrades de cadascuna de les primeres `t` columnes de la matriu `B`.]
  
```Clojure
;; si la funciÃ³ s'anomena imat
(imat * 3 5 5 7) ğŸ‘‰ [[15 18 21 24 27 30 33] 
                     [20 24 28 32 36 40 44] 
                     [25 30 35 40 45 50 55] 
                     [30 36 42 48 54 60 66] 
                     [35 42 49 56 63 70 77]]
```


---

## _Lazy Sequences_

Per saber-ne mÃ©s:

* _The Joy of Clojure_, seccions 6.3, p. 123, i 6.4, p. 132

* [_Language: Laziness_](https://clojure-doc.org/articles/language/laziness/)

Per a una visiÃ³ crÃ­tica de la _laziness_ i el seu Ãºs a Clojure:

* [_Clojure's Deadly Sin_](https://clojure-goes-fast.com/blog/clojures-deadly-sin/),
entrada del blog d'Oleksandr Yakushev el 27 de Juliol de 2023.


