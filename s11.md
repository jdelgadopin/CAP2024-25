class: center, up

# CAP - Macros

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 7</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Macros: MotivaciÃ³

Les **_Macros de Lisp_** (i les macros de Clojure ho sÃ³n) neixen l'any
1963 amb l'article de Timothy Hart [_MACRO definitions for
LISP_](http://hdl.handle.net/1721.1/6111). 

Encara avui dia no gaires llenguatges fora dels de la familia de Lisp
(Clojure, Scheme, Common Lisp, Dylan, Racket, etc.) tenen una
capacitat similar. Julia o Elixir en sÃ³n dos exemples.

El fet que els llenguatges de la familia de Lisp siguin [_homoiconics_](https://en.wikipedia.org/wiki/Homoiconicity)
Ã©s el que permet tractar codi com si fossin dades, i transformar programes en programes
(metaprogramaciÃ³) amb facilitat:

_A language is homoiconic if a program written in it can be
manipulated as data using the language. The program's internal
representation can thus be inferred just by reading the program
itself. This property is often summarized by saying that the language
treats **code as data**._

Aquesta possibilitat de metaprogramaciÃ³ que les macros (de Lisp) ens permeten estÃ 
darrera la metodologia de programaciÃ³ associada als programes de la familia de Lisp.
Simplificant, hom resol problemes en Lisp/Clojure creant 
[_Domain-Specific Languages_](https://en.wikipedia.org/wiki/Domain-specific_language)
associats al problema en qÃ¼estiÃ³, en els que sigui senzill formular (un programa que
porti a) una soluciÃ³ del problema.

---

## Macros: MotivaciÃ³

Us recordeu del primer dia de classe? DÃ¨iem...

Ã‰s habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa Ã©s:

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-42.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: MotivaciÃ³

En aquest tema ens centrarem en el quÃ¨ passa en la part assenyalada...

Ã‰s habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa Ã©s:

.center[![:scale 90%](figures/macros1.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: MotivaciÃ³

Podem analitzar quÃ¨ passa en les fases de **read** i **eval** que ja coneixem:

En Clojure la instrucciÃ³ `read-string` permet obtenir una estructura
de dades Clojure a partir d'una _string_ de carÃ cters:

```Clojure
(read-string "(+ 1 2)") ğŸ‘‰ (+ 1 2)

(read-string "(map inc (range 10))") ğŸ‘‰ (map inc (range 10))
```
i `eval` ens permet avaluar una estructura de dades Clojure (interpretant-la com a codi):

```Clojure
(eval (read-string "(+ 1 2)")) ğŸ‘‰ 3

(eval (read-string "(map inc (range 10))")) ğŸ‘‰ (1 2 3 4 5 6 7 8 9 10)

;; perÃ² fixem-nos que el pas de read-string Ã©s necessari...

(eval "(+ 1 2)") ğŸ‘‰ "(+ 1 2)"
(eval "(map inc (range 10))") ğŸ‘‰ "(map inc (range 10))"
```
---

## Macros: MotivaciÃ³

_In computer programming, a macro (short for "macro instruction"; from
Greek Î¼Î±ÎºÏÎ¿- 'long, large') is a rule or pattern that specifies how
a certain input should be mapped to a replacement output. Applying a
macro to an input is known as macro expansion._ .small[([Wikipedia](https://en.wikipedia.org/wiki/Macro_%28computer_science%29))]

Ara bÃ©, a la fase d'**ExpansiÃ³** de Clojure Ã©s on passen 
_coses interessants_. Podem veure-ho amb
`macroexpand` i variants:
```Clojure
(macroexpand (read-string "(+ 1 2)")) ğŸ‘‰ (+ 1 2)

(macroexpand (read-string "(map inc (range 10))")) ğŸ‘‰ (map inc (range 10))
```
perÃ²... no sembla que passi res.

Clojure tÃ© moltes macros definides. Una d'elles Ã©s `cond`:

```Clojure
;; Fem (def x 10) i (def y 15) abans...

(read-string "(cond (> x y) 1000 :else -1000)") 
ğŸ‘‰ (cond (> x y) 1000 :else -1000)

(eval (read-string "(cond (> x y) 1000 :else -1000)")) ğŸ‘‰ -1000 
```
Tampoc sembla que passi res d'especial! 

---

## Macros: MotivaciÃ³

A mÃ©s de `macroexpand`, podem fer servir `macroexpand-all`:

```Clojure
;; Hem de fer (use 'clojure.walk) abans, que Ã©s on estÃ  macroexpand-all

(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))

ğŸ‘‰ (if (> x y) 1000 (if :else -1000 nil))
```
Ara sÃ­. El resultat de `macroexpand-all` no Ã©s el que retorna `read-string`!

S'ha transformat una llista de Clojure (que representa codi) en una altra llista de Clojure
(que tambÃ© representa codi). 

La _macroexpansiÃ³_ Ã©s una transformaciÃ³ `Codi font â‡’ Codi font` que tÃ© lloc **_abans_** de l'avaluaciÃ³. 

S'acostuma a dir que la macroexpansiÃ³ tÃ© lloc **_en temps de compilaciÃ³_**.

AixÃ­ doncs, l'avaluador de Clojure no "sap" res de cap `cond`, aquest queda transformat
en una sÃ¨rie de `if` imbricats _abans que el codi
arribi a l'avaluador_!

---

## Macros: MotivaciÃ³

La transformaciÃ³ de codi font en codi font que fan les macros tÃ© lloc **_abans_** d'avaluar
les expressions que contenen les invocacions a les macros.

En realitat, el que fa Clojure Ã©s `(eval (macroexpand-all (read-string "...")))`.red[*]
```Clojure
(eval (macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))) ğŸ‘‰ -1000
```
El procÃ©s de _macroexpansiÃ³_ pot requerir diversos passos. L'exemple que estem
treballant n'Ã©s un cas. `macroexpand-1` en fa un d'aquests passos:

```Clojure
(macroexpand-1 (read-string "(cond (> x y) 1000 :else -1000)"))
ğŸ‘‰ (if (> x y) 1000 (clojure.core/cond :else -1000))
;;                   ------------------
;;          AquÃ­ hi ha un 'cond' encara per expandir

;; en canvi:
(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))
ğŸ‘‰ (if (> x y) 1000 (if :else -1000 nil))
```

Ã‰s clar, doncs, que la definiciÃ³ de les macros pot ser **_recursiva_**.

.footnote[.red[*] En realitat el comportament intern de _macroexpansiÃ³_ no queda fidelment
reproduÃ¯t per <br>`macroexpand-all` (de `clojure.walk`) al 100%, perÃ² Ã©s la variant de 
`macroexpand` que mÃ©s s'hi apropa]

---

## Macros: MotivaciÃ³

Les macros formen part d'un sistema per ampliar un llenguatge de programaciÃ³ fent
servir el mateix llenguatge de programaciÃ³. El mateix _core_ de Clojure estÃ  ple
de macros. Veiem alguns exemples (del [codi font](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj) de Clojure):

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(...)

(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  {:added "1.0"}
  [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
                (second clauses)
                (throw (IllegalArgumentException.
                         "cond requires an even number of forms")))
            (cons 'clojure.core/cond (next (next clauses))))))
```

---

## Macros

Si ens fixem en `when` i `cond`, sÃ³n exemples on la transformaciÃ³ de codi
font en codi font es senzillament manipulaciÃ³ de llistes i els seus continguts,
jugant amb `quote` quan cal. **Aquesta transformaciÃ³ es fa en Clojure**.

Hi ha macros una mica mÃ©s complicades, que fan servir funcions i macros de Clojure que 
encara no hem vist:

```Clojure
;; Ara resulta que a Clojure tenÃ­em 'while'!! ğŸ˜

(defmacro while
  "Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil"
  {:added "1.0"}
  [test & body]
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
QuÃ¨ sÃ³n aquests sÃ­mbols `~` o `~@`?

El millor de les macros Ã©s que **_el programador en pot definir de prÃ²pies_**.

Ara veurem com... â¡ï¸

---

## Macros: `defmacro` i els parÃ metres

Per definir macros fem servir `defmacro`. Quan s'invoca una macro cal tenir present una
propietat importantÃ­ssima:

<p style="padding: 20px; border: 2px solid red;">.center[**Els parÃ metres de la macro NO s'avaluen**]</p>

Cap parÃ metre dels que passem a una macro (expressions, llistes, sÃ­mbols, el que sigui) **NO** s'avalua.

Veiem un exemple. Recordem la definiciÃ³ de `when`:

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(macroexpand-all '(when (f x) (map g (h x)) nil)) 
ğŸ‘‰ (if (f x) (do (map g (h x)) nil))
```
No s'avalua l'expressiÃ³ `(f x)`, ni la resta de parÃ metres `(map g (h x))` o `nil`. Quan s'invoca
la macro `(when (f x) (map g (h x)) nil)`, aquesta invocaciÃ³ queda _textualment_ substituÃ¯da per
`(if (f x) (do (map g (h x)) nil))`.

---

## Macros: `defmacro` i els parÃ metres

A l'expressiÃ³ `(when (f x) (map g (h x)) nil)` es fa el que diu la definiciÃ³ de la macro sense avaluar
els parÃ metres, Ã©s a dir, els parÃ metres sÃ³n estructures de dades Clojure i es queden com a tals.

Quan executem el cos del `when`: `(list 'if test (cons 'do body))`, `test` Ã©s _literalment_ el
que hem passat a la invocaciÃ³ de `when`, Ã©s a dir, `(f x)`, i body Ã©s la seqÃ¼Ã¨ncia amb la resta
de parÃ metres (com correspÃ³n a `&`) sense avaluar: `((map g (h x)) nil)`.

AixÃ­, `(list 'if test (cons 'do body))` construeix la llista `(if (f x) (do (map g (h x)) nil))`,
que Ã©s el que substitueix `(when (f x) (map g (h x)) nil)` i que serÃ  _posteriorment_ avaluat.

Veiem, doncs, com amb les funcions per manipular llistes de Clojure (aquÃ­ `cons` i `list`) mÃ©s 
`quote` podem manipular i _transformar_ codi font en codi font. El mateix Clojure ens permet
executar una expressiÃ³ per transformar codi font _abans_ de l'execuciÃ³/avaluaciÃ³ en sÃ­ del codi.

El problema Ã©s que amb aquestes funcions no en tenim prou.

---

## Macros: `syntax-quote` _et. al_

VoldrÃ­em tenir una mena de `quote` selectiu, on es poguÃ©s _triar_ quÃ¨ s'avalua o no. AixÃ² Ã©s 
precisament el que fa `syntax-quote`, altrament conegut pel _back-tick_ \`. Com diem el que volem 
que sigui avaluat dins un `syntax-quote`? Fent servir l'`unquote`, o `~`. Amb \` i `~` tenim el 
que necessitem:

```Clojure
user=> (def x 1001)
#'user/x

user=> x   ;; avaluaciÃ³ "normal"
1001

user=> `x  ;; amb syntax-quote
user/x

user=> 'x  ;; amb quote
x

user=> `(list :a :b :c x :d)   ;; syntax-quote actua (gairebÃ©) com un quote...
(clojure.core/list :a :b :c user/x :d)

user=> `(list :a :b :c ~x :d)  ;;... perÃ² podem fer servir l'unquote
(clojure.core/list :a :b :c 1001 :d)
```
Quan fem servir `syntax-quote` els sÃ­mbols no avaluats sÃ³n _namespace-qualified_. Es fa explÃ­cita
la seva pertinenÃ§a a un _namespace_ determinat.

---

## Macros: `syntax-quote` _et. al_

Hi ha una utilitat mÃ©s que ens farÃ  la vida mÃ©s fÃ cil: l'`unquote-splicing`, o `~@`. 

De vegades volem inserir els elements d'una llista en una altra llista:

```Clojure
user=> (def lst '(:e :f :g))
#'user/lst

;; si fem servir unquote...
user=> `(:a :b :c :d ~lst :h)
(:a :b :c :d (:e :f :g) :h)

;; no Ã©s aixÃ² el que volem... perÃ² si faig servir l'unquote-splicing
user=> `(:a :b :c :d ~@lst :h)
(:a :b :c :d :e :f :g :h)
```
L'`unquote-splicing` Ã©s precisament el que fa, si el resultat de l'avaluaciÃ³ Ã©s una llista
insereix els elements de la llista allÃ  on hem fet servir l'`~@`. 

De fet, allÃ² que avaluem amb `~@` ha de resultar obligatÃ²riament en
una llista. En altre cas obtindrem un `Don't know how to create ISeq from:...`

---

## Macros: `syntax-quote` _et. al_

Ara ja podem entendre el `while`:
.cols5050[
.col1[
```Clojure
(defmacro while  ;; sense comentaris
  [test & body]  ;; ni metadades
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
]
.col2[
```Clojure
(let [n (atom 2)]
  (while (not (zero? @n)) 
     (println @n) 
     (swap! n dec))) ğŸ‘‰ nil
ğŸ‘ï¸ 2
ğŸ‘ï¸ 1
```
]]

```Clojure
(macroexpand-all 
      '(let [n (atom 2)] (while (not (zero? @n)) (println @n) (swap! n dec))))
      
ğŸ‘‰ (let* [n (atom 2)] 
     (loop* [] 
        (if (not (zero? (clojure.core/deref n))) 
          (do 
            (println (clojure.core/deref n)) 
            (swap! n dec) 
            (recur)))))
```

`loop*` i `let*` sÃ³n versions _internes_ de `loop` i `let` que el programador no hauria de fer servir.
Tot i aixÃ², l'expansiÃ³ de la macro sÃ­ les fa servir. Fixem-nos que tambÃ© s'ha expandit el `when`.

---

## Macros: `syntax-quote` _et. al_

Hem vist l'expansiÃ³ completa, perÃ² podem entendre-la millor per passos
(ignorarem el `loop*` i el `let*`):

```Clojure
;; primer macro-expandim el while:
(let [n (atom 2)]                   (let [n (atom 2)]
  (while (not (zero? @n))  ğŸ‘‰ğŸ‘‰ğŸ‘‰    (loop [] 
    (println @n)                        (when (not (zero? (clojure.core/deref n)))
    (swap! n dec)))                       (println (clojure.core/deref n))
                                          (swap! n dec)
                                          (recur))))
;; ara macro-expandim el when:
(let [n (atom 2)]
  (loop [] 
    (when (not (zero? (clojure.core/deref n)))
      (println (clojure.core/deref n))
      (swap! n dec)
      (recur))))

        ğŸ‘‡ğŸ‘‡ğŸ‘‡

(let [n (atom 2)] 
  (loop [] 
    (if (not (zero? (clojure.core/deref n))) 
      (do 
        (println (clojure.core/deref n)) 
        (swap! n dec) 
        (recur)))))
```
---

## Macros: Captura de sÃ­mbols

El mÃ³n de les macros Ã©s ple de subtileses, que anirem veient poc a poc. Comencem amb el que s'anomena
**_symbol capture_**.

Comencem pel problema d'escriure sÃ­mbols en el codi generat per
`syntax-quote`. Suposem que fem la macro `cubs`:

```Clojure
(defmacro cubs [s] `(map (fn [x] (* x x x)) ~s)) ğŸ‘‰ #'user/cubs
(cubs (range 10)) ğŸ‘‰ Error ;; es queixa perquÃ¨ no sap quÃ¨ Ã©s user/x
```
En fer servir `cubs` ens trobem que els sÃ­mbols que fem servir, `x` en particular, Ã©s
interpretat pel `syntax-quote` com a un sÃ­mbol del _namespace_ _user_, `user/x`, i no ho Ã©s. Ã‰s el
parÃ metre d'una funciÃ³, i aixÃ­ haurÃ­em d'escriure'l.

Haurem de fer que determinats sÃ­mbols que ens interessen no siguin processats per 
`syntax-quote`: Si fem `(unquote (quote x))`, Ã©s a dir `~'x`, aconseguim que el codi generat escrigui
senzillament `x`:
```Clojure
(defmacro cubs [s] `(map (fn [~'x] (* ~'x ~'x ~'x)) ~s)) ğŸ‘‰ #'user/cubs
(cubs (range 10)) ğŸ‘‰ (0 1 8 27 64 125 216 343 512 729)
```
---

## Macros: Captura de sÃ­mbols

Ara fem una altra macro: `crea-multiplicador`:
```Clojure
(defmacro crea-multiplicador [x] `(fn [~'y] (* ~'y ~x))) 
ğŸ‘‰ #'user/crea-multiplicador
;; (crea-multiplicador x) macorexpandirÃ  a la closure (fn [y] (* x y))
(def per3 (crea-multiplicador 3)) ğŸ‘‰ #'user/per3
;; per3 Ã©s en realitat el resultat d'avaluar (fn [y] (* 3 y))
(per3 10) ğŸ‘‰ 30
```
Tot sembla correcte. Anem, perÃ², a fer un experiment:
```Clojure
(def y 100) ğŸ‘‰ #'user/y
(def per103 (crea-multiplicador (+ y 3))) ğŸ‘‰ #'user/per103
(per103 10) ğŸ‘‰ 130 ;; !!!!
```
Aquest no Ã©s el resultat correcte! EsperÃ vem `1030`. QuÃ¨ ha passat?
Macroexpandim _a mÃ _...
```Clojure
(crea-multiplicador (+ y 3)) ğŸ‘‰ (fn [y] (* (+ y 3) y))
((fn [y] (* (+ y 3) y)) 10) â‰¡ (* 13 10) â‰¡ 130
```
Direm que `y` (Ã©s a dir, `user/y`) ha estat **_capturada_** (pel codi generat per la macro).

---

## Macros: Captura de sÃ­mbols

AixÃ­ doncs, quÃ¨ podem fer per evitar la captura de sÃ­mbols (a banda
d'anar amb molt de compte)?

Clojure ens proporciona la funciÃ³ `gensym`. La seva aplicaciÃ³ ens proporciona un sÃ­mbol
nou, que no ha estat utilitzat fins el moment. Es pot proporcionar un prefix:
```Clojure
(gensym) ğŸ‘‰ G__3

(gensym "y") ğŸ‘‰ y6

(gensym "nou") ğŸ‘‰ nou9
```
Dins d'una macro podem disposar de l'**_auto-gensym_**. Podem afegir un sufix `#` a un
sÃ­mbol i es generarÃ  un sÃ­mbol Ãºnic amb el sÃ­mbol com a prefix:

```Clojure
(defmacro crea-multiplicador [x] `(fn [y#] (* y# ~x)))
ğŸ‘‰ #'user/crea-multiplicador

(def y 100) ğŸ‘‰ #'user/y
(def per103 (crea-multiplicador (+ y 3))) ğŸ‘‰ #'user/per103
(per103 10) ğŸ‘‰ 1030
```
