class: center, up

# CAP - Macros

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 7</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Macros: Motivaci√≥

Les **_Macros de Lisp_** (i les macros de Clojure ho s√≥n) neixen l'any
1963 amb l'article de Timothy Hart [_MACRO definitions for
LISP_](http://hdl.handle.net/1721.1/6111). 

Encara avui dia no gaires llenguatges fora dels de la familia de Lisp
(Clojure, Scheme, Common Lisp, Dylan, Racket, etc.) tenen una
capacitat similar. Julia o Elixir en s√≥n dos exemples.

El fet que els llenguatges de la familia de Lisp siguin [_homoiconics_](https://en.wikipedia.org/wiki/Homoiconicity)
√©s el que permet tractar codi com si fossin dades, i transformar programes en programes
(metaprogramaci√≥) amb facilitat:

_A language is homoiconic if a program written in it can be
manipulated as data using the language. The program's internal
representation can thus be inferred just by reading the program
itself. This property is often summarized by saying that the language
treats **code as data**._

Aquesta possibilitat de metaprogramaci√≥ que les macros (de Lisp) ens permeten est√†
darrera la metodologia de programaci√≥ associada als programes de la familia de Lisp.
Simplificant, hom resol problemes en Lisp/Clojure creant 
[_Domain-Specific Languages_](https://en.wikipedia.org/wiki/Domain-specific_language)
associats al problema en q√ºesti√≥, en els que sigui senzill formular (un programa que
porti a) una soluci√≥ del problema.

---

## Macros: Motivaci√≥

Us recordeu del primer dia de classe? D√®iem...

√âs habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa √©s:

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-42.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: Motivaci√≥

En aquest tema ens centrarem en el qu√® passa en la part assenyalada...

√âs habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa √©s:

.center[![:scale 90%](figures/macros1.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: Motivaci√≥

Podem analitzar qu√® passa en les fases de **read** i **eval** que ja coneixem:

En Clojure la instrucci√≥ `read-string` permet obtenir una estructura
de dades Clojure a partir d'una _string_ de car√†cters:

```Clojure
(read-string "(+ 1 2)") üëâ (+ 1 2)

(read-string "(map inc (range 10))") üëâ (map inc (range 10))
```
i `eval` ens permet avaluar una estructura de dades Clojure (interpretant-la com a codi):

```Clojure
(eval (read-string "(+ 1 2)")) üëâ 3

(eval (read-string "(map inc (range 10))")) üëâ (1 2 3 4 5 6 7 8 9 10)

;; per√≤ fixem-nos que el pas de read-string √©s necessari...

(eval "(+ 1 2)") üëâ "(+ 1 2)"
(eval "(map inc (range 10))") üëâ "(map inc (range 10))"
```
---

## Macros: Motivaci√≥

_In computer programming, a macro (short for "macro instruction"; from
Greek ŒºŒ±Œ∫œÅŒø- 'long, large') is a rule or pattern that specifies how
a certain input should be mapped to a replacement output. Applying a
macro to an input is known as macro expansion._ .small[([Wikipedia](https://en.wikipedia.org/wiki/Macro_%28computer_science%29))]

Ara b√©, a la fase d'**Expansi√≥** de Clojure √©s on passen 
_coses interessants_. Podem veure-ho amb
`macroexpand` i variants:
```Clojure
(macroexpand (read-string "(+ 1 2)")) üëâ (+ 1 2)

(macroexpand (read-string "(map inc (range 10))")) üëâ (map inc (range 10))
```
per√≤... no sembla que passi res.

Clojure t√© moltes macros definides. Una d'elles √©s `cond`:

```Clojure
;; Fem (def x 10) i (def y 15) abans...

(read-string "(cond (> x y) 1000 :else -1000)") 
üëâ (cond (> x y) 1000 :else -1000)

(eval (read-string "(cond (> x y) 1000 :else -1000)")) üëâ -1000 
```
Tampoc sembla que passi res d'especial! 

---

## Macros: Motivaci√≥

A m√©s de `macroexpand`, podem fer servir `macroexpand-all`:

```Clojure
;; Hem de fer (use 'clojure.walk) abans, que √©s on est√† macroexpand-all

(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))

üëâ (if (> x y) 1000 (if :else -1000 nil))
```
Ara s√≠. El resultat de `macroexpand-all` no √©s el que retorna `read-string`!

S'ha transformat una llista de Clojure (que representa codi) en una altra llista de Clojure
(que tamb√© representa codi). 

La _macroexpansi√≥_ √©s una transformaci√≥ `Codi font ‚áí Codi font` que t√© lloc **_abans_** de l'avaluaci√≥. 

S'acostuma a dir que la macroexpansi√≥ t√© lloc **_en temps de compilaci√≥_**.

Aix√≠ doncs, l'avaluador de Clojure no "sap" res de cap `cond`, aquest queda transformat
en una s√®rie de `if` imbricats _abans que el codi
arribi a l'avaluador_!

---

## Macros: Motivaci√≥

La transformaci√≥ de codi font en codi font que fan les macros t√© lloc **_abans_** d'avaluar
les expressions que contenen les invocacions a les macros.

En realitat, el que fa Clojure √©s `(eval (macroexpand-all (read-string "...")))`.red[*]
```Clojure
(eval (macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))) üëâ -1000
```
El proc√©s de _macroexpansi√≥_ pot requerir diversos passos. L'exemple que estem
treballant n'√©s un cas. `macroexpand-1` en fa un d'aquests passos:

```Clojure
(macroexpand-1 (read-string "(cond (> x y) 1000 :else -1000)"))
üëâ (if (> x y) 1000 (clojure.core/cond :else -1000))
;;                   ------------------
;;          Aqu√≠ hi ha un 'cond' encara per expandir

;; en canvi:
(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))
üëâ (if (> x y) 1000 (if :else -1000 nil))
```

√âs clar, doncs, que la definici√≥ de les macros pot ser **_recursiva_**.

.footnote[.red[*] En realitat el comportament intern de _macroexpansi√≥_ no queda fidelment
reprodu√Øt per <br>`macroexpand-all` (de `clojure.walk`) al 100%, per√≤ √©s la variant de 
`macroexpand` que m√©s s'hi apropa]

---

## Macros: Motivaci√≥

Les macros formen part d'un sistema per ampliar un llenguatge de programaci√≥ fent
servir el mateix llenguatge de programaci√≥. El mateix _core_ de Clojure est√† ple
de macros. Veiem alguns exemples (del [codi font](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj) de Clojure):

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(...)

(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  {:added "1.0"}
  [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
                (second clauses)
                (throw (IllegalArgumentException.
                         "cond requires an even number of forms")))
            (cons 'clojure.core/cond (next (next clauses))))))
```

---

## Macros

Si ens fixem en `when` i `cond`, s√≥n exemples on la transformaci√≥ de codi
font en codi font es senzillament manipulaci√≥ de llistes i els seus continguts,
jugant amb `quote` quan cal. **Aquesta transformaci√≥ es fa en Clojure**.

Hi ha macros una mica m√©s complicades, que fan servir funcions i macros de Clojure que 
encara no hem vist:

```Clojure
;; Ara resulta que a Clojure ten√≠em 'while'!! üòÅ

(defmacro while
  "Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil"
  {:added "1.0"}
  [test & body]
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
Qu√® s√≥n aquests s√≠mbols `~` o `~@`?

El millor de les macros √©s que **_el programador en pot definir de pr√≤pies_**.

Ara veurem com... ‚û°Ô∏è

---

## Macros: `defmacro` i els par√†metres

Per definir macros fem servir `defmacro`. Quan s'invoca una macro cal tenir present una
propietat important√≠ssima:

<p style="padding: 20px; border: 2px solid red;">.center[**Els par√†metres de la macro NO s'avaluen**]</p>

Cap par√†metre dels que passem a una macro (expressions, llistes, s√≠mbols, el que sigui) **NO** s'avalua.

Veiem un exemple. Recordem la definici√≥ de `when`:

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(macroexpand-all '(when (f x) (map g (h x)) nil)) 
üëâ (if (f x) (do (map g (h x)) nil))
```
No s'avalua l'expressi√≥ `(f x)`, ni la resta de par√†metres `(map g (h x))` o `nil`. Quan s'invoca
la macro `(when (f x) (map g (h x)) nil)`, aquesta invocaci√≥ queda _textualment_ substitu√Øda per
`(if (f x) (do (map g (h x)) nil))`.

---

## Macros: `defmacro` i els par√†metres

A l'expressi√≥ `(when (f x) (map g (h x)) nil)` es fa el que diu la definici√≥ de la macro sense avaluar
els par√†metres, √©s a dir, els par√†metres s√≥n estructures de dades Clojure i es queden com a tals.

Quan executem el cos del `when`: `(list 'if test (cons 'do body))`, `test` √©s _literalment_ el
que hem passat a la invocaci√≥ de `when`, √©s a dir, `(f x)`, i body √©s la seq√º√®ncia amb la resta
de par√†metres (com corresp√≥n a `&`) sense avaluar: `((map g (h x)) nil)`.

Aix√≠, `(list 'if test (cons 'do body))` construeix la llista `(if (f x) (do (map g (h x)) nil))`,
que √©s el que substitueix `(when (f x) (map g (h x)) nil)` i que ser√† _posteriorment_ avaluat.

Veiem, doncs, com amb les funcions per manipular llistes de Clojure (aqu√≠ `cons` i `list`) m√©s 
`quote` podem manipular i _transformar_ codi font en codi font. El mateix Clojure ens permet
executar una expressi√≥ per transformar codi font _abans_ de l'execuci√≥/avaluaci√≥ en s√≠ del codi.

El problema √©s que amb aquestes funcions no en tenim prou.

---

## Macros: `syntax-quote` _et. al_

Voldr√≠em tenir una mena de `quote` selectiu, on es pogu√©s _triar_ qu√® s'avalua o no. Aix√≤ √©s 
precisament el que fa `syntax-quote`, altrament conegut pel _back-tick_ \`. Com diem el que volem 
que sigui avaluat dins un `syntax-quote`? Fent servir l'`unquote`, o `~`. Amb \` i `~` tenim el 
que necessitem:

```Clojure
user=> (def x 1001)
#'user/x

user=> x   ;; avaluaci√≥ "normal"
1001

user=> `x  ;; amb syntax-quote
user/x

user=> 'x  ;; amb quote
x

user=> `(list :a :b :c x :d)   ;; syntax-quote actua (gaireb√©) com un quote...
(clojure.core/list :a :b :c user/x :d)

user=> `(list :a :b :c ~x :d)  ;;... per√≤ podem fer servir l'unquote
(clojure.core/list :a :b :c 1001 :d)
```
Quan fem servir `syntax-quote` els s√≠mbols no avaluats s√≥n _namespace-qualified_. Es fa expl√≠cita
la seva pertinen√ßa a un _namespace_ determinat.

---

## Macros: `syntax-quote` _et. al_

Hi ha una utilitat m√©s que ens far√† la vida m√©s f√†cil: l'`unquote-splicing`, o `~@`. 

De vegades volem inserir els elements d'una llista en una altra llista:

```Clojure
user=> (def lst '(:e :f :g))
#'user/lst

;; si fem servir unquote...
user=> `(:a :b :c :d ~lst :h)
(:a :b :c :d (:e :f :g) :h)

;; no √©s aix√≤ el que volem... per√≤ si faig servir l'unquote-splicing
user=> `(:a :b :c :d ~@lst :h)
(:a :b :c :d :e :f :g :h)
```
L'`unquote-splicing` √©s precisament el que fa, si el resultat de l'avaluaci√≥ √©s una llista
insereix els elements de la llista all√† on hem fet servir l'`~@`. 

De fet, all√≤ que avaluem amb `~@` ha de resultar obligat√≤riament en
una llista. En altre cas obtindrem un `Don't know how to create ISeq from:...`

---

## Macros: `syntax-quote` _et. al_

Ara ja podem entendre el `while`:
.cols5050[
.col1[
```Clojure
(defmacro while  ;; sense comentaris
  [test & body]  ;; ni metadades
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
]
.col2[
```Clojure
(let [n (atom 2)]
  (while (not (zero? @n)) 
     (println @n) 
     (swap! n dec))) üëâ nil
üëÅÔ∏è 2
üëÅÔ∏è 1
```
]]

```Clojure
(macroexpand-all 
      '(let [n (atom 2)] (while (not (zero? @n)) (println @n) (swap! n dec))))
      
üëâ (let* [n (atom 2)] 
     (loop* [] 
        (if (not (zero? (clojure.core/deref n))) 
          (do 
            (println (clojure.core/deref n)) 
            (swap! n dec) 
            (recur)))))
```

`loop*` i `let*` s√≥n versions _internes_ de `loop` i `let` que el programador no hauria de fer servir.
Tot i aix√≤, l'expansi√≥ de la macro s√≠ les fa servir. Fixem-nos que tamb√© s'ha expandit el `when`.

---

## Macros: `syntax-quote` _et. al_

Hem vist l'expansi√≥ completa, per√≤ podem entendre-la millor per passos
(ignorarem el `loop*` i el `let*`):

```Clojure
;; primer macro-expandim el while:
(let [n (atom 2)]                   (let [n (atom 2)]
  (while (not (zero? @n))  üëâüëâüëâ    (loop [] 
    (println @n)                        (when (not (zero? (clojure.core/deref n)))
    (swap! n dec)))                       (println (clojure.core/deref n))
                                          (swap! n dec)
                                          (recur))))
;; ara macro-expandim el when:
(let [n (atom 2)]
  (loop [] 
    (when (not (zero? (clojure.core/deref n)))
      (println (clojure.core/deref n))
      (swap! n dec)
      (recur))))

        üëáüëáüëá

(let [n (atom 2)] 
  (loop [] 
    (if (not (zero? (clojure.core/deref n))) 
      (do 
        (println (clojure.core/deref n)) 
        (swap! n dec) 
        (recur)))))
```
---

## Macros: Captura de s√≠mbols

El m√≥n de les macros √©s ple de subtileses, que anirem veient poc a poc. Comencem amb el que s'anomena
**_symbol capture_**.

Comencem pel problema d'escriure s√≠mbols en el codi generat per
`syntax-quote`. Suposem que fem la macro `cubs`:

```Clojure
(defmacro cubs [s] `(map (fn [x] (* x x x)) ~s)) üëâ #'user/cubs
(cubs (range 10)) üëâ Error ;; es queixa perqu√® no sap qu√® √©s user/x
```
En fer servir `cubs` ens trobem que els s√≠mbols que fem servir, `x` en particular, √©s
interpretat pel `syntax-quote` com a un s√≠mbol del _namespace_ _user_, `user/x`, i no ho √©s. √âs el
par√†metre d'una funci√≥, i aix√≠ haur√≠em d'escriure'l.

Haurem de fer que determinats s√≠mbols que ens interessen no siguin processats per 
`syntax-quote`: Si fem `(unquote (quote x))`, √©s a dir `~'x`, aconseguim que el codi generat escrigui
senzillament `x`:
```Clojure
(defmacro cubs [s] `(map (fn [~'x] (* ~'x ~'x ~'x)) ~s)) üëâ #'user/cubs
(cubs (range 10)) üëâ (0 1 8 27 64 125 216 343 512 729)
```
---

## Macros: Captura de s√≠mbols

Ara fem una altra macro: `crea-multiplicador`:
```Clojure
(defmacro crea-multiplicador [x] `(fn [~'y] (* ~'y ~x))) 
üëâ #'user/crea-multiplicador
;; (crea-multiplicador x) macorexpandir√† a la closure (fn [y] (* x y))
(def per3 (crea-multiplicador 3)) üëâ #'user/per3
;; per3 √©s en realitat el resultat d'avaluar (fn [y] (* 3 y))
(per3 10) üëâ 30
```
Tot sembla correcte. Anem, per√≤, a fer un experiment:
```Clojure
(def y 100) üëâ #'user/y
(def per103 (crea-multiplicador (+ y 3))) üëâ #'user/per103
(per103 10) üëâ 130 ;; !!!!
```
Aquest no √©s el resultat correcte! Esper√†vem `1030`. Qu√® ha passat?
Macroexpandim _a m√†_...
```Clojure
(crea-multiplicador (+ y 3)) üëâ (fn [y] (* (+ y 3) y))
((fn [y] (* (+ y 3) y)) 10) ‚â° (* 13 10) ‚â° 130
```
Direm que `y` (√©s a dir, `user/y`) ha estat **_capturada_** (pel codi generat per la macro).

---

## Macros: Captura de s√≠mbols

Aix√≠ doncs, qu√® podem fer per evitar la captura de s√≠mbols (a banda
d'anar amb molt de compte)?

Clojure ens proporciona la funci√≥ `gensym`. La seva aplicaci√≥ ens proporciona un s√≠mbol
nou, que no ha estat utilitzat fins el moment. Es pot proporcionar un prefix:
```Clojure
(gensym) üëâ G__3

(gensym "y") üëâ y6

(gensym "nou") üëâ nou9
```
Dins d'una macro podem disposar de l'**_auto-gensym_**. Podem afegir un sufix `#` a un
s√≠mbol i es generar√† un s√≠mbol √∫nic amb el s√≠mbol com a prefix:

```Clojure
(defmacro crea-multiplicador [x] `(fn [y#] (* y# ~x)))
üëâ #'user/crea-multiplicador

(def y 100) üëâ #'user/y
(def per103 (crea-multiplicador (+ y 3))) üëâ #'user/per103
(per103 10) üëâ 1030
```
