class: center, up

# CAP - Macros

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 7</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Macros: Motivaci√≥

Les **_Macros de Lisp_** (i les macros de Clojure ho s√≥n) neixen l'any
1963 amb l'article de Timothy Hart [_MACRO definitions for
LISP_](http://hdl.handle.net/1721.1/6111). 

Encara avui dia no gaires llenguatges fora dels de la familia de Lisp
(Clojure, Scheme, Common Lisp, Dylan, Racket, etc.) tenen una
capacitat similar. Julia o Elixir en s√≥n dos exemples.

El fet que els llenguatges de la familia de Lisp siguin [_homoiconics_](https://en.wikipedia.org/wiki/Homoiconicity)
√©s el que permet tractar codi com si fossin dades, i transformar programes en programes
(metaprogramaci√≥) amb facilitat:

_A language is homoiconic if a program written in it can be
manipulated as data using the language. The program's internal
representation can thus be inferred just by reading the program
itself. This property is often summarized by saying that the language
treats **code as data**._

Aquesta possibilitat de metaprogramaci√≥ que les macros (de Lisp) ens permeten est√†
darrera la metodologia de programaci√≥ associada als programes de la familia de Lisp.
Simplificant, hom resol problemes en Lisp/Clojure creant 
[_Domain-Specific Languages_](https://en.wikipedia.org/wiki/Domain-specific_language)
associats al problema en q√ºesti√≥, en els que sigui senzill formular (un programa que
porti a) una soluci√≥ del problema.

---

## Macros: Motivaci√≥

Us recordeu del primer dia de classe? D√®iem...

√âs habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa √©s:

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-42.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: Motivaci√≥

En aquest tema ens centrarem en el qu√® passa en la part assenyalada...

√âs habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa √©s:

.center[![:scale 90%](figures/macros1.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: Motivaci√≥

Podem analitzar qu√® passa en les fases de **read** i **eval** que ja coneixem:

En Clojure la instrucci√≥ `read-string` permet obtenir una estructura
de dades Clojure a partir d'una _string_ de car√†cters:

```Clojure
(read-string "(+ 1 2)") üëâ (+ 1 2)

(read-string "(map inc (range 10))") üëâ (map inc (range 10))
```
i `eval` ens permet avaluar una estructura de dades Clojure (interpretant-la com a codi):

```Clojure
(eval (read-string "(+ 1 2)")) üëâ 3

(eval (read-string "(map inc (range 10))")) üëâ (1 2 3 4 5 6 7 8 9 10)

;; per√≤ fixem-nos que el pas de read-string √©s necessari...

(eval "(+ 1 2)") üëâ "(+ 1 2)"
(eval "(map inc (range 10))") üëâ "(map inc (range 10))"
```
---

## Macros: Motivaci√≥

_In computer programming, a macro (short for "macro instruction"; from
Greek ŒºŒ±Œ∫œÅŒø- 'long, large') is a rule or pattern that specifies how
a certain input should be mapped to a replacement output. Applying a
macro to an input is known as macro expansion._ .small[([Wikipedia](https://en.wikipedia.org/wiki/Macro_%28computer_science%29))]

Ara b√©, a la fase d'**Expansi√≥** de Clojure √©s on passen 
_coses interessants_. Podem veure-ho amb
`macroexpand` i variants:
```Clojure
(macroexpand (read-string "(+ 1 2)")) üëâ (+ 1 2)

(macroexpand (read-string "(map inc (range 10))")) üëâ (map inc (range 10))
```
per√≤... no sembla que passi res.

Clojure t√© moltes macros definides. Una d'elles √©s `cond`:

```Clojure
;; Fem (def x 10) i (def y 15) abans...

(read-string "(cond (> x y) 1000 :else -1000)") 
üëâ (cond (> x y) 1000 :else -1000)

(eval (read-string "(cond (> x y) 1000 :else -1000)")) üëâ -1000 
```
Tampoc sembla que passi res d'especial! 

---

## Macros: Motivaci√≥

A m√©s de `macroexpand`, podem fer servir `macroexpand-all`:

```Clojure
;; Hem de fer (use 'clojure.walk) abans, que √©s on est√† macroexpand-all

(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))

üëâ (if (> x y) 1000 (if :else -1000 nil))
```
Ara s√≠. El resultat de `macroexpand-all` no √©s el que retorna `read-string`!

S'ha transformat una llista de Clojure (que representa codi) en una altra llista de Clojure
(que tamb√© representa codi). 

La _macroexpansi√≥_ √©s una transformaci√≥ `Codi font ‚áí Codi font` que t√© lloc **_abans_** de l'avaluaci√≥. 

S'acostuma a dir que la macroexpansi√≥ t√© lloc **_en temps de compilaci√≥_**.

Aix√≠ doncs, l'avaluador de Clojure no "sap" res de cap `cond`, aquest queda transformat
en una s√®rie de `if` imbricats _abans que el codi
arribi a l'avaluador_!

---

## Macros: Motivaci√≥

La transformaci√≥ de codi font en codi font que fan les macros t√© lloc **_abans_** d'avaluar
les expressions que contenen les invocacions a les macros.

En realitat, el que fa Clojure √©s `(eval (macroexpand-all (read-string "...")))`.red[*]
```Clojure
(eval (macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))) üëâ -1000
```
El proc√©s de _macroexpansi√≥_ pot requerir diversos passos. L'exemple que estem
treballant n'√©s un cas. `macroexpand-1` en fa un d'aquests passos:

```Clojure
(macroexpand-1 (read-string "(cond (> x y) 1000 :else -1000)"))
üëâ (if (> x y) 1000 (clojure.core/cond :else -1000))
;;                   ------------------
;;          Aqu√≠ hi ha un 'cond' encara per expandir

;; en canvi:
(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))
üëâ (if (> x y) 1000 (if :else -1000 nil))
```

√âs clar, doncs, que la definici√≥ de les macros pot ser **_recursiva_**.

.footnote[.red[*] En realitat el comportament intern de _macroexpansi√≥_ no queda fidelment
reprodu√Øt per <br>`macroexpand-all` (de `clojure.walk`) al 100%, per√≤ √©s la variant de 
`macroexpand` que m√©s s'hi apropa]

---

## Macros: Motivaci√≥

Les macros formen part d'un sistema per ampliar un llenguatge de programaci√≥ fent
servir el mateix llenguatge de programaci√≥. El mateix _core_ de Clojure est√† ple
de macros. Veiem alguns exemples (del [codi font](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj) de Clojure):

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(...)

(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  {:added "1.0"}
  [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
                (second clauses)
                (throw (IllegalArgumentException.
                         "cond requires an even number of forms")))
            (cons 'clojure.core/cond (next (next clauses))))))
```

---

## Macros

Si ens fixem en `when` i `cond`, s√≥n exemples on la transformaci√≥ de codi
font en codi font es senzillament manipulaci√≥ de llistes i els seus continguts,
jugant amb `quote` quan cal. **Aquesta transformaci√≥ es fa en Clojure**.

Hi ha macros una mica m√©s complicades, que fan servir funcions i macros de Clojure que 
encara no hem vist:

```Clojure
;; Ara resulta que a Clojure ten√≠em 'while'!! üòÅ

(defmacro while
  "Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil"
  {:added "1.0"}
  [test & body]
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
Qu√® s√≥n aquests s√≠mbols `~` o `~@`?

El millor de les macros √©s que **_el programador en pot definir de pr√≤pies_**.

Ara veurem com... ‚û°Ô∏è

---

## Macros: `defmacro` i els par√†metres

Per definir macros fem servir `defmacro`. Quan s'invoca una macro cal tenir present una
propietat important√≠ssima:

<p style="padding: 20px; border: 2px solid red;">.center[**Els par√†metres de la macro NO s'avaluen**]</p>

Cap par√†metre dels que passem a una macro (expressions, llistes, s√≠mbols, el que sigui) **NO** s'avalua.

Veiem un exemple. Recordem la definici√≥ de `when`:

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(macroexpand-all '(when (f x) (map g (h x)) nil)) 
üëâ (if (f x) (do (map g (h x)) nil))
```
No s'avalua l'expressi√≥ `(f x)`, ni la resta de par√†metres `(map g (h x))` o `nil`. Quan s'invoca
la macro `(when (f x) (map g (h x)) nil)`, aquesta invocaci√≥ queda _textualment_ substitu√Øda per
`(if (f x) (do (map g (h x)) nil))`.

---

## Macros: `defmacro` i els par√†metres

A l'expressi√≥ `(when (f x) (map g (h x)) nil)` es fa el que diu la definici√≥ de la macro sense avaluar
els par√†metres, √©s a dir, els par√†metres s√≥n estructures de dades Clojure i es queden com a tals.

Quan executem el cos del `when`: `(list 'if test (cons 'do body))`, `test` √©s _literalment_ el
que hem passat a la invocaci√≥ de `when`, √©s a dir, `(f x)`, i body √©s la seq√º√®ncia amb la resta
de par√†metres (com corresp√≥n a `&`) sense avaluar: `((map g (h x)) nil)`.

Aix√≠, `(list 'if test (cons 'do body))` construeix la llista `(if (f x) (do (map g (h x)) nil))`,
que √©s el que substitueix `(when (f x) (map g (h x)) nil)` i que ser√† _posteriorment_ avaluat.

Veiem, doncs, com amb les funcions per manipular llistes de Clojure (aqu√≠ `cons` i `list`) m√©s 
`quote` podem manipular i _transformar_ codi font en codi font. El mateix Clojure ens permet
executar una expressi√≥ per transformar codi font _abans_ de l'execuci√≥/avaluaci√≥ en s√≠ del codi.

El problema √©s que amb aquestes funcions no en tenim prou.

---

## Macros: `syntax-quote` _et. al_

Voldr√≠em tenir una mena de `quote` selectiu, on es pogu√©s _triar_ qu√® s'avalua o no. Aix√≤ √©s 
precisament el que fa `syntax-quote`, altrament conegut pel _back-tick_ \`. Com diem el que volem 
que sigui avaluat dins un `syntax-quote`? Fent servir l'`unquote`, o `~`. Amb \` i `~` tenim el 
que necessitem:

```Clojure
user=> (def x 1001)
#'user/x

user=> x   ;; avaluaci√≥ "normal"
1001

user=> `x  ;; amb syntax-quote
user/x

user=> 'x  ;; amb quote
x

user=> `(list :a :b :c x :d)   ;; syntax-quote actua (gaireb√©) com un quote...
(clojure.core/list :a :b :c user/x :d)

user=> `(list :a :b :c ~x :d)  ;;... per√≤ podem fer servir l'unquote
(clojure.core/list :a :b :c 1001 :d)
```
Quan fem servir `syntax-quote` els s√≠mbols no avaluats s√≥n _namespace-qualified_. Es fa expl√≠cita
la seva pertinen√ßa a un _namespace_ determinat.

---

## Macros: `syntax-quote` _et. al_

Hi ha una utilitat m√©s que ens far√† la vida m√©s f√†cil: l'`unquote-splicing`, o `~@`. 

De vegades volem inserir els elements d'una llista en una altra llista:

```Clojure
user=> (def lst '(:e :f :g))
#'user/lst

;; si fem servir unquote...
user=> `(:a :b :c :d ~lst :h)
(:a :b :c :d (:e :f :g) :h)

;; no √©s aix√≤ el que volem... per√≤ si faig servir l'unquote-splicing
user=> `(:a :b :c :d ~@lst :h)
(:a :b :c :d :e :f :g :h)
```
L'`unquote-splicing` √©s precisament el que fa, si el resultat de l'avaluaci√≥ √©s una llista
insereix els elements de la llista all√† on hem fet servir l'`~@`. 

De fet, all√≤ que avaluem amb `~@` ha de resultar obligat√≤riament en
una llista. En altre cas obtindrem un `Don't know how to create ISeq from:...`

---

## Macros: `syntax-quote` _et. al_

Ara ja podem entendre el `while`:
.cols5050[
.col1[
```Clojure
(defmacro while  ;; sense comentaris
  [test & body]  ;; ni metadades
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
]
.col2[
```Clojure
(let [n (atom 2)]
  (while (not (zero? @n)) 
     (println @n) 
     (swap! n dec))) üëâ nil
üëÅÔ∏è 2
üëÅÔ∏è 1
```
]]

```Clojure
(macroexpand-all 
      '(let [n (atom 2)] (while (not (zero? @n)) (println @n) (swap! n dec))))
      
üëâ (let* [n (atom 2)] 
     (loop* [] 
        (if (not (zero? (clojure.core/deref n))) 
          (do 
            (println (clojure.core/deref n)) 
            (swap! n dec) 
            (recur)))))
```

`loop*` i `let*` s√≥n versions _internes_ de `loop` i `let` que el programador no hauria de fer servir.
Tot i aix√≤, l'expansi√≥ de la macro s√≠ les fa servir. Fixem-nos que tamb√© s'ha expandit el `when`.

---

## Macros: `syntax-quote` _et. al_

Hem vist l'expansi√≥ completa, per√≤ podem entendre-la millor per passos
(ignorarem el `loop*` i el `let*`):

```Clojure
;; primer macro-expandim el while:
(let [n (atom 2)]                   (let [n (atom 2)]
  (while (not (zero? @n))  üëâüëâüëâ    (loop [] 
    (println @n)                        (when (not (zero? (clojure.core/deref n)))
    (swap! n dec)))                       (println (clojure.core/deref n))
                                          (swap! n dec)
                                          (recur))))
;; ara macro-expandim el when:
(let [n (atom 2)]
  (loop [] 
    (when (not (zero? (clojure.core/deref n)))
      (println (clojure.core/deref n))
      (swap! n dec)
      (recur))))

        üëáüëáüëá

(let [n (atom 2)] 
  (loop [] 
    (if (not (zero? (clojure.core/deref n))) 
      (do 
        (println (clojure.core/deref n)) 
        (swap! n dec) 
        (recur)))))
```
