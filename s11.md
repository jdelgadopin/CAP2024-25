class: center, up

# CAP - Macros

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 7</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Macros: Motivaci√≥

Les **_Macros de Lisp_** (i les macros de Clojure ho s√≥n) neixen l'any
1963 amb l'article de Timothy Hart [_MACRO definitions for
LISP_](http://hdl.handle.net/1721.1/6111). 

Encara avui dia no gaires llenguatges fora dels de la familia de Lisp
(Clojure, Scheme, Common Lisp, Dylan, Racket, etc.) tenen una
capacitat similar. Julia o Elixir en s√≥n dos exemples.

El fet que els llenguatges de la familia de Lisp siguin [_homoiconics_](https://en.wikipedia.org/wiki/Homoiconicity)
√©s el que permet tractar codi com si fossin dades, i transformar programes en programes
(metaprogramaci√≥) amb facilitat:

_A language is homoiconic if a program written in it can be
manipulated as data using the language. The program's internal
representation can thus be inferred just by reading the program
itself. This property is often summarized by saying that the language
treats **code as data**._

Aquesta possibilitat de metaprogramaci√≥ que les macros (de Lisp) ens permeten est√†
darrera la metodologia de programaci√≥ associada als programes de la familia de Lisp.
Simplificant, hom resol problemes en Lisp/Clojure creant 
[_Domain-Specific Languages_](https://en.wikipedia.org/wiki/Domain-specific_language) (DSL's)
associats al problema en q√ºesti√≥, en els que sigui senzill formular (un programa que
porti a) una soluci√≥ del problema.

---

## Macros: Motivaci√≥

Us recordeu del primer dia de classe? D√®iem...

√âs habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa √©s:

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-42.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: Motivaci√≥

En aquest tema ens centrarem en el qu√® passa en la part assenyalada...

√âs habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa √©s:

.center[![:scale 90%](figures/macros1.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: Motivaci√≥

Veiem-ho una mica millor representat:

.center[![:scale 55%](figures/process.png)]

.tiny[.red[Font]: _Clojure Programming_, secci√≥ _What is a Macro_, figure 5-1, p. 231]


---

## Macros: Motivaci√≥

Podem analitzar qu√® passa en les fases de **read** i **eval** que ja coneixem:

En Clojure la instrucci√≥ `read-string` permet obtenir una estructura
de dades Clojure a partir d'una _string_ de car√†cters:

```Clojure
(read-string "(+ 1 2)") üëâ (+ 1 2)

(read-string "(map inc (range 10))") üëâ (map inc (range 10))
```
i `eval` ens permet avaluar una estructura de dades Clojure (interpretant-la com a codi):

```Clojure
(eval (read-string "(+ 1 2)")) üëâ 3

(eval (read-string "(map inc (range 10))")) üëâ (1 2 3 4 5 6 7 8 9 10)

;; per√≤ fixem-nos que el pas de read-string √©s necessari...

(eval "(+ 1 2)") üëâ "(+ 1 2)"
(eval "(map inc (range 10))") üëâ "(map inc (range 10))"
```
---

## Macros: Motivaci√≥

_In computer programming, a macro (short for "macro instruction"; from
Greek ŒºŒ±Œ∫œÅŒø- 'long, large') is a rule or pattern that specifies how
a certain input should be mapped to a replacement output. Applying a
macro to an input is known as macro expansion._ .small[([Wikipedia](https://en.wikipedia.org/wiki/Macro_%28computer_science%29))]

Ara b√©, a la fase d'**Expansi√≥** de Clojure √©s on passen 
_coses interessants_. Podem veure-ho amb
`macroexpand` i variants:
```Clojure
(macroexpand (read-string "(+ 1 2)")) üëâ (+ 1 2)

(macroexpand (read-string "(map inc (range 10))")) üëâ (map inc (range 10))
```
per√≤... no sembla que passi res.

Clojure t√© moltes macros definides. Una d'elles √©s `cond`:

```Clojure
;; Fem (def x 10) i (def y 15) abans...

(read-string "(cond (> x y) 1000 :else -1000)") 
üëâ (cond (> x y) 1000 :else -1000)

(eval (read-string "(cond (> x y) 1000 :else -1000)")) üëâ -1000 
```
Tampoc sembla que passi res d'especial! 

---

## Macros: Motivaci√≥

A m√©s de `macroexpand`, podem fer servir `macroexpand-all`:

```Clojure
;; Hem de fer (use 'clojure.walk) abans, que √©s on est√† macroexpand-all

(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))

üëâ (if (> x y) 1000 (if :else -1000 nil))
```
Ara s√≠. El resultat de `macroexpand-all` no √©s el que retorna `read-string`!

S'ha transformat una llista de Clojure (que representa codi) en una altra llista de Clojure
(que tamb√© representa codi). 

La _macroexpansi√≥_ √©s una transformaci√≥ `Codi font ‚áí Codi font` que t√© lloc **_abans_** de l'avaluaci√≥. 

S'acostuma a dir que la macroexpansi√≥ t√© lloc **_en temps de compilaci√≥_**.

Aix√≠ doncs, l'avaluador de Clojure no "sap" res de cap `cond`, aquest queda transformat
en una s√®rie de `if` imbricats _abans que el codi
arribi a l'avaluador_!

---

## Macros: Motivaci√≥

La transformaci√≥ de codi font en codi font que fan les macros t√© lloc **_abans_** d'avaluar
les expressions que contenen les invocacions a les macros.

En realitat, el que fa Clojure √©s `(eval (macroexpand-all (read-string "...")))`.red[*]
```Clojure
(eval (macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))) üëâ -1000
```
El proc√©s de _macroexpansi√≥_ pot requerir diversos passos. L'exemple que estem
treballant n'√©s un cas. `macroexpand-1` en fa un d'aquests passos:

```Clojure
(macroexpand-1 (read-string "(cond (> x y) 1000 :else -1000)"))
üëâ (if (> x y) 1000 (clojure.core/cond :else -1000))
;;                   ------------------
;;          Aqu√≠ hi ha un 'cond' encara per expandir

;; en canvi:
(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))
üëâ (if (> x y) 1000 (if :else -1000 nil))
```

√âs clar, doncs, que la definici√≥ de les macros pot ser **_recursiva_**.

.footnote[.red[*] En realitat el comportament intern de _macroexpansi√≥_ no queda fidelment
reprodu√Øt per <br>`macroexpand-all` (de `clojure.walk`) al 100%, per√≤ √©s la variant de 
`macroexpand` que m√©s s'hi apropa]

---

## Macros: Motivaci√≥

Les macros formen part d'un sistema per ampliar un llenguatge de programaci√≥ fent
servir el mateix llenguatge de programaci√≥. El mateix _core_ de Clojure est√† ple
de macros. Veiem alguns exemples (del [codi font](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj) de Clojure):

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(...)

(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  {:added "1.0"}
  [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
                (second clauses)
                (throw (IllegalArgumentException.
                         "cond requires an even number of forms")))
            (cons 'clojure.core/cond (next (next clauses))))))
```

---

## Macros

Si ens fixem en `when` i `cond`, s√≥n exemples on la transformaci√≥ de codi
font en codi font es senzillament manipulaci√≥ de llistes i els seus continguts,
jugant amb `quote` quan cal. **Aquesta transformaci√≥ es fa en Clojure**.

Hi ha macros una mica m√©s complicades, que fan servir funcions i macros de Clojure que 
encara no hem vist:

```Clojure
;; Ara resulta que a Clojure ten√≠em 'while'!! üòÅ

(defmacro while
  "Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil"
  {:added "1.0"}
  [test & body]
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
Qu√® s√≥n aquests s√≠mbols `~` o `~@`?

El millor de les macros √©s que **_el programador en pot definir de pr√≤pies_**.

Ara veurem com... ‚û°Ô∏è

---

## Macros: `defmacro` i els par√†metres

Per definir macros fem servir `defmacro`. Quan s'invoca una macro cal tenir present una
propietat important√≠ssima:

<p style="padding: 20px; border: 2px solid red;">.center[**Els par√†metres de la macro NO s'avaluen**]</p>

Cap par√†metre dels que passem a una macro (expressions, llistes, s√≠mbols, el que sigui) **NO** s'avalua.

Veiem un exemple. Recordem la definici√≥ de `when`:

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(macroexpand-all '(when (f x) (map g (h x)) nil)) 
üëâ (if (f x) (do (map g (h x)) nil))
```
No s'avalua l'expressi√≥ `(f x)`, ni la resta de par√†metres `(map g (h x))` o `nil`. Quan s'invoca
la macro `(when (f x) (map g (h x)) nil)`, aquesta invocaci√≥ queda _textualment_ substitu√Øda per
`(if (f x) (do (map g (h x)) nil))`.

---

## Macros: `defmacro` i els par√†metres

A l'expressi√≥ `(when (f x) (map g (h x)) nil)` es fa el que diu la definici√≥ de la macro sense avaluar
els par√†metres, √©s a dir, els par√†metres s√≥n estructures de dades Clojure i es queden com a tals.

Quan executem el cos del `when`: `(list 'if test (cons 'do body))`, `test` √©s _literalment_ el
que hem passat a la invocaci√≥ de `when`, √©s a dir, `(f x)`, i body √©s la seq√º√®ncia amb la resta
de par√†metres (com corresp√≥n a `&`) sense avaluar: `((map g (h x)) nil)`.

Aix√≠, `(list 'if test (cons 'do body))` construeix la llista `(if (f x) (do (map g (h x)) nil))`,
que √©s el que substitueix `(when (f x) (map g (h x)) nil)` i que ser√† _posteriorment_ avaluat.

Veiem, doncs, com amb les funcions per manipular llistes de Clojure (aqu√≠ `cons` i `list`) m√©s 
`quote` podem manipular i _transformar_ codi font en codi font. El mateix Clojure ens permet
executar una expressi√≥ per transformar codi font _abans_ de l'execuci√≥/avaluaci√≥ en s√≠ del codi.

El problema √©s que amb aquestes funcions no en tenim prou.

---

## Macros: `syntax-quote` _et. al_

Voldr√≠em tenir una mena de `quote` selectiu, on es pogu√©s _triar_ qu√® s'avalua o no. Aix√≤ √©s 
precisament el que fa `syntax-quote`, altrament conegut pel _back-tick_ \`. Com diem el que volem 
que sigui avaluat dins un `syntax-quote`? Fent servir l'`unquote`, o `~`. Amb \` i `~` tenim el 
que necessitem:

```Clojure
user=> (def x 1001)
#'user/x

user=> x   ;; avaluaci√≥ "normal"
1001

user=> `x  ;; amb syntax-quote
user/x

user=> 'x  ;; amb quote
x

user=> `(list :a :b :c x :d)   ;; syntax-quote actua (gaireb√©) com un quote...
(clojure.core/list :a :b :c user/x :d)

user=> `(list :a :b :c ~x :d)  ;;... per√≤ podem fer servir l'unquote
(clojure.core/list :a :b :c 1001 :d)
```
Quan fem servir `syntax-quote` els s√≠mbols no avaluats s√≥n _namespace-qualified_. Es fa expl√≠cita
la seva pertinen√ßa a un _namespace_ determinat.

---

## Macros: `syntax-quote` _et. al_

Hi ha una utilitat m√©s que ens far√† la vida m√©s f√†cil: l'`unquote-splicing`, o `~@`. 

De vegades volem inserir els elements d'una llista en una altra llista:

```Clojure
user=> (def lst '(:e :f :g))
#'user/lst

;; si fem servir unquote...
user=> `(:a :b :c :d ~lst :h)
(:a :b :c :d (:e :f :g) :h)

;; no √©s aix√≤ el que volem... per√≤ si faig servir l'unquote-splicing
user=> `(:a :b :c :d ~@lst :h)
(:a :b :c :d :e :f :g :h)
```
L'`unquote-splicing` √©s precisament el que fa, si el resultat de l'avaluaci√≥ √©s una llista
insereix els elements de la llista all√† on hem fet servir l'`~@`. 

De fet, all√≤ que avaluem amb `~@` ha de resultar obligat√≤riament en
una llista. En altre cas obtindrem un `Don't know how to create ISeq from:...`

---

## Macros: `syntax-quote` _et. al_

Ara ja podem entendre el `while`:
.cols5050[
.col1[
```Clojure
(defmacro while  ;; sense comentaris
  [test & body]  ;; ni metadades
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
]
.col2[
```Clojure
(let [n (atom 2)]
  (while (not (zero? @n)) 
     (println @n) 
     (swap! n dec))) üëâ nil
üëÅÔ∏è 2
üëÅÔ∏è 1
```
]]

```Clojure
(macroexpand-all 
      '(let [n (atom 2)] (while (not (zero? @n)) (println @n) (swap! n dec))))
      
üëâ (let* [n (atom 2)] 
     (loop* [] 
        (if (not (zero? (clojure.core/deref n))) 
          (do 
            (println (clojure.core/deref n)) 
            (swap! n dec) 
            (recur)))))
```

`loop*` i `let*` s√≥n versions _internes_ de `loop` i `let` que el programador no hauria de fer servir.
Tot i aix√≤, l'expansi√≥ de la macro s√≠ les fa servir. Fixem-nos que tamb√© s'ha expandit el `when`.

---

## Macros: `syntax-quote` _et. al_

Hem vist l'expansi√≥ completa, per√≤ podem entendre-la millor per passos
(ignorarem el `loop*` i el `let*`):

```Clojure
;; primer macro-expandim el while:
(let [n (atom 2)]                   (let [n (atom 2)]
  (while (not (zero? @n))  üëâüëâüëâ    (loop [] 
    (println @n)                        (when (not (zero? (clojure.core/deref n)))
    (swap! n dec)))                       (println (clojure.core/deref n))
                                          (swap! n dec)
                                          (recur))))
;; ara macro-expandim el when:
(let [n (atom 2)]
  (loop [] 
    (when (not (zero? (clojure.core/deref n)))
      (println (clojure.core/deref n))
      (swap! n dec)
      (recur))))

        üëáüëáüëá

(let [n (atom 2)] 
  (loop [] 
    (if (not (zero? (clojure.core/deref n))) 
      (do 
        (println (clojure.core/deref n)) 
        (swap! n dec) 
        (recur)))))
```
---

## Macros: Captura de s√≠mbols

El m√≥n de les macros √©s ple de subtileses, que anirem veient poc a poc. Comencem amb el que s'anomena
**_symbol capture_**.

Comencem pel problema d'escriure s√≠mbols en el codi generat per
`syntax-quote`. Suposem que fem la macro `cubs`:

```Clojure
(defmacro cubs [s] `(map (fn [x] (* x x x)) ~s)) üëâ #'user/cubs
(cubs (range 10)) üëâ Error ;; es queixa perqu√® no sap qu√® √©s user/x
```
En fer servir `cubs` ens trobem que els s√≠mbols que fem servir, `x` en particular, √©s
interpretat pel `syntax-quote` com a un s√≠mbol del _namespace_ _user_, `user/x`, i no ho √©s. √âs el
par√†metre d'una funci√≥, i aix√≠ haur√≠em d'escriure'l.

Haurem de fer que determinats s√≠mbols que ens interessen no siguin processats per 
`syntax-quote`: Si fem `(unquote (quote x))`, √©s a dir `~'x`, aconseguim que el codi generat escrigui
senzillament `x`:
```Clojure
(defmacro cubs [s] `(map (fn [~'x] (* ~'x ~'x ~'x)) ~s)) üëâ #'user/cubs
(cubs (range 10)) üëâ (0 1 8 27 64 125 216 343 512 729)
```
---

## Macros: Captura de s√≠mbols

Ara fem una altra macro: `crea-multiplicador`:
```Clojure
(defmacro crea-multiplicador [x] `(fn [~'y] (* ~'y ~x))) 
üëâ #'user/crea-multiplicador
;; (crea-multiplicador x) macorexpandir√† a la closure (fn [y] (* x y))
(def per3 (crea-multiplicador 3)) üëâ #'user/per3
;; per3 √©s en realitat el resultat d'avaluar (fn [y] (* 3 y))
(per3 10) üëâ 30
```
Tot sembla correcte. Anem, per√≤, a fer un experiment:
```Clojure
(def y 100) üëâ #'user/y
(def per103 (crea-multiplicador (+ y 3))) üëâ #'user/per103
(per103 10) üëâ 130 ;; !!!!
```
Aquest no √©s el resultat correcte! Esper√†vem `1030`. Qu√® ha passat?
Macroexpandim _a m√†_...
```Clojure
(crea-multiplicador (+ y 3)) üëâ (fn [y] (* (+ y 3) y))
((fn [y] (* (+ y 3) y)) 10) ‚â° (* 13 10) ‚â° 130
```
Direm que `y` (√©s a dir, `user/y`) ha estat **_capturada_** (pel codi generat per la macro).

---

## Macros: Captura de s√≠mbols

Aix√≠ doncs, qu√® podem fer per evitar la captura de s√≠mbols (a banda
d'anar amb molt de compte)?

Clojure ens proporciona la funci√≥ `gensym`. La seva aplicaci√≥ ens proporciona un s√≠mbol
nou, que no ha estat utilitzat fins el moment. Es pot proporcionar un prefix:
```Clojure
(gensym) üëâ G__3

(gensym "y") üëâ y6

(gensym "nou") üëâ nou9
```
Dins d'una macro podem disposar de l'**_auto-gensym_**. Podem afegir un sufix `#` a un
s√≠mbol i es generar√† un s√≠mbol √∫nic amb el s√≠mbol com a prefix:

```Clojure
(defmacro crea-multiplicador [x] `(fn [y#] (* y# ~x)))
üëâ #'user/crea-multiplicador

(def y 100) üëâ #'user/y
(def per103 (crea-multiplicador (+ y 3))) üëâ #'user/per103
(per103 10) üëâ 1030
```
---

## Macros: Captura de s√≠mbols

Ara podem entendre altres macros, per exemple l'`and` i l'`or`, del 
[codi font](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj) 
de Clojure:

```Clojure
(defmacro and
  "Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."
  {:added "1.0"}
  ([] true)
  ([x] x)
  ([x & next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))
      
(defmacro or
  "Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."
  {:added "1.0"}
  ([] nil)
  ([x] x)
  ([x & next]
      `(let [or# ~x]
         (if or# or# (or ~@next)))))
```
---

## Macros: Captura de s√≠mbols

Aix√≠ doncs, un exemple d'utilitzaci√≥ de l'_auto-gensym_:

```Clojure
(macroexpand-all '(and a b))
üëâ
(let* [and__5579__auto__ a] 
  (if and__5579__auto__ 
    b 
    and__5579__auto__))
    
(macroexpand-all '(and (or x y) (or z t)))
üëâ
(let* [and__5579__auto__ (let* [or__5581__auto__ x]
                           (if or__5581__auto__
                               or__5581__auto__
                             y))]
  (if and__5579__auto__
      (let* [or__5581__auto__ z]
        (if or__5581__auto__
            or__5581__auto__ t))
    and__5579__auto__))
```
Fixem-nos com hi ha (_gen_)s√≠mbols que s'han "reciclat" on √©s leg√≠tim fer-ho

Cal tenir en compte que els lligams establerts per _special forms_
com `let`, `letfn` o la cl√†usula `catch` de `try` tenen el mateix requeriment
que els par√†metres de funcions, de manera que normalment cal
utilitzar _auto-gensym_ per a aquestes situacions, tamb√©.

---

## Macros: Petita parada, Resum

.center[![:scale 90%](figures/macro2.png)]

.tiny[.red[*Font]: _Programming Clojure, 3rd ed._, Alex Miller with Stuart Halloway and Aaron Bedra,
Pragmatic 2018, p. 249]

---

## Macros: `&form` & `&env`

Dins de les macros (i _nom√©s_ all√†) puc disposar de dos variables: 

* `&env`: diccionari on les claus s√≥n els noms en l'entorn local on expandeixo la macro (els valors s√≥n inst√†ncies de classes que Clojure fa servir internament)

* `&form`: l'expressi√≥ amb que s'ha invocat la macro

```Clojure
(defmacro write-form-and-env [] 
  (println (str "&form √©s " &form)) 
  (println (str "&env √©s " &env))) üëâ #'user/write-form-and-env

(write-form-and-env) üëâ nil

üëÅÔ∏è &form √©s (write-form-and-env)
üëÅÔ∏è &env √©s 

(let [a "a", b "b"] (write-form-and-env)) üëâ nil

üëÅÔ∏è &form √©s (write-form-and-env)
üëÅÔ∏è &env √©s {a #object[clojure.lang.Compiler$LocalBinding 0x68809cc7...], 
            b #object[clojure.lang.Compiler$LocalBinding 0x703feacd...]}
```
---

## Macros: Les macros NO s√≥n _first class_

Les macros **no s√≥n valors** en Clojure. No s√≥n _ciutadans de primera classe_.

Veiem un exemple:

```Clojure
(defn cub [x] (* x x x)) üëâ #'user/cub

(cub 4) üëâ 64

(map cub (range 10)) üëâ (0 1 8 27 64 125 216 343 512 729)

(defmacro cub' [x] `(* ~x ~x ~x)) üëâ #'user/cub'

(cub' 4) üëâ 64
(macroexpand-1 '(cub' 4)) üëâ (clojure.core/* 4 4 4)

(map cub' (range 10)) üëâ Syntax error (...). 
                          Can't take value of a macro: #'user/cub'
```
Si la macro √©s prou senzilla, hi ha un possible _pegat_ per arreglar aix√≤:
```Clojure
(map (fn [n] (cub' n)) (range 10)) üëâ (0 1 8 27 64 125 216 343 512 729)
```
per√≤ no sempre serveix. Dependr√† de la macro.

---

## Macros: Avaluacions m√∫ltiples indesitjades

Ja hem vist com Clojure implementa la macro `and`. Anem a fer una versi√≥ pr√≤pia incorrecte:

```Clojure
(defmacro and'  ;; sense metadades ni comentari
  ([] true)
  ([x] x)
  ([x & next]
    `(if ~x (and' ~@next) ~x))))
```

Veieu on √©s l'error?

---

## Macros: Avaluacions m√∫ltiples indesitjades

Ja hem vist com Clojure implementa la macro `and`. Anem a fer una versi√≥ pr√≤pia incorrecte:

```Clojure
(defmacro and'  ;; sense metadades ni comentari
  ([] true)
  ([x] x)
  ([x & next]
    `(if ~x (and' ~@next) ~x)))
```


Fem una prova:

```Clojure
(and' true true) üëâ true
(and' nil 4) üëâ nil

;; sembla que est√† b√©... per√≤:
 
(and (do (println "yuju") (= 100 101)) true) üëâ false
üëÅÔ∏è yuju

(and' (do (println "yuju") (= 100 101)) true) üëâ false
üëÅÔ∏è yuju
üëÅÔ∏è yuju
```
Veiem que els `~x` provoquen una doble avaluaci√≥, que el `let` de l'`and` original evita.

---

## Macros: Gimn√†stica de Macros

* Implementa una macro per proporcionar una versi√≥ senzilla de `defn`. La podem
  anomenar `defn'` (es pot fer una soluci√≥ en dues l√≠nies de codi).
  
* Implementa una macro per proporcionar l'estructura de control `do-while` a Clojure
  i fes-la servir per fer una funci√≥ `jugar-a-endevinar-nombre` que implementi un 
  joc d'endevinar un nombre entre 1 i 100 (inclosos), amb pistes:
  ```Clojure
  (jugar-a-endevinar-nombre ) üëâ nil
  üëÅÔ∏è N√∫mero? 50
  üëÅÔ∏è √âs m√©s gran
  üëÅÔ∏è N√∫mero? 75
  üëÅÔ∏è √âs m√©s gran
  üëÅÔ∏è N√∫mero? 87
  üëÅÔ∏è √âs m√©s petit
  üëÅÔ∏è N√∫mero? 81
  üëÅÔ∏è √âs m√©s petit 
  üëÅÔ∏è N√∫mero? 78
  üëÅÔ∏è √âs m√©s petit
  üëÅÔ∏è N√∫mero? 76
  üëÅÔ∏è Trobat!
  ```
  Us anir√† b√© saber qu√® fan `print`, `flush`, `Integer/valueOf` i `read-line`.

---

## Macros: Gimn√†stica de Macros

* Explica per quina ra√≥ observem aquest comportament:
  ```Clojure
  (defmacro incognita []
      (println "Quan s'executa aquest println?")
      `(println "Quan s'executa aquest altre println?")) üëâ #'user/incognita
  
  (incognita) üëâ nil
  üëÅÔ∏è Quan s'executa aquest println?
  üëÅÔ∏è Quan s'executa aquest altre println?

  (defn utilitza-la-macro [] (incognita)) üëâ #'user/utilitza-la-macro
  üëÅÔ∏è Quan s'executa aquest println?

  (utilitza-la-macro) üëâ nil
  üëÅÔ∏è Quan s'executa aquest altre println?
  ```
* Feu una macro `rand-expr` que, donades dues expressions `e1` i `e2` es _macroexpandeixi_ 
  a una d'elles **a l'atzar**. Cada cop que hi ha una _macroexpansi√≥_ t√© lloc la tria aleat√≤ria.
  ```Clojure
  (rand-expr (+ 1 2) (* 3 4)) üëâ 12
  (rand-expr (+ 1 2) (* 3 4)) üëâ 12
  (rand-expr (+ 1 2) (* 3 4)) üëâ 3
  (macroexpand '(rand-expr (+ 1 2) (* 3 4))) üëâ (* 3 4)
  (macroexpand '(rand-expr (+ 1 2) (* 3 4))) üëâ (+ 1 2)
  ```

---

## Macros: Gimn√†stica de Macros

* Suposem que volem fer un `fold` amb una macro: Donada una funci√≥ de dos arguments
  `‚äï`, cal que faci un `fold` expl√≠cit, √©s a dir, la crida a `macro-fold`
  s'expandeixi en les corresponents aplicacions de `‚äï`. 
  ```Clojure
  ;; Fem el seg√ºent:
  (defmacro macro-fold [f x0 s]
     (if (empty? s)
       `~x0
       `(~f ~(first s) (macro-fold ~f ~x0 ~(next s)))))

  ;; Ho provem...
  (macro-fold (fn [x a] (+ x (* 2 a))) 0 [1 2 3 4]) üëâ 49
  (macroexpand-all '(macro-fold (fn [x a] (+ x (* 2 a)) 0 [1 2 3 4])) üëâ
  ((fn* ([x a] (+ x (* 2 a))))
     1
     ((fn* ([x a] (+ x (* 2 a))))
      2
      ((fn* ([x a] (+ x (* 2 a))))
       3
       ((fn* ([x a] (+ x (* 2 a))))
        4
        0))))
  (macroexpand-all '(macro-fold ‚äï x0 [x1,x2,x3,x4,x5])) üëâ
  (‚äï x1 (‚äï x2 (‚äï x3 (‚äï x4 (‚äï x5 x0)))))
  ```
  Sembla que `macro-fold` funciona b√©... per√≤ no, no √©s correcte. Per qu√®?

---

## Macros: Usos

Quan conv√© fer servir macros? 

Mirem primer el principal consell sobre quan NO fer servir macros:

<p style="padding: 20px; border: 2px solid red;">.center[**NO fer macros si podem fer servir funcions**]</p>

Dit aix√≤, existeixen situacions on S√ç conv√© fer servir macros.

Un √∫s t√≠pic de les macros √©s el cas de voler afegir **noves estructures de control** a Clojure.

Per exemple, pels que enyorin el `for` de "_tota la vida_", podr√≠em voler afegir a Clojure
una construcci√≥ `for-loop` que funcion√©s de la seg√ºent manera:
```Clojure
;; Volem fer quelcom similar a for (i = 0; i < 5; ++i) ...

(for-loop [i 0, (< i 5), (inc i)] (println i)) üëâ nil
üëÅÔ∏è 0
üëÅÔ∏è 1
üëÅÔ∏è 2
üëÅÔ∏è 3
üëÅÔ∏è 4
```
---

## Macros: Usos

Fixem-nos, com a entrada tenim un vector `[i 0, (< i 5), (inc i)]` i una col¬∑lecci√≥ 
d'expressions que cal avaluar com a _cos del bucle_, en aquest cas nom√©s n'hi ha una
`(println i)`.

Cal recordar, i entendre, que en el proc√©s de _macroexpansi√≥_ podem fer servir Clojure
de manera completa. Per exemple, a les macros podem fer _destructuring_ a l'hora de 
gestionar els par√†metres:
```Clojure
(defmacro for-loop [[simbol inicial condicio canvi :as params] & cos]
  ...
```
Aix√≠, `simbol` ‚â° `i`, `inicial` ‚â° `0`, `condicio` ‚â° `(< i 5)`, `canvi` ‚â° `(inc i)` i finalment
`cos` ‚â° `((println i))` (atenci√≥ al `&`). Tamb√©, com tenim `:as`, `params` ‚â° `[i 0, (< i 5), (inc i)]`.

Ara cal transformar aquesta informaci√≥ en una expressi√≥ Clojure amb `loop/recur`:
```Clojure
`(loop [~simbol ~inicial valor# nil]   ;; utilitzem l'auto-gensym
   (if ~condicio
     (let [nou-valor# (do ~@cos)]
       (recur ~canvi nou-valor#))
     valor#))
```
---

## Macros: Usos

Si ho posem tot junt:
```Clojure
(defmacro for-loop [[simbol inicial condicio canvi :as params] & cos]
  `(loop [~simbol ~inicial valor# nil]   ;; utilitzem l'auto-gensym
     (if ~condicio
       (let [nou-valor# (do ~@cos)]
         (recur ~canvi nou-valor#))
       valor#)))
```
Provem-ho:
```Clojure
(for-loop [i 0, (< i 5), (inc i)] (println i)) üëâ nil
üëÅÔ∏è 0
üëÅÔ∏è 1
üëÅÔ∏è 2
üëÅÔ∏è 3
üëÅÔ∏è 4

(macroexpand '(for-loop [i 0, (< i 5), (inc i)] (println i)))
 üëâ
(loop* [i 0 valor__3__auto__ nil]  ;; pretty-printed
  (if (< i 5)
    (clojure.core/let [nou-valor__4__auto__ (do (println i))]
      (recur (inc i) nou-valor__4__auto__))
    valor__3__auto__))
```
---

## Macros: Usos

Opcionalment podem fer la comprovaci√≥ d'alguns possibles errors, en cas de no fer servir de manera
adequada la macro:
```Clojure
(defmacro for-loop [[simbol inicial condicio canvi :as params] & cos]
  (cond
    (not (vector? params)) 
    (throw (Error. "El 1r argument ha de ser un vector amb el format adequat"))
    
    (not= 4 (count params)) 
    (throw (Error. "Calen exactament 4 elements per definir el for"))
    
    :else
    `(loop [~simbol ~inicial valor# nil]   ;; utilitzem l'auto-gensym
       (if ~condicio
         (let [nou-valor# (do ~@cos)]
           (recur ~canvi nou-valor#))
         valor#))))
         
         
(for-loop [i 0, (< i 5)] (println i)) ;; recordeu que les comes s√≥n espais
üëâ 
Unexpected error (Error) macroexpanding for-loop at (REPL:1:1).
Calen exactament 4 elements per definir el for

```
---

## Macros: Usos



---

## Macros: M√©s Gimn√†stica de Macros

* Hem vist les macros de Clojure per implementar les operacions l√≤giques `and` i `or`. 
  Feu una macro que implementi l'operaci√≥ `nand` (si no sabeu qu√® √©s, mireu [aqu√≠](https://en.wikipedia.org/wiki/Sheffer_stroke))

---

## Macros: _Frikada_ Final

El m√≤dul on trobem `macroexpand-all`, anomenat `clojure.walk`, tamb√© t√© altres funcions.
Una d'elles √©s `postwalk`, que et permet rec√≤rrer l'estructura del codi Clojure,
aplicant una funci√≥ a cada element trobat:

```Clojure
(use '[clojure.walk :as w])

(w/postwalk #(if (symbol? %) (println %) (if (number? %) (println (inc %))))
            '(map inc [1 2 3])) üëâ nil
üëÅÔ∏è map
üëÅÔ∏è inc
üëÅÔ∏è 2
üëÅÔ∏è 3
üëÅÔ∏è 4

(w/postwalk #(if (symbol? %) (println %) (if (number? %) (println (inc %))))
            '(map inc ['a 'b 'c])) üëâ nil
üëÅÔ∏è map
üëÅÔ∏è inc
üëÅÔ∏è quote
üëÅÔ∏è a
üëÅÔ∏è quote
üëÅÔ∏è b
üëÅÔ∏è quote
üëÅÔ∏è c
```

---

## Macros: _Frikada_ Final

Fent servir `postwalk` podem fer una macro... curiosa:

```Clojure
(use '[clojure.string :as s])

(defmacro misteri
  [form]
  (w/postwalk 
   #(if (symbol? %)
      (symbol (s/reverse (name %))) 
      %)
   form))
```
Penseu qu√® fa aquesta macro...

Veiem-ne un exemple:

```Clojure
(misteri (pool [i 5]
           (fi (ton (?orez i))
             (od (nltnirp i)
                 (rucer (ced i)))))) üëâ nil 
üëÅÔ∏è 5
üëÅÔ∏è 4
üëÅÔ∏è 3
üëÅÔ∏è 2
üëÅÔ∏è 1
```
---

## Macros: _Frikada_ Final

La soluci√≥ ens la d√≥na `macroexpand`:

```Clojure
(macroexpand '(misteri (pool [i 5]
                (fi (ton (?orez i))
                  (od (nltnirp i)
                      (rucer (ced i)))))))
üëâ

(loop [i 5]                 ;; en realitat √©s loop* 
  (if (not (zero? i)) 
    (do (println i) 
        (recur (dec i)))))
```
I tenim una macro que ens permet escriure els s√≠mbols de Clojure a l'inrev√©s.red[*]! üòÖ

.footnote[.red[*Font]: _Clojure Programming_, secci√≥ _Writing Your First Macro_, p. 236] 
