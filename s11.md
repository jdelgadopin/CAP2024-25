class: center, up

# CAP - Macros

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 7</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Macros: MotivaciÃ³

Les **_Macros de Lisp_** (i les macros de Clojure ho sÃ³n) neixen l'any
1963 amb l'article de Timothy Hart [_MACRO definitions for
LISP_](http://hdl.handle.net/1721.1/6111). 

Encara avui dia no gaires llenguatges fora dels de la familia de Lisp
(Clojure, Scheme, Common Lisp, Dylan, Racket, etc.) tenen una
capacitat similar. Julia o Elixir en sÃ³n dos exemples.

El fet que els llenguatges de la familia de Lisp siguin [_homoiconics_](https://en.wikipedia.org/wiki/Homoiconicity)
Ã©s el que permet tractar codi com si fossin dades, i transformar programes en programes
(metaprogramaciÃ³) amb facilitat:

_A language is homoiconic if a program written in it can be
manipulated as data using the language. The program's internal
representation can thus be inferred just by reading the program
itself. This property is often summarized by saying that the language
treats **code as data**._

Aquesta possibilitat de metaprogramaciÃ³ que les macros (de Lisp) ens permeten estÃ 
darrera la metodologia de programaciÃ³ associada als programes de la familia de Lisp.
Simplificant, hom resol problemes en Lisp/Clojure creant 
[_Domain-Specific Languages_](https://en.wikipedia.org/wiki/Domain-specific_language) (DSL's)
associats al problema en qÃ¼estiÃ³, en els que sigui senzill formular (un programa que
porti a) una soluciÃ³ del problema.

---

## Macros: MotivaciÃ³

Us recordeu del primer dia de classe? DÃ¨iem...

Ã‰s habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa Ã©s:

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-42.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: MotivaciÃ³

En aquest tema ens centrarem en el quÃ¨ passa en la part assenyalada...

Ã‰s habitual fer servir el **REPL** (_Read, Eval, Print Loop_) en treballar amb Clojure. Provem les
funcions que definim fent-ne prototipus i les testem. Accedirem al **REPL** via terminal o 
via editor/IDE. Sigui com sigui, nosaltres el farem servir molt.

.center[![:scale 90%](figures/Screenshot_2024-08-29_12-34-10.png)]

encara que en realitat el que fa Ã©s:

.center[![:scale 90%](figures/macros1.png)]

.tiny[.red[Font]: _The Joy of Clojure_, p. 15]

---

## Macros: MotivaciÃ³

Veiem-ho una mica millor representat:

.center[![:scale 55%](figures/process.png)]

.tiny[.red[Font]: _Clojure Programming_, secciÃ³ _What is a Macro_, figure 5-1, p. 231]


---

## Macros: MotivaciÃ³

Podem analitzar quÃ¨ passa en les fases de **read** i **eval** que ja coneixem:

En Clojure la instrucciÃ³ `read-string` permet obtenir una estructura
de dades Clojure a partir d'una _string_ de carÃ cters:

```Clojure
(read-string "(+ 1 2)") ğŸ‘‰ (+ 1 2)

(read-string "(map inc (range 10))") ğŸ‘‰ (map inc (range 10))
```
i `eval` ens permet avaluar una estructura de dades Clojure (interpretant-la com a codi):

```Clojure
(eval (read-string "(+ 1 2)")) ğŸ‘‰ 3

(eval (read-string "(map inc (range 10))")) ğŸ‘‰ (1 2 3 4 5 6 7 8 9 10)

;; perÃ² fixem-nos que el pas de read-string Ã©s necessari...

(eval "(+ 1 2)") ğŸ‘‰ "(+ 1 2)"
(eval "(map inc (range 10))") ğŸ‘‰ "(map inc (range 10))"
```
---

## Macros: MotivaciÃ³

_In computer programming, a macro (short for "macro instruction"; from
Greek Î¼Î±ÎºÏÎ¿- 'long, large') is a rule or pattern that specifies how
a certain input should be mapped to a replacement output. Applying a
macro to an input is known as macro expansion._ .small[([Wikipedia](https://en.wikipedia.org/wiki/Macro_%28computer_science%29))]

Ara bÃ©, a la fase d'**ExpansiÃ³** de Clojure Ã©s on passen 
_coses interessants_. Podem veure-ho amb
`macroexpand` i variants:
```Clojure
(macroexpand (read-string "(+ 1 2)")) ğŸ‘‰ (+ 1 2)

(macroexpand (read-string "(map inc (range 10))")) ğŸ‘‰ (map inc (range 10))
```
perÃ²... no sembla que passi res.

Clojure tÃ© moltes macros definides. Una d'elles Ã©s `cond`:

```Clojure
;; Fem (def x 10) i (def y 15) abans...

(read-string "(cond (> x y) 1000 :else -1000)") 
ğŸ‘‰ (cond (> x y) 1000 :else -1000)

(eval (read-string "(cond (> x y) 1000 :else -1000)")) ğŸ‘‰ -1000 
```
Tampoc sembla que passi res d'especial! 

---

## Macros: MotivaciÃ³

A mÃ©s de `macroexpand`, podem fer servir `macroexpand-all`:

```Clojure
;; Hem de fer (use 'clojure.walk) abans, que Ã©s on estÃ  macroexpand-all

(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))

ğŸ‘‰ (if (> x y) 1000 (if :else -1000 nil))
```
Ara sÃ­. El resultat de `macroexpand-all` no Ã©s el que retorna `read-string`!

S'ha transformat una llista de Clojure (que representa codi) en una altra llista de Clojure
(que tambÃ© representa codi). 

La _macroexpansiÃ³_ Ã©s una transformaciÃ³ `Codi font â‡’ Codi font` que tÃ© lloc **_abans_** de l'avaluaciÃ³. 

S'acostuma a dir que la macroexpansiÃ³ tÃ© lloc **_en temps de compilaciÃ³_**.

AixÃ­ doncs, l'avaluador de Clojure no "sap" res de cap `cond`, aquest queda transformat
en una sÃ¨rie de `if` imbricats _abans que el codi
arribi a l'avaluador_!

---

## Macros: MotivaciÃ³

La transformaciÃ³ de codi font en codi font que fan les macros tÃ© lloc **_abans_** d'avaluar
les expressions que contenen les invocacions a les macros.

En realitat, el que fa Clojure Ã©s `(eval (macroexpand-all (read-string "...")))`.red[*]
```Clojure
(eval (macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))) ğŸ‘‰ -1000
```
El procÃ©s de _macroexpansiÃ³_ pot requerir diversos passos. L'exemple que estem
treballant n'Ã©s un cas. `macroexpand-1` en fa un d'aquests passos:

```Clojure
(macroexpand-1 (read-string "(cond (> x y) 1000 :else -1000)"))
ğŸ‘‰ (if (> x y) 1000 (clojure.core/cond :else -1000))
;;                   ------------------
;;          AquÃ­ hi ha un 'cond' encara per expandir

;; en canvi:
(macroexpand-all (read-string "(cond (> x y) 1000 :else -1000)"))
ğŸ‘‰ (if (> x y) 1000 (if :else -1000 nil))
```

Ã‰s clar, doncs, que la definiciÃ³ de les macros pot ser **_recursiva_**.

.footnote[.red[*] En realitat el comportament intern de _macroexpansiÃ³_ no queda fidelment
reproduÃ¯t per <br>`macroexpand-all` (de `clojure.walk`) al 100%, perÃ² Ã©s la variant de 
`macroexpand` que mÃ©s s'hi apropa]

---

## Macros: MotivaciÃ³

Les macros formen part d'un sistema per ampliar un llenguatge de programaciÃ³ fent
servir el mateix llenguatge de programaciÃ³. El mateix _core_ de Clojure estÃ  ple
de macros. Veiem alguns exemples (del [codi font](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj) de Clojure):

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(...)

(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  {:added "1.0"}
  [& clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
                (second clauses)
                (throw (IllegalArgumentException.
                         "cond requires an even number of forms")))
            (cons 'clojure.core/cond (next (next clauses))))))
```

---

## Macros

Si ens fixem en `when` i `cond`, sÃ³n exemples on la transformaciÃ³ de codi
font en codi font es senzillament manipulaciÃ³ de llistes i els seus continguts,
jugant amb `quote` quan cal. **Aquesta transformaciÃ³ es fa en Clojure**.

Hi ha macros una mica mÃ©s complicades, que fan servir funcions i macros de Clojure que 
encara no hem vist:

```Clojure
;; Ara resulta que a Clojure tenÃ­em 'while'!! ğŸ˜

(defmacro while
  "Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil"
  {:added "1.0"}
  [test & body]
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
QuÃ¨ sÃ³n aquests sÃ­mbols `~` o `~@`?

El millor de les macros Ã©s que **_el programador en pot definir de prÃ²pies_**.

Ara veurem com... â¡ï¸

---

## Macros: `defmacro` i els parÃ metres

Per definir macros fem servir `defmacro`. Quan s'invoca una macro cal tenir present una
propietat importantÃ­ssima:

<p style="padding: 20px; border: 2px solid red;">.center[**Els parÃ metres de la macro NO s'avaluen**]</p>

Cap parÃ metre dels que passem a una macro (expressions, llistes, sÃ­mbols, el que sigui) **NO** s'avalua.

Veiem un exemple. Recordem la definiciÃ³ de `when`:

```Clojure
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))

(macroexpand-all '(when (f x) (map g (h x)) nil)) 
ğŸ‘‰ (if (f x) (do (map g (h x)) nil))
```
No s'avalua l'expressiÃ³ `(f x)`, ni la resta de parÃ metres `(map g (h x))` o `nil`. Quan s'invoca
la macro `(when (f x) (map g (h x)) nil)`, aquesta invocaciÃ³ queda _textualment_ substituÃ¯da per
`(if (f x) (do (map g (h x)) nil))`.

---

## Macros: `defmacro` i els parÃ metres

A l'expressiÃ³ `(when (f x) (map g (h x)) nil)` es fa el que diu la definiciÃ³ de la macro sense avaluar
els parÃ metres, Ã©s a dir, els parÃ metres sÃ³n estructures de dades Clojure i es queden com a tals.

Quan executem el cos del `when`: `(list 'if test (cons 'do body))`, `test` Ã©s _literalment_ el
que hem passat a la invocaciÃ³ de `when`, Ã©s a dir, `(f x)`, i body Ã©s la seqÃ¼Ã¨ncia amb la resta
de parÃ metres (com correspÃ³n a `&`) sense avaluar: `((map g (h x)) nil)`.

AixÃ­, `(list 'if test (cons 'do body))` construeix la llista `(if (f x) (do (map g (h x)) nil))`,
que Ã©s el que substitueix `(when (f x) (map g (h x)) nil)` i que serÃ  _posteriorment_ avaluat.

Veiem, doncs, com amb les funcions per manipular llistes de Clojure (aquÃ­ `cons` i `list`) mÃ©s 
`quote` podem manipular i _transformar_ codi font en codi font. El mateix Clojure ens permet
executar una expressiÃ³ per transformar codi font _abans_ de l'execuciÃ³/avaluaciÃ³ en sÃ­ del codi.

El problema Ã©s que amb aquestes funcions no en tenim prou.

---

## Macros: `syntax-quote` _et. al_

VoldrÃ­em tenir una mena de `quote` selectiu, on es poguÃ©s _triar_ quÃ¨ s'avalua o no. AixÃ² Ã©s 
precisament el que fa `syntax-quote`, altrament conegut pel _back-tick_ \`. Com diem el que volem 
que sigui avaluat dins un `syntax-quote`? Fent servir l'`unquote`, o `~`. Amb \` i `~` tenim el 
que necessitem:

```Clojure
user=> (def x 1001)
#'user/x

user=> x   ;; avaluaciÃ³ "normal"
1001

user=> `x  ;; amb syntax-quote
user/x

user=> 'x  ;; amb quote
x

user=> `(list :a :b :c x :d)   ;; syntax-quote actua (gairebÃ©) com un quote...
(clojure.core/list :a :b :c user/x :d)

user=> `(list :a :b :c ~x :d)  ;;... perÃ² podem fer servir l'unquote
(clojure.core/list :a :b :c 1001 :d)
```
Quan fem servir `syntax-quote` els sÃ­mbols no avaluats sÃ³n _namespace-qualified_. Es fa explÃ­cita
la seva pertinenÃ§a a un _namespace_ determinat.

---

## Macros: `syntax-quote` _et. al_

Hi ha una utilitat mÃ©s que ens farÃ  la vida mÃ©s fÃ cil: l'`unquote-splicing`, o `~@`. 

De vegades volem inserir els elements d'una llista en una altra llista:

```Clojure
user=> (def lst '(:e :f :g))
#'user/lst

;; si fem servir unquote...
user=> `(:a :b :c :d ~lst :h)
(:a :b :c :d (:e :f :g) :h)

;; no Ã©s aixÃ² el que volem... perÃ² si faig servir l'unquote-splicing
user=> `(:a :b :c :d ~@lst :h)
(:a :b :c :d :e :f :g :h)
```
L'`unquote-splicing` Ã©s precisament el que fa, si el resultat de l'avaluaciÃ³ Ã©s una llista
insereix els elements de la llista allÃ  on hem fet servir l'`~@`. 

De fet, allÃ² que avaluem amb `~@` ha de resultar obligatÃ²riament en
una llista. En altre cas obtindrem un `Don't know how to create ISeq from:...`

---

## Macros: `syntax-quote` _et. al_

Ara ja podem entendre el `while`:
.cols5050[
.col1[
```Clojure
(defmacro while  ;; sense comentaris
  [test & body]  ;; ni metadades
  `(loop []
     (when ~test
       ~@body
       (recur))))
```
]
.col2[
```Clojure
(let [n (atom 2)]
  (while (not (zero? @n)) 
     (println @n) 
     (swap! n dec))) ğŸ‘‰ nil
ğŸ‘ï¸ 2
ğŸ‘ï¸ 1
```
]]

```Clojure
(macroexpand-all 
      '(let [n (atom 2)] (while (not (zero? @n)) (println @n) (swap! n dec))))
      
ğŸ‘‰ (let* [n (atom 2)] 
     (loop* [] 
        (if (not (zero? (clojure.core/deref n))) 
          (do 
            (println (clojure.core/deref n)) 
            (swap! n dec) 
            (recur)))))
```

`loop*` i `let*` sÃ³n versions _internes_ de `loop` i `let` que el programador no hauria de fer servir.
Tot i aixÃ², l'expansiÃ³ de la macro sÃ­ les fa servir. Fixem-nos que tambÃ© s'ha expandit el `when`.

---

## Macros: `syntax-quote` _et. al_

Hem vist l'expansiÃ³ completa, perÃ² podem entendre-la millor per passos
(ignorarem el `loop*` i el `let*`):

```Clojure
;; primer macro-expandim el while:
(let [n (atom 2)]                   (let [n (atom 2)]
  (while (not (zero? @n))  ğŸ‘‰ğŸ‘‰ğŸ‘‰    (loop [] 
    (println @n)                        (when (not (zero? (clojure.core/deref n)))
    (swap! n dec)))                       (println (clojure.core/deref n))
                                          (swap! n dec)
                                          (recur))))
;; ara macro-expandim el when:
(let [n (atom 2)]
  (loop [] 
    (when (not (zero? (clojure.core/deref n)))
      (println (clojure.core/deref n))
      (swap! n dec)
      (recur))))

        ğŸ‘‡ğŸ‘‡ğŸ‘‡

(let [n (atom 2)] 
  (loop [] 
    (if (not (zero? (clojure.core/deref n))) 
      (do 
        (println (clojure.core/deref n)) 
        (swap! n dec) 
        (recur)))))
```
---

## Macros: Captura de sÃ­mbols

El mÃ³n de les macros Ã©s ple de subtileses, que anirem veient poc a poc. Comencem amb el que s'anomena
**_symbol capture_**.

Comencem pel problema d'escriure sÃ­mbols en el codi generat per
`syntax-quote`. Suposem que fem la macro `cubs`:

```Clojure
(defmacro cubs [s] `(map (fn [x] (* x x x)) ~s)) ğŸ‘‰ #'user/cubs
(cubs (range 10)) ğŸ‘‰ Error ;; es queixa perquÃ¨ no sap quÃ¨ Ã©s user/x
```
En fer servir `cubs` ens trobem que els sÃ­mbols que fem servir, `x` en particular, Ã©s
interpretat pel `syntax-quote` com a un sÃ­mbol del _namespace_ _user_, `user/x`, i no ho Ã©s. Ã‰s el
parÃ metre d'una funciÃ³, i aixÃ­ haurÃ­em d'escriure'l.

Haurem de fer que determinats sÃ­mbols que ens interessen no siguin processats per 
`syntax-quote`: Si fem `(unquote (quote x))`, Ã©s a dir `~'x`, aconseguim que el codi generat escrigui
senzillament `x`:
```Clojure
(defmacro cubs [s] `(map (fn [~'x] (* ~'x ~'x ~'x)) ~s)) ğŸ‘‰ #'user/cubs
(cubs (range 10)) ğŸ‘‰ (0 1 8 27 64 125 216 343 512 729)
```
---

## Macros: Captura de sÃ­mbols

Ara fem una altra macro: `crea-multiplicador`:
```Clojure
(defmacro crea-multiplicador [x] `(fn [~'y] (* ~'y ~x))) 
ğŸ‘‰ #'user/crea-multiplicador
;; (crea-multiplicador x) macorexpandirÃ  a la closure (fn [y] (* x y))
(def per3 (crea-multiplicador 3)) ğŸ‘‰ #'user/per3
;; per3 Ã©s en realitat el resultat d'avaluar (fn [y] (* 3 y))
(per3 10) ğŸ‘‰ 30
```
Tot sembla correcte. Anem, perÃ², a fer un experiment:
```Clojure
(def y 100) ğŸ‘‰ #'user/y
(def per103 (crea-multiplicador (+ y 3))) ğŸ‘‰ #'user/per103
(per103 10) ğŸ‘‰ 130 ;; !!!!
```
Aquest no Ã©s el resultat correcte! EsperÃ vem `1030`. QuÃ¨ ha passat?
Macroexpandim _a mÃ _...
```Clojure
(crea-multiplicador (+ y 3)) ğŸ‘‰ (fn [y] (* (+ y 3) y))
((fn [y] (* (+ y 3) y)) 10) â‰¡ (* 13 10) â‰¡ 130
```
Direm que `y` (Ã©s a dir, `user/y`) ha estat **_capturada_** (pel codi generat per la macro).

---

## Macros: Captura de sÃ­mbols

AixÃ­ doncs, quÃ¨ podem fer per evitar la captura de sÃ­mbols (a banda
d'anar amb molt de compte)?

Clojure ens proporciona la funciÃ³ `gensym`. La seva aplicaciÃ³ ens proporciona un sÃ­mbol
nou, que no ha estat utilitzat fins el moment. Es pot proporcionar un prefix:
```Clojure
(gensym) ğŸ‘‰ G__3

(gensym "y") ğŸ‘‰ y6

(gensym "nou") ğŸ‘‰ nou9
```
Dins d'una macro podem disposar de l'**_auto-gensym_**. Podem afegir un sufix `#` a un
sÃ­mbol i es generarÃ  un sÃ­mbol Ãºnic amb el sÃ­mbol com a prefix:

```Clojure
(defmacro crea-multiplicador [x] `(fn [y#] (* y# ~x)))
ğŸ‘‰ #'user/crea-multiplicador

(def y 100) ğŸ‘‰ #'user/y
(def per103 (crea-multiplicador (+ y 3))) ğŸ‘‰ #'user/per103
(per103 10) ğŸ‘‰ 1030
```
---

## Macros: Captura de sÃ­mbols

Ara podem entendre altres macros, per exemple l'`and` i l'`or`, del 
[codi font](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj) 
de Clojure:

```Clojure
(defmacro and
  "Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."
  {:added "1.0"}
  ([] true)
  ([x] x)
  ([x & next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))
      
(defmacro or
  "Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."
  {:added "1.0"}
  ([] nil)
  ([x] x)
  ([x & next]
      `(let [or# ~x]
         (if or# or# (or ~@next)))))
```
---

## Macros: Captura de sÃ­mbols

AixÃ­ doncs, un exemple d'utilitzaciÃ³ de l'_auto-gensym_:

```Clojure
(macroexpand-all '(and a b))
ğŸ‘‰
(let* [and__5579__auto__ a] 
  (if and__5579__auto__ 
    b 
    and__5579__auto__))
    
(macroexpand-all '(and (or x y) (or z t)))
ğŸ‘‰
(let* [and__5579__auto__ (let* [or__5581__auto__ x]
                           (if or__5581__auto__
                               or__5581__auto__
                             y))]
  (if and__5579__auto__
      (let* [or__5581__auto__ z]
        (if or__5581__auto__
            or__5581__auto__ t))
    and__5579__auto__))
```
Fixem-nos com hi ha (_gen_)sÃ­mbols que s'han "reciclat" on Ã©s legÃ­tim fer-ho

Cal tenir en compte que els lligams establerts per _special forms_
com `let`, `letfn` o la clÃ usula `catch` de `try` tenen el mateix requeriment
que els parÃ metres de funcions, de manera que normalment cal
utilitzar _auto-gensym_ per a aquestes situacions, tambÃ©.

---

## Macros: Petita parada, Resum

.center[![:scale 90%](figures/macro2.png)]

.tiny[.red[*Font]: _Programming Clojure, 3rd ed._, Alex Miller with Stuart Halloway and Aaron Bedra,
Pragmatic 2018, p. 249]

---

## Macros: `&form` & `&env`

Dins de les macros (i _nomÃ©s_ allÃ ) puc disposar de dos variables: 

* `&env`: diccionari on les claus sÃ³n els noms en l'entorn local on expandeixo la macro (els valors sÃ³n instÃ ncies de classes que Clojure fa servir internament)

* `&form`: l'expressiÃ³ amb que s'ha invocat la macro

```Clojure
(defmacro write-form-and-env [] 
  (println (str "&form Ã©s " &form)) 
  (println (str "&env Ã©s " &env))) ğŸ‘‰ #'user/write-form-and-env

(write-form-and-env) ğŸ‘‰ nil

ğŸ‘ï¸ &form Ã©s (write-form-and-env)
ğŸ‘ï¸ &env Ã©s 

(let [a "a", b "b"] (write-form-and-env)) ğŸ‘‰ nil

ğŸ‘ï¸ &form Ã©s (write-form-and-env)
ğŸ‘ï¸ &env Ã©s {a #object[clojure.lang.Compiler$LocalBinding 0x68809cc7...], 
            b #object[clojure.lang.Compiler$LocalBinding 0x703feacd...]}
```
---

## Macros: Les macros NO sÃ³n _first class_

Les macros **no sÃ³n valors** en Clojure. No sÃ³n _ciutadans de primera classe_.

Veiem un exemple:

```Clojure
(defn cub [x] (* x x x)) ğŸ‘‰ #'user/cub

(cub 4) ğŸ‘‰ 64

(map cub (range 10)) ğŸ‘‰ (0 1 8 27 64 125 216 343 512 729)

(defmacro cub' [x] `(* ~x ~x ~x)) ğŸ‘‰ #'user/cub'

(cub' 4) ğŸ‘‰ 64
(macroexpand-1 '(cub' 4)) ğŸ‘‰ (clojure.core/* 4 4 4)

(map cub' (range 10)) ğŸ‘‰ Syntax error (...). 
                          Can't take value of a macro: #'user/cub'
```
Si la macro Ã©s prou senzilla, hi ha un possible _pegat_ per arreglar aixÃ²:
```Clojure
(map (fn [n] (cub' n)) (range 10)) ğŸ‘‰ (0 1 8 27 64 125 216 343 512 729)
```
perÃ² no sempre serveix. DependrÃ  de la macro.

---

## Macros: Avaluacions mÃºltiples indesitjades

Ja hem vist com Clojure implementa la macro `and`. Anem a fer una versiÃ³ prÃ²pia incorrecte:

```Clojure
(defmacro and'  ;; sense metadades ni comentari
  ([] true)
  ([x] x)
  ([x & next]
    `(if ~x (and' ~@next) ~x))))
```

Veieu on Ã©s l'error?

---

## Macros: Avaluacions mÃºltiples indesitjades

Ja hem vist com Clojure implementa la macro `and`. Anem a fer una versiÃ³ prÃ²pia incorrecte:

```Clojure
(defmacro and'  ;; sense metadades ni comentari
  ([] true)
  ([x] x)
  ([x & next]
    `(if ~x (and' ~@next) ~x)))
```


Fem una prova:

```Clojure
(and' true true) ğŸ‘‰ true
(and' nil 4) ğŸ‘‰ nil

;; sembla que estÃ  bÃ©... perÃ²:
 
(and (do (println "yuju") (= 100 101)) true) ğŸ‘‰ false
ğŸ‘ï¸ yuju

(and' (do (println "yuju") (= 100 101)) true) ğŸ‘‰ false
ğŸ‘ï¸ yuju
ğŸ‘ï¸ yuju
```
Veiem que els `~x` provoquen una doble avaluaciÃ³, que el `let` de l'`and` original evita.

---

## Macros: GimnÃ stica de Macros

* Implementa una macro per proporcionar una versiÃ³ senzilla de `defn`. La podem
  anomenar `defn'` (es pot fer una soluciÃ³ en dues lÃ­nies de codi).
  
* Implementa una macro per proporcionar l'estructura de control `do-while` a Clojure
  i fes-la servir per fer una funciÃ³ `jugar-a-endevinar-nombre` que implementi un 
  joc d'endevinar un nombre entre 1 i 100 (inclosos), amb pistes:
  ```Clojure
  (jugar-a-endevinar-nombre ) ğŸ‘‰ nil
  ğŸ‘ï¸ NÃºmero? 50
  ğŸ‘ï¸ Ã‰s mÃ©s gran
  ğŸ‘ï¸ NÃºmero? 75
  ğŸ‘ï¸ Ã‰s mÃ©s gran
  ğŸ‘ï¸ NÃºmero? 87
  ğŸ‘ï¸ Ã‰s mÃ©s petit
  ğŸ‘ï¸ NÃºmero? 81
  ğŸ‘ï¸ Ã‰s mÃ©s petit 
  ğŸ‘ï¸ NÃºmero? 78
  ğŸ‘ï¸ Ã‰s mÃ©s petit
  ğŸ‘ï¸ NÃºmero? 76
  ğŸ‘ï¸ Trobat!
  ```
  Us anirÃ  bÃ© saber quÃ¨ fan `print`, `flush`, `Integer/valueOf` i `read-line`.

---

## Macros: GimnÃ stica de Macros

* Explica per quina raÃ³ observem aquest comportament:
  ```Clojure
  (defmacro incognita []
      (println "Quan s'executa aquest println?")
      `(println "Quan s'executa aquest altre println?")) ğŸ‘‰ #'user/incognita
  
  (incognita) ğŸ‘‰ nil
  ğŸ‘ï¸ Quan s'executa aquest println?
  ğŸ‘ï¸ Quan s'executa aquest altre println?

  (defn utilitza-la-macro [] (incognita)) ğŸ‘‰ #'user/utilitza-la-macro
  ğŸ‘ï¸ Quan s'executa aquest println?

  (utilitza-la-macro) ğŸ‘‰ nil
  ğŸ‘ï¸ Quan s'executa aquest altre println?
  ```
* Feu una macro `rand-expr` que, donades dues expressions `e1` i `e2` es _macroexpandeixi_ 
  a una d'elles **a l'atzar**. Cada cop que hi ha una _macroexpansiÃ³_ tÃ© lloc la tria aleatÃ²ria.
  ```Clojure
  (rand-expr (+ 1 2) (* 3 4)) ğŸ‘‰ 12
  (rand-expr (+ 1 2) (* 3 4)) ğŸ‘‰ 12
  (rand-expr (+ 1 2) (* 3 4)) ğŸ‘‰ 3
  (macroexpand '(rand-expr (+ 1 2) (* 3 4))) ğŸ‘‰ (* 3 4)
  (macroexpand '(rand-expr (+ 1 2) (* 3 4))) ğŸ‘‰ (+ 1 2)
  ```

---

## Macros: GimnÃ stica de Macros

* Suposem que volem fer un `fold` amb una macro: Donada una funciÃ³ de dos arguments
  `âŠ•`, cal que faci un `fold` explÃ­cit, Ã©s a dir, la crida a `macro-fold`
  s'expandeixi en les corresponents aplicacions de `âŠ•`. 
  ```Clojure
  ;; Fem el segÃ¼ent:
  (defmacro macro-fold [f x0 s]
     (if (empty? s)
       `~x0
       `(~f ~(first s) (macro-fold ~f ~x0 ~(next s)))))

  ;; Ho provem...
  (macro-fold (fn [x a] (+ x (* 2 a))) 0 [1 2 3 4]) ğŸ‘‰ 49
  (macroexpand-all '(macro-fold (fn [x a] (+ x (* 2 a)) 0 [1 2 3 4])) ğŸ‘‰
  ((fn* ([x a] (+ x (* 2 a))))
     1
     ((fn* ([x a] (+ x (* 2 a))))
      2
      ((fn* ([x a] (+ x (* 2 a))))
       3
       ((fn* ([x a] (+ x (* 2 a))))
        4
        0))))
  (macroexpand-all '(macro-fold âŠ• x0 [x1,x2,x3,x4,x5])) ğŸ‘‰
  (âŠ• x1 (âŠ• x2 (âŠ• x3 (âŠ• x4 (âŠ• x5 x0)))))
  ```
  Sembla que `macro-fold` funciona bÃ©... perÃ² no, no Ã©s correcte. Per quÃ¨?

---

## Macros: Usos

Quan convÃ© fer servir macros? 

Mirem primer el principal consell sobre quan NO fer servir macros:

<p style="padding: 20px; border: 2px solid red;">.center[**NO fer macros si podem fer servir funcions**]</p>

Dit aixÃ², existeixen situacions on SÃ convÃ© fer servir macros.

Un Ãºs tÃ­pic de les macros Ã©s el cas de voler afegir **noves estructures de control** a Clojure.

Per exemple, pels que enyorin el `for` de "_tota la vida_", podrÃ­em voler afegir a Clojure
una construcciÃ³ `for-loop` que funcionÃ©s de la segÃ¼ent manera:
```Clojure
;; Volem fer quelcom similar a for (i = 0; i < 5; ++i) ...

(for-loop [i 0, (< i 5), (inc i)] (println i)) ğŸ‘‰ nil
ğŸ‘ï¸ 0
ğŸ‘ï¸ 1
ğŸ‘ï¸ 2
ğŸ‘ï¸ 3
ğŸ‘ï¸ 4
```
---

## Macros: Usos

Fixem-nos, com a entrada tenim un vector `[i 0, (< i 5), (inc i)]` i una colÂ·lecciÃ³ 
d'expressions que cal avaluar com a _cos del bucle_, en aquest cas nomÃ©s n'hi ha una
`(println i)`.

Cal recordar, i entendre, que en el procÃ©s de _macroexpansiÃ³_ podem fer servir Clojure
de manera completa. Per exemple, a les macros podem fer _destructuring_ a l'hora de 
gestionar els parÃ metres:
```Clojure
(defmacro for-loop [[simbol inicial condicio canvi :as params] & cos]
  ...
```
AixÃ­, `simbol` â‰¡ `i`, `inicial` â‰¡ `0`, `condicio` â‰¡ `(< i 5)`, `canvi` â‰¡ `(inc i)` i finalment
`cos` â‰¡ `((println i))` (atenciÃ³ al `&`). TambÃ©, com tenim `:as`, `params` â‰¡ `[i 0, (< i 5), (inc i)]`.

Ara cal transformar aquesta informaciÃ³ en una expressiÃ³ Clojure amb `loop/recur`:
```Clojure
`(loop [~simbol ~inicial valor# nil]   ;; utilitzem l'auto-gensym
   (if ~condicio
     (let [nou-valor# (do ~@cos)]
       (recur ~canvi nou-valor#))
     valor#))
```
---

## Macros: Usos

Si ho posem tot junt:
```Clojure
(defmacro for-loop [[simbol inicial condicio canvi :as params] & cos]
  `(loop [~simbol ~inicial valor# nil]   ;; utilitzem l'auto-gensym
     (if ~condicio
       (let [nou-valor# (do ~@cos)]
         (recur ~canvi nou-valor#))
       valor#)))
```
Provem-ho:
```Clojure
(for-loop [i 0, (< i 5), (inc i)] (println i)) ğŸ‘‰ nil
ğŸ‘ï¸ 0
ğŸ‘ï¸ 1
ğŸ‘ï¸ 2
ğŸ‘ï¸ 3
ğŸ‘ï¸ 4

(macroexpand '(for-loop [i 0, (< i 5), (inc i)] (println i)))
 ğŸ‘‰
(loop* [i 0 valor__3__auto__ nil]  ;; pretty-printed
  (if (< i 5)
    (clojure.core/let [nou-valor__4__auto__ (do (println i))]
      (recur (inc i) nou-valor__4__auto__))
    valor__3__auto__))
```
---

## Macros: Usos

Opcionalment podem fer la comprovaciÃ³ d'alguns possibles errors, en cas de no fer servir de manera
adequada la macro:
```Clojure
(defmacro for-loop [[simbol inicial condicio canvi :as params] & cos]
  (cond
    (not (vector? params)) 
    (throw (Error. "El 1r argument ha de ser un vector amb el format adequat"))
    
    (not= 4 (count params)) 
    (throw (Error. "Calen exactament 4 elements per definir el for"))
    
    :else
    `(loop [~simbol ~inicial valor# nil]   ;; utilitzem l'auto-gensym
       (if ~condicio
         (let [nou-valor# (do ~@cos)]
           (recur ~canvi nou-valor#))
         valor#))))
         
         
(for-loop [i 0, (< i 5)] (println i)) ;; recordeu que les comes sÃ³n espais
ğŸ‘‰ 
Unexpected error (Error) macroexpanding for-loop at (REPL:1:1).
Calen exactament 4 elements per definir el for

```
---

## Macros: Usos



---

## Macros: MÃ©s GimnÃ stica de Macros

* Hem vist les macros de Clojure per implementar les operacions lÃ²giques `and` i `or`. 
  Feu una macro que implementi l'operaciÃ³ `nand` (si no sabeu quÃ¨ Ã©s, mireu [aquÃ­](https://en.wikipedia.org/wiki/Sheffer_stroke))

---

## Macros: _Frikada_ Final

El mÃ²dul on trobem `macroexpand-all`, anomenat `clojure.walk`, tambÃ© tÃ© altres funcions.
Una d'elles Ã©s `postwalk`, que et permet recÃ²rrer l'estructura del codi Clojure,
aplicant una funciÃ³ a cada element trobat:

```Clojure
(use '[clojure.walk :as w])

(w/postwalk #(if (symbol? %) (println %) (if (number? %) (println (inc %))))
            '(map inc [1 2 3])) ğŸ‘‰ nil
ğŸ‘ï¸ map
ğŸ‘ï¸ inc
ğŸ‘ï¸ 2
ğŸ‘ï¸ 3
ğŸ‘ï¸ 4

(w/postwalk #(if (symbol? %) (println %) (if (number? %) (println (inc %))))
            '(map inc ['a 'b 'c])) ğŸ‘‰ nil
ğŸ‘ï¸ map
ğŸ‘ï¸ inc
ğŸ‘ï¸ quote
ğŸ‘ï¸ a
ğŸ‘ï¸ quote
ğŸ‘ï¸ b
ğŸ‘ï¸ quote
ğŸ‘ï¸ c
```

---

## Macros: _Frikada_ Final

Fent servir `postwalk` podem fer una macro... curiosa:

```Clojure
(use '[clojure.string :as s])

(defmacro misteri
  [form]
  (w/postwalk 
   #(if (symbol? %)
      (symbol (s/reverse (name %))) 
      %)
   form))
```
Penseu quÃ¨ fa aquesta macro...

Veiem-ne un exemple:

```Clojure
(misteri (pool [i 5]
           (fi (ton (?orez i))
             (od (nltnirp i)
                 (rucer (ced i)))))) ğŸ‘‰ nil 
ğŸ‘ï¸ 5
ğŸ‘ï¸ 4
ğŸ‘ï¸ 3
ğŸ‘ï¸ 2
ğŸ‘ï¸ 1
```
---

## Macros: _Frikada_ Final

La soluciÃ³ ens la dÃ³na `macroexpand`:

```Clojure
(macroexpand '(misteri (pool [i 5]
                (fi (ton (?orez i))
                  (od (nltnirp i)
                      (rucer (ced i)))))))
ğŸ‘‰

(loop [i 5]                 ;; en realitat Ã©s loop* 
  (if (not (zero? i)) 
    (do (println i) 
        (recur (dec i)))))
```
I tenim una macro que ens permet escriure els sÃ­mbols de Clojure a l'inrevÃ©s.red[*]! ğŸ˜…

.footnote[.red[*Font]: _Clojure Programming_, secciÃ³ _Writing Your First Macro_, p. 236] 
