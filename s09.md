class: center, up

# CAP - Immutabilitat d'Estructures de Dades

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 5</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Immutabilitat d'Estructures de Dades

_Immutability refers to the **inability to change an object after it has
been created. In an immutable system, any modification to data results
in the creation of a new object, leaving the original unchanged**. This
concept might initially seem inefficient, especially to developers
accustomed to mutable state in languages like Java. However,
immutability offers several advantages.red[*]:_

* _**Predictability**: Immutable data structures eliminate side effects,
making functions more predictable and easier to reason about. Since
data cannot change unexpectedly, the behavior of functions remains
consistent._

* _**Concurrency**: Immutability naturally supports concurrent programming.
Since data cannot be altered, there is no risk of race conditions or
the need for complex locking mechanisms._

* _**Simplified Debugging**: With immutable data, the state of the system at
any point in time is clear and unambiguous, simplifying debugging and
testing._

* _**Enhanced Reusability**: Functions operating on immutable data are
inherently more reusable, as they do not depend on or alter external
state._

.footnote[.red[*] [Font: clojureforjava.com](https://clojureforjava.com/3/1/1/3/)]

---

## Immutabilitat d'Estructures de Dades

A Clojure, hem dit des del principi de curs que les colÂ·leccions que
hem treballat (llistes, vectors, conjunts, _strings_, diccionaris) sÃ³n
_**immutables**_, Ã©s a dir, sempre preserven una versiÃ³ d'elles
mateixes quan les modifiquem. 

En realitat, la immutabilitat Ã©s conseqÃ¼Ã¨ncia d'una caracterÃ­stica
fonamental d'aquestes estructures de dades: SÃ³n estructures de dades
**persistents**.

PerÃ²... _A natural concern when confronted with this picture of
persistence is that a naive implementation would copy the entire
collection on each change, leading to slow operations and poor use of
memory. Clojureâ€™s implementations (Bagwell 2001.red[*]) are instead efficient
by sharing structural elements from one version of a persistent
structure to another._<br> (_The Joy of Clojure_ p.86)

AquÃ­ estÃ  el quid de la qÃ¼estiÃ³: el que s'anomena **_efficient structural sharing_**.

En aquest tema mirarem d'explicar, sense entrar en massa detalls, com la persistÃ¨ncia pot
fer-se eficient (basant-nos sobre tot en la secciÃ³ 6.2, p. 120, de _The Joy of Clojure_)

.footnote[.red[*] [_Ideal Hash Trees_](https://lampwww.epfl.ch/papers/idealhashtrees.pdf), Phil Bagwell, Programming Methods Laboratory (EPFL) technical report, 2001.]

---

## Immutabilitat d'Estructures de Dades

Les colÂ·leccions a Clojure estan implementades de manera que l'_structural sharing_ sigui
eficient. Les llistes estan implementades com a llistes enllaÃ§ades (_linked lists_) i vectors
i diccionaris estan implementats amb arbres (no arbres qualsevol, Ã©s clar). Els conjunts sÃ³n
una variant dels diccionaris i s'implementen essencialment igual.

Comencem per les llistes:

```Clojure
(def llista-original '(:a :b :c :d))

(def llista-1 (cons :e llista-original))
(def llista-2 (cons :f llista-1))
(def llista-3 (cons :aa (rest llista-original)))

llista-original ğŸ‘‰ (:a :b :c :d)
llista-1 ğŸ‘‰ (:e :a :b :c :d)
llista-2 ğŸ‘‰ (:f :e :a :b :c :d)
llista-3 ğŸ‘‰ (:aa :b :c :d)
```
---

## Immutabilitat d'Estructures de Dades

Fem algunes "preguntes" per mirar de trobar com estan construÃ¯des aquestes llistes:

```Clojure
(= (rest llista-original) (rest (rest llista-1))) ğŸ‘‰ true
(= llista-original (rest (rest llista-2)))        ğŸ‘‰ true
(= (rest llista-original) (rest llista-3))        ğŸ‘‰ true
(= (rest llista-original) '(:b :c :d))            ğŸ‘‰ true
```
AixÃ² no ens hauria de sorprendre. Anem, perÃ², una mica mÃ©s enllÃ  i siguem
mÃ©s exigents amb el que preguntem (Ã©s el primer cop que apareix `identical?` perÃ² hauria
de ser prou obvi quÃ¨ fa):

```Clojure
(identical? (rest llista-original) (rest (rest llista-1))) ğŸ‘‰ true
(identical? llista-original (rest (rest llista-2)))        ğŸ‘‰ true
(identical? (rest llista-original) (rest llista-3))        ğŸ‘‰ true
(identical? (rest llista-original) '(:b :c :d))            ğŸ‘‰ false ;; (!!)
```
Podem explicar aquests resultats?

---

## Immutabilitat d'Estructures de Dades

La manera d'entendre per quina rÃ¡o hem obtingut les respostes de la transparÃ¨ncia anterior
Ã©s entenent que les llistes s'implementen de manera que:

* La modificaciÃ³ d'una llista NO altera la llista original.

* Es mantenen totes les propietats d'una llista, independentment de les operacions que
fem amb ella (cost d'accÃ©s, espai que ocupa, etc.).

No es copien (Ã­ntegrament) les llistes per tal de fer-les persistents. 
Es comparteix la seva estructura, creant els nodes nous estrictament necessaris. 

GrÃ ficament:

.center[![:scale 80%](figures/ss-llista.png)]

---

## Immutabilitat d'Estructures de Dades

Aquest tema ha estat basat essencialment en:

* _The Joy of Clojure_, secciÃ³ 5.1, p. 85 i seccions 6.1, p. 117, i 6.2, p.120.

PerÃ² si voleu anar mÃ©s enllÃ  (_bastant_ mÃ©s enllÃ !), podeu consultar:

* _Understanding Clojure's PersistentVector implementation_, ([Entrada del blog _Higher Order_](https://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation.html), Karl Krukow, Febrer 2009).

*  [_Ideal Hash Trees_](https://lampwww.epfl.ch/papers/idealhashtrees.pdf), Phil Bagwell, LAML - Programming Methods Laboratory (EPFL) technical report, 2001.

I sobre tot...

.cols5050[
.col1[
.right[![:scale 30%](figures/okasaki.png)]
]
.col2[
[Purely Functional Data Structures](https://www.cambridge.org/in/universitypress/subjects/computer-science/programming-languages-and-applied-logic/purely-functional-data-structures?format=PB&isbn=9780521663502),
Chris Okasaki, Cambridge University Press 1999.
]]

