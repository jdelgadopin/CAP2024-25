class: center, up

# CAP - Immutabilitat d'Estructures de Dades

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 5</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Immutabilitat d'Estructures de Dades: Per qu√®?

_Immutability refers to the **inability to change an object after it has
been created. In an immutable system, any modification to data results
in the creation of a new object, leaving the original unchanged**. This
concept might initially seem inefficient, especially to developers
accustomed to mutable state in languages like Java. However,
immutability offers several advantages.red[*]:_

* _**Predictability**: Immutable data structures eliminate side effects,
making functions more predictable and easier to reason about. Since
data cannot change unexpectedly, the behavior of functions remains
consistent._

* _**Concurrency**: Immutability naturally supports concurrent programming.
Since data cannot be altered, there is no risk of race conditions or
the need for complex locking mechanisms._

* _**Simplified Debugging**: With immutable data, the state of the system at
any point in time is clear and unambiguous, simplifying debugging and
testing._

* _**Enhanced Reusability**: Functions operating on immutable data are
inherently more reusable, as they do not depend on or alter external
state._

.footnote[.red[*] [Font: clojureforjava.com](https://clojureforjava.com/3/1/1/3/)]

---

## Immutabilitat d'Estructures de Dades: _Structural Sharing_

A Clojure, hem dit des del principi de curs que les col¬∑leccions que
hem treballat (llistes, vectors, conjunts, diccionaris) s√≥n
_**immutables**_, √©s a dir, sempre preserven una versi√≥ d'elles
mateixes quan les modifiquem. 

En realitat, la immutabilitat √©s conseq√º√®ncia d'una caracter√≠stica
fonamental d'aquestes estructures de dades: S√≥n estructures de dades
**persistents**.

Per√≤... _A natural concern when confronted with this picture of
persistence is that a naive implementation would copy the entire
collection on each change, leading to slow operations and poor use of
memory. Clojure‚Äôs implementations (Bagwell 2001.red[*]) are instead efficient
by sharing structural elements from one version of a persistent
structure to another._<br> (_The Joy of Clojure_ p.86)

Aqu√≠ est√† el quid de la q√ºesti√≥: el que s'anomena **_efficient structural sharing_**.

En aquest tema mirarem d'explicar, sense entrar en massa detalls, com la persist√®ncia pot
fer-se eficient (basant-nos sobre tot en la secci√≥ 6.2, p. 120, de _The Joy of Clojure_)

.footnote[.red[*] [_Ideal Hash Trees_](https://lampwww.epfl.ch/papers/idealhashtrees.pdf), Phil Bagwell, Programming Methods Laboratory (EPFL) technical report, 2001.]

---

## Immutabilitat d'Estructures de Dades: Llistes

Les col¬∑leccions a Clojure estan implementades de manera que
l'_structural sharing_ sigui eficient. Les llistes estan implementades
com a llistes enlla√ßades (_linked lists_) i vectors i diccionaris
estan implementats amb variants de
[Trie](https://en.wikipedia.org/wiki/Trie). Els conjunts s√≥n una
variant dels diccionaris i s'implementen essencialment igual.

Comencem per les llistes:

```Clojure
(def llista-original '(:a :b :c :d))

(def llista-1 (cons :e llista-original))
(def llista-2 (cons :f llista-1))
(def llista-3 (cons :aa (rest llista-original)))

llista-original üëâ (:a :b :c :d)
llista-1 üëâ (:e :a :b :c :d)
llista-2 üëâ (:f :e :a :b :c :d)
llista-3 üëâ (:aa :b :c :d)
```
---

## Immutabilitat d'Estructures de Dades: Llistes

Fem algunes "preguntes" per mirar de trobar com estan constru√Ødes aquestes llistes:

```Clojure
(= (rest llista-original) (rest (rest llista-1))) üëâ true
(= llista-original (rest (rest llista-2)))        üëâ true
(= (rest llista-original) (rest llista-3))        üëâ true
(= (rest llista-original) '(:b :c :d))            üëâ true
```
Aix√≤ no ens hauria de sorprendre. Anem, per√≤, una mica m√©s enll√† i siguem
m√©s exigents amb el que preguntem (√©s el primer cop que apareix `identical?` per√≤ hauria
de ser prou obvi qu√® fa):

```Clojure
(identical? (rest llista-original) (rest (rest llista-1))) üëâ true
(identical? llista-original (rest (rest llista-2)))        üëâ true
(identical? (rest llista-original) (rest llista-3))        üëâ true
(identical? (rest llista-original) '(:b :c :d))            üëâ false ;; (!!)
```
Podem explicar aquests resultats?

---

## Immutabilitat d'Estructures de Dades: Llistes

La manera d'entendre per quina r√°o hem obtingut les respostes de la transpar√®ncia anterior
√©s entenent que les llistes s'implementen de manera que:

* La modificaci√≥ d'una llista NO altera la llista original.

* Es mantenen totes les propietats d'una llista, independentment de les operacions que
fem amb ella (cost d'acc√©s, espai que ocupa, etc.).

No es copien (√≠ntegrament) les llistes per tal de fer-les persistents. 
Es comparteix la seva estructura, creant els nodes nous estrictament necessaris. 

Gr√†ficament:

.center[![:scale 80%](figures/ss-llista.png)]

---

## Immutabilitat d'Estructures de Dades: Vectors i Diccionaris

Ja hem vist que a Clojure no es fan servir massa les llistes. S√≥n
importants sobre tot per manipular codi a les macros (cosa que encara
hem d'estudiar). Les col¬∑leccions m√©s utilitzades s√≥n els vectors i
els diccionaris.

Vectors i diccionaris no s'implementen amb llistes enlla√ßades. A m√©s, com que estem parlant
d'implementacions, no t√© gaire sentit referir-nos a l'interficie abstracta de les seq√º√®ncies.

El creador de Clojure, Rich Hickey, va inventar versions eficients i persistents
de variants d'una estructura de dades anomenada
[**Trie**](https://en.wikipedia.org/wiki/Trie)  per poder implementar
vectors i diccionaris:

Els vectors s'implementen amb _persistent bit-partitioned vector tries_, a la classe Java
(`clojure.lang.`)`PersistentVector`.

Els diccionaris (`hash-map`) s'implementen amb una versi√≥ persistent dels _Hash
Array Mapped Trie_, anomenada (`clojure.lang.`)`PersistentHashMap`.

Lamentablement, l'estudi de l'estructura de dades [Trie](https://en.wikipedia.org/wiki/Trie), i les 
seves variants, no √©s quelcom que puguem fer en aquest curs.

---

## Immutabilitat d'Estructures de Dades: Vectors i Diccionaris

Aquestes estructures de dades que s'utilitzen per implementar vectors
i diccionaris tenen una propietat molt interessant: Les operacions m√©s
freq√ºents tenen una complexitat quasi-constant (_effectively constant
time_), fent-les tan eficients, en la pr√†ctica, com les seves
contrapartides no persistents:

_**Effectively constant-time** is a complexity class sometimes used in
computer science to denote algorithms that are not, strictly speaking,
constant-time, but are, for all intents and purposes, constant time._

_For example, accessing the elements of a Clojure vector requires
traversing a tree (actually a trie), the depth of which varies with
the size of the vector. But because the tree has a branching factor of
32, and thus a depth of_ $log\_{32}(n)$ _(where $n$ is the size), for all
practical sizes that fit in memory on modern machines the factor,
though variable, is bounded by a small (approx. 7) constant.red[*]._

Fixem-nos que $32^7 > 10^{10}$, √©s a dir, podem emmagatzemar en un
arbre amb factor de ramificaci√≥ $32$ i profunditat $7$ m√©s d'un billi√≥
(americ√†) d'elements.

.footnote[.red[*] [Font](https://cuddly-octo-palm-tree.com/posts/2022-02-13-opt-clj-5/)]

---

## Immutabilitat d'Estructures de Dades: Vectors i Diccionaris

Els Tries s√≥n essencialment arbres. Com que no podem estudiar en
profunditat les estructures de dades reals que es fan servir a Clojure
per implementar vectors i diccionaris, i entendre aix√≠ el mecanisme
per fer-les persistents de manera eficient, el que farem √©s centrar la
discussi√≥ en arbres, estructura de dades amb la que tots estem
familiaritzats. Simplifiquem per poder entendre.



---

## Immutabilitat d'Estructures de Dades


Aquest tema ha estat basat essencialment en:

* _The Joy of Clojure_, secci√≥ 5.1, p. 85 i seccions 6.1, p. 117, i 6.2, p.120.

Per√≤ si voleu anar m√©s enll√† (_bastant_ m√©s enll√†!), podeu consultar:

* [_Understanding Clojure's PersistentVector implementation_](https://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation.html) i 
  [_Understanding Clojure's PersistentHashMap_](https://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice).
  (Entrades del blog _Higher Order_, Karl Krukow, febrer i setembre 2009).

*  [_Ideal Hash Trees_](https://lampwww.epfl.ch/papers/idealhashtrees.pdf), Phil Bagwell, LAML - Programming Methods Laboratory (EPFL) technical report, 2001.

I sobre tot...

.cols5050[
.col1[
.right[![:scale 30%](figures/okasaki.png)]
]
.col2[
[Purely Functional Data Structures](https://www.cambridge.org/in/universitypress/subjects/computer-science/programming-languages-and-applied-logic/purely-functional-data-structures?format=PB&isbn=9780521663502),
Chris Okasaki, Cambridge University Press 1999.
]]

