class: center, up

# CAP - Funcions _First Class_

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 3 i 4</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# SessiÃ³ 03

---

## Funcions _First Class_

<br>

_In computer science, a programming language is said to have
**first-class functions** if it treats functions as first-class citizens.
This means **the language supports passing functions as arguments to
other functions, returning them as the values from other functions,
and assigning them to variables or storing them in data structures**.
Some programming language theorists require **support for anonymous
functions (function literals) as well**_. 

_In languages with first-class functions, the names of functions do not
have any special status; they are treated like ordinary variables with
a function type. The term was coined by Christopher Strachey in the
context of "functions as first-class citizens" in the mid-1960s._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/First-class_function)]

---

## Funcions _First Class_

<br>

_In computer programming, a **pure function** is a function that has the following properties:_

* _the function **return values are identical for identical arguments** (no variation with local static variables, non-local variables, mutable reference arguments or input streams, i.e., referential transparency),_

* _the function has **no side effects** (no mutation of local static variables, non-local variables, mutable reference arguments or input/output streams)._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Pure_function)]

<br>

**NOTA**: Quan parlem de composiciÃ³ de funcions, en general, sempre
estarem suposant que la composiciÃ³ _tÃ© sentit_, i <ins>no ho farem
explÃ­cit</ins>. Ã‰s a dir, si en algun moment parlem de `(comp f g)` (o, en
altre notaciÃ³, `fÂ·g`) estarem suposant que **el rang de `g` estÃ  inclÃ²s
en el domini d'`f`**. Com Clojure no Ã©s un llenguatge _tipat_, hem
d'expressar aquest requeriment textualment, en lloc de formar part de
les definicions formals de `f` i `g`.

---

## Funcions _First Class_

Ja hem vist "_dissimuladament_" alguns exemples:

* L'expressiÃ³ `(if (> x 0) + -)` retorna el valor-funciÃ³ lligat al sÃ­mbol `+` o al sÃ­mbol `-`, depÃ©n del valor d'`x`.

* La funciÃ³ `apply` requeria una funciÃ³ com a parÃ metre

* Igual que fem `(def s 345)` podem fer `(def quadrat (fn [x] (* x x)))`, Ã©s a dir, podem lligar funcions 
a noms per fer-les servir desprÃ©s: `(quadrat 7) ğŸ‘‰ 49`

El fet de tractar les funcions com a valors qualsevol, que poden passar-se com a argument a una funcio,
que poden retornar-se com a funcions i que poden vincular-se a un nom Ã©s _fonamental_ en les tÃ¨cniques associades
a la programaciÃ³ funcional.

Avui dia hi ha molt pocs llenguatges de programaciÃ³ que no donin suport a les funcions com a _first class citizens_.
Les darreres versions de Java i de C++ han mirat d'afegir funcions de primera clase,
sense resoldre-ho satisfactÃ²riament en comparaciÃ³ amb Clojure, Common Lisp, Smalltalk, Javascript, Python, etc.red[*]

.footnote[.red[*] OpiniÃ³ parcialment subjectiva, que quedi clar]

---

## _Higher Order Functions_

La _Clojure sequence library_ estÃ  composada, sobre tot, de funcions que requereixen funcions com a parÃ metre, Ã©s
a dir, de **_funcions d'ordre superior_** (_Higher Order Functions_)

AixÃ­ doncs, una petita mostra de les funcions d'aquesta _library_ poden ser (algunes les veurem amb una mica de detall):

.cols5050[
.col1[
* `map`

* `filter`

* `remove`

* `drop-while`

* `take-while`

* `every?`

* `some?`

]
.col2[
* `repeatedly`

* `reduce`

* `iterate`

* `apply`

* `partial`

* `comp`

* `sort-by`
]]

**Exercici**: Hi ha mÃ©s funcions a la _Seq library_. Feu-ne una ullada 
[aquÃ­](https://clojure.org/reference/sequences#_the_seq_library).

---

## Funcions d'ordre superior habituals

### `map`

Aplica una funciÃ³ a tots els elements d'una seqÃ¼Ã¨ncia.

**Exemples**:

```clojure
(map inc '(1 2 3))  ğŸ‘‰  (2 3 4)
```

```clojure
(map + '(1 2 3) '(4 5 6 7))  ğŸ‘‰  (5 7 9)
```

### `filter`

ObtÃ© els elements d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(filter even? '(2 1 4 6 7))  ğŸ‘‰  (2 4 6)
```

---

## Funcions d'ordre superior habituals

### `drop-while`

Elimina els primers elements consecutius d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(drop-while even? '(2 4 6 7 8))  ğŸ‘‰  (7 8)
```

### `take-while`

ObtÃ© els primers elements consecutius d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(take-while even? '(2 4 6 7 8))  ğŸ‘‰  (2 4 6)
```
---

## Funcions d'ordre superior habituals

### `reduce`

Desplega un operador `âŠ•` a una seqÃ¼Ã¨ncia $(x_1 x_2 ... x_n)$ donant el resultat $((x1 âŠ• x2) âŠ• ...) âŠ• xn$.

**Exemples**:

```clojure
(reduce + '(2 4 6))  ğŸ‘‰  12
```

```clojure
(reduce * 1 '(2 3 4))  ğŸ‘‰  24
```

### `iterate`

`(iterate f x)` retorna la seqÃ¼Ã¨ncia "_infinita_" `'(x (f x) (f (f x))...)`.

**Exemple**:

```clojure
(take 5 (iterate inc 1))  ğŸ‘‰  (1 2 3 4 5)

```

---

## Funcions d'ordre superior habituals

### `apply`

Aplica una funciÃ³ a una seqÃ¼Ã¨ncia.

**Exemple**:

```clojure
(apply + 1 '(2 3))  ğŸ‘‰  6`           ; equivalent a (+ 1 2 3)
```

### `partial` 

Torna una funciÃ³ derivada de fixar parÃ metres d'una altra funciÃ³ que rep com a parÃ metre. EstÃ  relacionada amb la *currificaciÃ³*.

**Exemple**:

```clojure
((partial + 2) 4)  ğŸ‘‰  6`
```

```clojure
(def f (partial #(str %1 %2 "!") "Hola ")) 
(f "Gerard")  ğŸ‘‰  "Hola Gerard!"
```

---

## Funcions d'ordre superior habituals

### `comp` 

ComposiciÃ³ de funcions.

**Exemple**:

```clojure
((comp reverse sort) '(3 1 5))  ğŸ‘‰  (5 3 1)
```

```clojure
(def tres-mes-grans (comp (partial take 3) reverse sort))  ;; point-free style

(tres-mes-grans '(3 1 2 6 7))  ğŸ‘‰  (7 6 3)
```

.small[Sobre el _point-free style_, o _Tacit Programming_, podeu mirar la [Wikipedia](https://en.wikipedia.org/wiki/Tacit_programming)]

### `every?`

Mira si un predicat es satisfÃ  per tots els elements d'una seqÃ¼Ã¨ncia.

**Exemple**:

```clojure
(every? even? '(2 4 6))  ğŸ‘‰  true
```

---

## Funcions d'ordre superior

L'Ãºs d'aquestes funcions d'ordre superior permet fer programes mÃ©s petits, ja que
augmenten considerablement l'expressivitat del llenguatge.

Compareu:

```Clojure
(defn prime? [n]    ;; sense funcions d'ordre superior
  (letfn [(find-divisor [i n]
            (cond
              (> i (/ n 2))   false
              (= (mod n i) 0) true
              :else           (recur (inc i) n)))]
    (if (< n 2) false
      (not (find-divisor 2 n)))))
```

amb

```Clojure
(defn prime? [n]    ;; amb funcions d'ordre superior
  (cond 
    (< n 2) false 
    :else (not-any? zero? (map #(rem n %) (range 2 (inc (/ n 2)))))))
```

---

## Funcions d'ordre superior

Veiem-ne un exemple una mica mÃ©s gran: Volem una funciÃ³ que, donat un element i una colÂ·lecciÃ³, retorni
un _Ã­ndex_ que caracteritzi la posiciÃ³ de l'element (`nil` si no hi Ã©s).
(_The Joy of Clojure_ p. 111).

AlgÃº que sap el Clojure que nosaltres sabem (de moment poquet ğŸ˜„) pot proposar:

```Clojure
(defn pos [e coll]
    (let [cmp (if (map? coll)
                 #(= (second %1) %2)
                 #(= %1 %2))]
       (loop [s coll, idx 0]
           (when (seq s)             ;; (seq nil) ğŸ‘‰ nil
               (if (cmp (first s) e)
                   (if (map? coll)
                       (first (first s))
                       idx)
                   (recur (next s) (inc idx)))))))

(pos 3 [:a 1 :b 2 :c 3 :d 4])    ğŸ‘‰ 5
(pos :foo [:a 1 :b 2 :c 3 :d 4]) ğŸ‘‰ nil
(pos 3 {:a 1 :b 2 :c 3 :d 4})    ğŸ‘‰ :c
(pos \3 ":a 1 :b 2 :c 3 :d 4")   ğŸ‘‰ 13
```
---

## Funcions d'ordre superior

Aquesta funciÃ³ no Ã©s gens "_clojurian_". No Ã©s _idiomÃ tica_. Ã‰s essencialment una funciÃ³ que no tÃ©
gens en compte la possibilitat de fer servir funcions d'ordre superior (excepte
a la definiciÃ³ de `cmp`).

Generalitzem el problema mirant de transformar una colÂ·lecciÃ³ en una seqÃ¼Ã¨ncia
de parelles (vectors) `[Ã­ndex element]`:

```Clojure
(defn index [coll]
    (cond
        (map? coll) (seq coll)
        (set? coll) (map vector coll coll)
        :else (map vector (iterate inc 0) coll)))
        
(index [:a 1 :b 2 :c 3 :d 4])  ğŸ‘‰ ([0 :a] [1 1] [2 :b] [3 2] [4 :c] [5 3] [6 :d] [7 4])
(index {:a 1 :b 2 :c 3 :d 4})  ğŸ‘‰ ([:a 1] [:b 2] [:c 3] [:d 4])
(index ":a 1 :b 2 :c 3 :d 4")  ğŸ‘‰ ([0 \:] [1 \a] [2 \space] [3 \1] [4 \space] [5 \:] [6 \b] [7 \space] [8 \2] [9 \space] [10 \:] [11 \c] [12 \space] [13 \3] [14 \space] [15 \:] [16 \d] [17 \space] [18 \4])
(index #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ ([1 1] [4 4] [:c :c] [3 3] [2 2] [:b :b] [:d :d] [:a :a])
```

.tiny[Aplicar `index` a un vector, una llista o una _string_ com a argument
retorna una seqÃ¼Ã¨ncia de vectors de dos elements on el primer Ã©s
l'Ã­ndex i el segon l'element. Si apliquem `index` a un diccionari
senzillament aparellarÃ  claus i valors, i aplicar la funciÃ³ a un
conjunt (on el concepte d'Ã­ndex Ã©s _forÃ§at_, ja que no tÃ© gaire sentit
en dependre d'un ordre arbitrari) retornarÃ  una seqÃ¼Ã¨ncia amb els
elements aparellats amb ells mateixos.]

---

## Funcions d'ordre superior

Amb la funciÃ³ `index` Ã©s fÃ cil fer una versiÃ³ de `pos` mÃ©s senzilla:

```Clojure
(defn pos' [e coll]
    (let [element (first (drop-while #(not= (second %) e) (index coll)))]
        (first element)))
        
(pos' 3 [:a 1 :b 2 :c 3 :d 4])    ğŸ‘‰ 5
(pos' :foo [:a 1 :b 2 :c 3 :d 4]) ğŸ‘‰ nil
(pos' 3 {:a 1 :b 2 :c 3 :d 4})    ğŸ‘‰ :c
(pos' \3 ":a 1 :b 2 :c 3 :d 4")   ğŸ‘‰ 13

;; perÃ²

(pos  :d #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ 6
(pos' :d #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ :d
```

`pos'` Ã©s molt semblant a `pos`, excepte si la colÂ·lecciÃ³ Ã©s un conjunt. En aquest
cas, la decisiÃ³ que hem pres a la funciÃ³ `index` fa que el retorn sigui diferent:
`pos` retornarÃ  un Ã­ndex numÃ¨ric, reflectint l'ordre (arbitrari) que Clojure ha
donat als elements, i `pos'` retorna l'element en qÃ¼estiÃ³, si hi Ã©s.

Un dels avantatges de la possibilitat de fer servir funcions d'ordre
superior Ã©s que ens permet major expressivitat i per tant escriure codi 
mÃ©s compacte.

---

## Funcions d'ordre superior

Comparem

```Clojure
(defn pos [e coll]
    (let [cmp (if (map? coll)
                 #(= (second %1) %2)
                 #(= %1 %2))]
       (loop [s coll, idx 0]
           (when (seq s)             ;; (seq nil) ğŸ‘‰ nil
               (if (cmp (first s) e)
                   (if (map? coll)
                       (first (first s))
                       idx)
                   (recur (next s) (inc idx)))))))
```
amb
```Clojure
(defn pos' [e coll]
    (letfn [(index [coll]
              (cond
                  (map? coll) (seq coll)
                  (set? coll) (map vector coll coll)
                  :else (map vector (iterate inc 0) coll)))]
       (let [element (first (drop-while #(not= (second %) e) (index coll)))]
           (first element))))
```

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

Hem dit abans que `(reduce âŠ• x0 '(x1 x2 ... xn))` desplega un operador `âŠ•` a 
una seqÃ¼Ã¨ncia donant com a resultat `(âŠ• (...(âŠ• (âŠ• x0 x1) x2)...) xn)`.

Veiem-ne exemples:

```Clojure
(reduce + 0 [1 2 3 4 5]) ğŸ‘‰ 15

(reduce conj #{} [:a :b :c]) ğŸ‘‰ #{:a :c :b}

```

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

Hem dit abans que `(reduce âŠ• x0 '(x1 x2 ... xn))` desplega un operador `âŠ•` a 
una seqÃ¼Ã¨ncia donant com a resultat `(âŠ• (...(âŠ• (âŠ• x0 x1) x2)...) xn)`.

Veiem-ne exemples:

```Clojure
(reduce + 0 [1 2 3 4 5]) ğŸ‘‰ 15

(reduce conj #{} [:a :b :c]) ğŸ‘‰ #{:a :c :b}

(reduce       ;; nombres primers fins a 100 
  (fn [primes number]
    (if (some zero? (map (partial mod number) primes))
      primes
      (conj primes number)))
  [2]
  (take 98 (iterate inc 3))) 
ğŸ‘‰ [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]

(reduce       ;; primers 20 nombres de Fibonacci
  (fn [a b] (conj a (+' (last a) (last (butlast a)))))
  [0 1]                      
  (repeat 18 1))
ğŸ‘‰ [0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181]
```

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

El que fa `reductions` Ã©s retornar tots els resultats intermedis de la invocaciÃ³ corresponent
de `reduce`. Ã‰s a dir, si `(reduce âŠ• x0 '(x1 x2 ... xn))` Ã©s `(âŠ• (...(âŠ• (âŠ• x0 x1) x2)...) xn)`,
aleshores:

```Clojure
(reductions âŠ• x0 '(x1 x2 ... xn)) ğŸ‘‰ (x0 (âŠ• x0 x1) (âŠ• (âŠ• x0 x1) x2) ...)
```

Per exemple:

```Clojure
(reductions + 0 [1 2 3 4 5]) ğŸ‘‰ (0 1 3 6 10 15)

(reductions conj #{} [:a :b :c]) ğŸ‘‰ (#{} #{:a} #{:b :a} #{:c :b :a})

(reductions     ;; primers fins a 7 (inclÃ²s)
  (fn [primes number]
    (if (some zero? (map (partial mod number) primes))
      primes
      (conj primes number)))
  [2]
  (take 5 (iterate inc 3)))
ğŸ‘‰ ([2] [2 3] [2 3] [2 3 5] [2 3 5] [2 3 5 7])
```
---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

Veiem alguns exemples mÃ©s:

```Clojure
(reduce / 64 [4,2,4]) ğŸ‘‰ 2
(reductions / 64 [4,2,4]) ğŸ‘‰ (64 16 8 2)

(reduce #(+ %2 (* 2 %1)) 4 [1 2 3]) ğŸ‘‰ 43
(reductions #(+ %2 (* 2 %1)) 4 [1 2 3]) ğŸ‘‰ (4 9 20 43)

(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (reduce (flip cons) '() '(1 2 3 4 5 6))) ğŸ‘‰ (6 5 4 3 2 1)
   
(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (reductions (flip cons) '() '(1 2 3 4 5 6)))
ğŸ‘‰(() (1) (2 1) (3 2 1) (4 3 2 1) (5 4 3 2 1) (6 5 4 3 2 1))
```

`reduce` tÃ© equivalents en prÃ cticament tots els llenguatges de programaciÃ³. 
S'anomena `foldl` a Haskell, `reduce` a Common Lisp, `inject:into:` a Smalltalk,
`iterator.fold` a Rust, `functools.reduce` a Python 3.x, `Iterable.fold` a Kotlin,
`array.reduce` a Javascript, `lists:foldl` a Erlang, i un molt llarg etc.red[*].

.footnote[.red[*] Si teniu interÃ©s mireu la [Wikipedia](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29)]

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

`reduce`/`reductions` tenen versions simÃ¨triques que no estan implementades a Clojure,
que podem anomenar `foldr`/`scanr` (igual que en Haskell, on `reduce` Ã©s `foldl` i
`reductions` Ã©s `scanl`).

PodrÃ­em implementar-les:

```Clojure
(defn foldr
  [f val coll]
  (if (empty? coll) val
      (f (first coll) (foldr f val (rest coll)))))

(defn scanr
  [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (reductions (flip f) e rlst)))))
```

on de la definiciÃ³ podem veure que `(foldr âŠ• x0 '(x1 x2 ... xn))` desplega 
l'operador `âŠ•` a una seqÃ¼Ã¨ncia calculant `(âŠ• x1 (âŠ• x2 (...(âŠ• xn x0)...)))`.
`scanr` retorna tots els resultats intermedis de la invocaciÃ³ corresponent
de `foldr`.

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

GrÃ ficament:

`(def y (reduce f x0 '(x1 x2 x3 x4)))`

.center[![:scale 50%](figures/foldl.png)]

`(def y (foldr f x0 '(x1 x2 x3 x4)))`

.center[![:scale 50%](figures/foldr.png)]

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

Per acabar l'incÃ­s, un exemple senzill ens ajudarÃ  a entendre millor les diferÃ¨ncies entre
aquestes funcions:

```Clojure
(reduce - 0 '(1 2 3 4 5)) ğŸ‘‰ -15 
;; (- (- (- (- (- 0 1) 2) 3) 4) 5)

(reductions - 0 '(1 2 3 4 5)) ğŸ‘‰ (0 -1 -3 -6 -10 -15)
;; 0 â‡’ 0, (- 0 1) â‡’ -1, (- (- 0 1) 2) â‡’ -3, (- (- (- 0 1) 2) 3) â‡’ -6, 
;; (- (- (- (- 0 1) 2) 3) 4) â‡’ -10, (- (- (- (- (- 0 1) 2) 3) 4) 5) â‡’ -15

(foldr - 0 '(1 2 3 4 5)) ğŸ‘‰ 3
;; (- 1 (- 2 (- 3 (- 4 (- 5 0)))))

(scanr - 0 '(1 2 3 4 5)) ğŸ‘‰ (3 -2 4 -1 5 0)
;; (- 1 (- 2 (- 3 (- 4 (- 5 0))))) â‡’ 3, (- 2 (- 3 (- 4 (- 5 0)))) â‡’ -2,
;; (- 3 (- 4 (- 5 0))) â‡’ 4, (- 4 (- 5 0)) â‡’ -1, (- 5 0) â‡’ 5, 0 â‡’ 0
```

---

## Funcions d'ordre superior

Un altre exemple: Recordem l'[algorisme de
Kadane](https://en.wikipedia.org/wiki/Maximum_subarray_problem) per
resoldre el **_Maximum Segment Sum Problem_**: Sigui V un vector de nombres 
i considerem totes els seus subvectors possibles (fins i tot el buit). Volem trobar
quant suma el subvector amb suma mÃ xima. 

Per exemple, si V = [31, -41,
59, 26, -53, 58, 97, -93, -23, 84] el resultat Ã©s 187, que correspÃ³n al 
subvector [59, 26, -53, 58, 97] (la suma del vector buit Ã©s zero).

L'algorisme de Kadane Ã©s un algorisme $\mathcal{O}(n)$ (lineal en la mida del vector) que
resol el problema de manera Ã²ptima.

Una implementaciÃ³ en Clojure que NO fa servir funcions d'ordre superior:
```Clojure
(defn kadane
  "v Ã©s un vector de nombres"
  [v]
  (let [mida (count v)]
    (loop [i 0, resultat 0, actual 0, per-tractar v]
      (if (= mida i)
        resultat
        (let [elem-i   (first per-tractar)
              m        (max (+ actual elem-i) 0)] 
          (recur (inc i) (max resultat m) m (rest per-tractar)))))))
```
---

## Funcions d'ordre superior

Podem fer un algorisme _millor_ (mÃ©s clar, mÃ©s curt) fent servir funcions d'ordre superior? Al tanto, 
que volem un algorisme que tambÃ© sigui lineal $\mathcal{O}(n)$.

```Clojure
(def max0 #(max 0 (+ %1 %2)))

(defn scanr   ;; ja l'hem vist, Ã©s la mateixa funciÃ³
  [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (reductions (flip f) e rlst)))))

(def kadane #(apply max (scanr max0 0 %)))
```

En aquest exemple el paper clau el juga `reductions`, que ens ajuda a definir `scanr`. 

Es pot demostrar que aquest algorisme tambÃ© Ã©s lineal $\mathcal{O}(n)$.

---

## Funcions d'ordre superior

Comparem

```Clojure
(defn kadane
  "v Ã©s un vector de nombres"
  [v]
  (let [mida (count v)]
    (loop [i 0, resultat 0, actual 0, per-tractar v]
      (if (= mida i)
        resultat
        (let [elem-i   (first per-tractar)
              m        (max (+ actual elem-i) 0)] 
          (recur (inc i) (max resultat m) m (rest per-tractar)))))))
```

amb 

```Clojure
(defn kadane
  "coll Ã©s un vector de nombres"
  [coll]
  (letfn [(max0 [x y] (max 0 (+ x y)))
          (scanr [f e lst] (letfn [(flip [ff] (fn [x y] (ff y x)))]
                             (let [rlst   (reverse lst)]
                               (reverse (reductions (flip f) e rlst)))))]
    (apply max (scanr max0 0 coll))))
```
---

## Funcions d'ordre superior

Veiem un exemple mÃ©s: [OrdenaciÃ³ per inserciÃ³](https://en.wikipedia.org/wiki/Insertion_sort) (_Insertion Sort_)

Recordem el pseudo-codi de l'algorisme.red[*]:

```C
i â† 1
while i < length(A)
    j â† i
    while j > 0 and A[j-1] > A[j]
        swap A[j] and A[j-1]
        j â† j - 1
    end while
    i â† i + 1
end while
```

Ã‰s un algorisme que depÃ©n molt de la _mutabilitat_ de la colÂ·lecciÃ³
`A`. A Clojure no Ã©s trivial traduir aquest pseudo-codi _literalment_.

Per exemple, donada la colÂ·lecciÃ³ `A`, fer `swap A[j] and A[j-1]` podria fer-se (suposem que `A`
Ã©s un vector): `(assoc (assoc A j (A (dec j))) (dec j) (A j))`,
perÃ² no Ã©s trivial veure si avaluar aquesta expressiÃ³ tÃ© el mateix cost que `swap A[j] and A[j-1]`, que 
Ã©s constant $\mathcal{O}(1)$.


.footnote[.red[*] [Font](https://en.wikipedia.org/wiki/Insertion_sort)]

---

## Funcions d'ordre superior

[OrdenaciÃ³ per inserciÃ³](https://en.wikipedia.org/wiki/Insertion_sort) (_Insertion Sort_)

En canvi, des d'un punt de vista _funcional_ l'ordenaciÃ³ per inserciÃ³ no Ã©s complicada:

```Clojure
(defn ordenacio-insercio 
  "Retorna una seqÃ¼Ã¨ncia amb els elements de la seqÃ¼Ã¨ncia xs ordenats"
  [xs]
  (letfn [(inserir [col x]
            "suposant que col estÃ  ordenada, insereix x tot mantenint l'ordre" 
            (concat (take-while #(<= % x) col) [x] (drop-while #(<= % x) col)))]
    (reduce inserir '() xs)))
    
(let [s  (shuffle (range 20))]
   (println s)
   (ordenacio-insercio s))
ğŸ‘ï¸ [14 9 16 5 17 1 15 8 10 0 12 3 19 7 4 11 18 6 2 13]
ğŸ‘‰ (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)

```

PerÃ² hem d'adaptar l'algorisme al punt de vista _funcional_. L'algorisme tal com estÃ  descrit
en pseudo-codi a la plana anterior no Ã©s gaire Ãºtil, mÃ©s que per entendre la idea _general_.

---

## Llistes per ComprensiÃ³ (_List Comprehension_)

### La macro `for`

En Clojure la macro `for` ens permet processar i generar seqÃ¼Ã¨ncies de manera alternativa a 
les funcions de la _Clojure Sequence Library_.
No Ã©s un `for` com els que coneixem d'altres llenguatges de programaciÃ³ 
(tot i que pot fer-se servir de manera similar en alguns casos).
Les llistes (seqÃ¼Ã¨ncies, en realitat) generades fent servir `for` 
s'anomenen **_llistes per comprensiÃ³_**.

En lloc d'intentar fer una descripciÃ³ general, veiem alguns exemples:

```Clojure
(for [i [1 2 3 4 5]] (* 2 i)) ğŸ‘‰ (2 4 6 8 10)

(for [i (range 4) j (range 3)] [i j])
ğŸ‘‰ ([0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2] [3 0] [3 1] [3 2])

;; Podem afegir els modificadors :when :while :let

(for [x (range 1 6) :let [y (* x x), z (* x x x)]] [x y z])
ğŸ‘‰ ([1 1 1] [2 4 8] [3 9 27] [4 16 64] [5 25 125])

(for [x (range 3) y (range 3) :when (not= x y)] [x y])
ğŸ‘‰ ([0 1] [0 2] [1 0] [1 2] [2 0] [2 1])

(for [x (range 3) y (range 3) :while (not= x y)] [x y])  ;; !!!
ğŸ‘‰ ([1 0] [2 0] [2 1])
```
---

## Llistes per ComprensiÃ³ (_List Comprehension_)

### La macro `for`

La diferÃ¨ncia entre fer servir `:when` i `:while` Ã©s subtil:

```Clojure
;; Suposem que tenim una funciÃ³ prime? ja definida

(for [x (range 3 33 2) :when (prime? x)] x)  ğŸ‘‰ (3 5 7 11 13 17 19 23 29 31)

(for [x (range 3 33 2) :while (prime? x)] x) ğŸ‘‰ (3 5 7)


(for [x (range 3 13 2) :when (prime? x), y (range 3 13 2) :when (prime? y)] 
     [x y])
ğŸ‘‰ ([3 3] [3 5] [3 7] [3 11] [5 3] [5 5] [5 7] [5 11] [7 3] 
    [7 5] [7 7] [7 11] [11 3] [11 5] [11 7] [11 11]) 

(for [x (range 3 13 2) :while (prime? x), y (range 3 13 2) :while (prime? y)] 
     [x y])
ğŸ‘‰ ([3 3] [3 5] [3 7] [5 3] [5 5] [5 7] [7 3] [7 5] [7 7])

```

Ã‰s fÃ cil veure que fent servir `for` podem aconseguir el mateix que aconseguim amb algunes
funcions de la _Clojure Sequence Library_. De fet, precisament aixÃ² forma
part dels [exercicis](https://gebakx.github.io/cap/problemes/llistes-comprensio.pdf) 
que corresponen a les sessions de laboratori d'aquest tema.

.small[[Font](https://clojuredocs.org/clojure.core/for)]

---

class: center, middle

# SessiÃ³ 04

---

## Funcions d'ordre superior

### `fold`

Ja hem fet servir les funcions `reduce`/`reductions`. Aquestes funcions sÃ³n fonamentals
en programaciÃ³ funcional.red[*]. Recordem les definicions de `foldl`/`reduce`, `foldr`, `scanl`/`reductions` i 
`scanr`, i definim `fold`:

```Clojure
;; foldl / foldr / fold
(def foldl reduce)

(defn foldr
  [f val coll]
  (if (empty? coll) val
      (f (first coll) (foldr f val (rest coll)))))

(def fold foldr)

;; scanl / scanr
(def scanl reductions)

(defn scanr
  [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (reductions (flip f) e rlst)))))
```

.footnote[.red[*] 
[_A tutorial on the universality and expressiveness of fold_](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/tutorial-on-the-universality-and-expressiveness-of-fold/CDBAA53C7120E23CBBBE206FD47FDBAA)
]

---

## Funcions d'ordre superior

### `fold`: Processar SeqÃ¼Ã¨ncies

En aquesta sessiÃ³ ens centrarem sobre tot en la idea de <ins>_processar seqÃ¼Ã¨ncies_</ins>. 
Molts problemes prÃ ctics es poden pensar en aquests termes,
adequadament combinats amb funcions d'ordre superior.

Ja hem vist exemples de la versatilitat de `reduce`/`foldl`. En aquesta sessiÃ³ ens concentrarem en
`fold` (`foldr` en realitat.red[*]).

```Clojure
;; Definim funcions conegudes que *nomÃ©s* accepten dos arguments:
(def suma #(+ %1 %2))
(def prod #(* %1 %2))
(def and2 #(and %1 %2))
(def or2  #(or %1 %2))

;; Podem definir les funcions de Clojure a partir d'aquestes fent Ãºs de fold:
(def suma_generalitzada    (partial fold suma 0))
(def producte_generalitzat (partial fold prod 1))
(def and_generalitzat      (partial fold and2 true))
(def or_generalitzat       (partial fold or2 false))

(suma_generalitzada (range 10)) ğŸ‘‰ 45
(producte_generalitzat (map inc (range 10))) ğŸ‘‰ 3628800 ;; 10!
```

.footnote[.red[*] 
No confondre amb `clojure.core.reducers/fold`, que Ã©s _una mena de_
`reduce` paralÂ·lelitzable
]

---

## Funcions d'ordre superior

### `fold`: Processar SeqÃ¼Ã¨ncies

PerÃ² aixÃ² nomÃ©s Ã©s una mostra molt trivial de les capacitats de `fold`.
Mirem de fer funcions una mica mÃ©s complicades:

```Clojure
(def mida (partial fold #(inc %2)  0))
(mida '()) ğŸ‘‰ 0
(mida [])  ğŸ‘‰ 0
(mida (range 10))       ğŸ‘‰ 10
(mida (vec (range 10))) ğŸ‘‰ 10

(def invertir (partial fold #(concat %2 [%1]) '()))
(invertir '()) ğŸ‘‰ ()
(invertir []) ğŸ‘‰ ()
(invertir (range 10)) ğŸ‘‰ (9 8 7 6 5 4 3 2 1 0)
(invertir (vec (range 10))) ğŸ‘‰ (9 8 7 6 5 4 3 2 1 0)
(apply str (invertir "Hola MÃ³n!")) ğŸ‘‰ "!nÃ³M aloH"

(def my-map (fn [f,s] (fold #(cons (f %1) %2) '() s)))
(my-map inc (range 2 15 3)) ğŸ‘‰ (3 6 9 12 15) ;;(range 2 15 3) ğŸ‘‰ (2 5 8 11 14)

(def my-filter (fn [p,s] (fold #(if (p %1) (cons %1 %2) %2) '() s)))
(my-filter even? (range 2 30)) ğŸ‘‰ (2 4 6 8 10 12 14 16 18 20 22 24 26 28)
```

---

## Funcions d'ordre superior

### `fold`: La Propietat Universal

No Ã©s casualitat que `fold` sigui capaÃ§ d'expressar tantes operacions diferents. En realitat, 
la definiciÃ³ de `(foldr âŠ• x0 '(x1 x2 ... xn))` com a `(âŠ• x1 (âŠ• x2 (...(âŠ• xn x0)...)))`
captura un patrÃ³ molt freqÃ¼ent en definicions recursives.

Disposant de funcions d'ordre superior, podem expressar una relaciÃ³
entre `fold` i aquest patrÃ³ de funciÃ³ recursiva:

```Clojure
;; Suposem un valor v i una funciÃ³ pura f, definim la funciÃ³ recursiva g:
(defn g [s]
  (if (empty? s) v
    (f (first s) (g (rest s)))))
```

Es pot demostrar que.red[*]:

```Clojure
g = (partial fold f v)              ;; g = fold f v
```
Aquesta relaciÃ³ s'anomena **_la propietat universal de fold_**.


.footnote[.red[*] NomÃ©s per a llistes de mida finita. Aquesta afirmaciÃ³ tindrÃ  mÃ©s sentit
a final de curs. Els detalls i demostracions els podeu trobar 
a l'[article](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/tutorial-on-the-universality-and-expressiveness-of-fold/CDBAA53C7120E23CBBBE206FD47FDBAA)
que hem citat abans. A mÃ©s, `f` ha de ser _pura_.]

---

## Funcions d'ordre superior

### `fold`: La Propietat Universal

Veiem un exemple d'aplicaciÃ³ d'aquesta propietat:

```Clojure
;; DefiniciÃ³ de map, suposant que no tinguÃ©ssim map a Clojure (!)
(defn map [ff s]
  (if (empty? s) 
    '()
    (cons (ff (first s)) (map ff (rest s)))))
```
Volem aplicar la propietat universal, caldria trobar quina Ã©s la `g` en aquest cas.
Considerant que `g` tÃ© com a argument una seqÃ¼Ã¨ncia `s`, nomÃ©s podem equiparar
`g` a `(partial map ff)`. En aquest cas, la nostra definiciÃ³ recursiva de `(partial map ff)` sÃ­ 
que tÃ© l'estructura que requerim de la `g` de la definiciÃ³ de la plana anterior (suposant, perÃ², que
`ff` Ã©s pura).

Aleshores, trobar la resta d'elements Ã©s senzill: El valor `v` seria
`'()`, i la funciÃ³ `f` seria `#(cons (ff %1) %2)`.

Per tant, segons la propietat universal, podem afirmar que, si `f` Ã©s pura:

```Clojure
(partial map f) = (partial fold #(cons (f %1) %2) '()) ;; map f = fold consÂ·f ()
```
---

## Funcions d'ordre superior

### `fold`: La Propietat de FusiÃ³ (_The fusion property of fold_)

Hi ha altres propietats que ens poden ser Ãºtils a l'hora de pensar programes
funcionals. La **_Propietat de FusiÃ³_** diu:

Siguin `h`, `g`, i `f` funcions pures i `w` i `v` valors donats. Si es verifica que:

```Clojure
(h w)       = v                       ;;       h w = v
(h (g x y)) = (f x (h y))             ;; h (g x y) = f x (h y)
```
Aleshores tenim que:

```Clojure
(comp h (partial fold g w)) = (partial fold f v)     ;; h Â· fold g w = fold f v
```

Veiem una aplicaciÃ³ de la propietat de fusiÃ³ argumentant que, 
donades dues funcions pures `ff` i `gg`:

```Clojure
;; Escrivim en Clojure que: map ff Â· map gg = map (ffÂ·gg)
(comp (partial map ff) (partial map gg)) = (partial map (comp ff gg))
```

**Exercici**: Per quÃ¨ Ã©s interessant aquesta propietat? QuÃ¨ en traiem nosaltres
de saber que `map f Â· map g = map (fÂ·g)`, per a `f` i `g` pures?

---

## Funcions d'ordre superior

### `fold`: La Propietat de FusiÃ³ (_The fusion property of fold_)

Continuant amb l'exemple de la plana anterior, caldria identificar els
diferents elements de la definiciÃ³ de la propietat general de fusiÃ³. 
Per fer aixÃ² substituirem a la propietat de fusiÃ³ dos dels `map` per 
la seva expressiÃ³ en termes de `fold`

```Clojure
(comp (partial map ff) (partial map gg)) = (partial map (comp ff gg))
â‰¡
(comp (partial map ff) (partial fold #(cons (gg %1) %2) '())) = 
                                 (partial fold #(cons ((comp ff gg) %1) %2) '())
```

AquÃ­ Ã©s, perÃ², on volem arribar. Aquesta expressiÃ³ sÃ­ que ens permetrÃ 
identificar tots els elements que apareixen a la formulaciÃ³ general de
la propietat:

```Clojure
w â‡’ '()                    v â‡’ '()                    h â‡’ (partial map ff)

g â‡’ #(cons (gg %1) %2)     f â‡’ #(cons ((comp ff gg) %1) %2)
```

Si amb aquestes substitucions es verifica la premisa de la propietat de fusiÃ³, aleshores
podrem dir que la igualtat anterior Ã©s certa grÃ cies a aquesta propietat.

---

## Funcions d'ordre superior

### `fold`: La Propietat de FusiÃ³ (_The fusion property of fold_)

Per a deduir aquesta igualtat amb la propietat de fusiÃ³, caldria que es verifiquÃ©s
(ara que podem identificar els diferents elements de la premisa):

```Clojure
;; a/ (h w) = v

;;      h          w     v
;;--------------  ---   ---
((partial map ff) '()) = ()

;; b/ (h (g x y)) = (f x (h y))

;;      h                  g
;;--------------   -----------------
((partial map ff) (#(cons (gg %1) %2) x y)) =
                            (#(cons ((comp ff gg) %1) %2) x ((partial map ff) y))
;;                           ---------------------------     ----------------
;;                                       f                           h

```
L'apartat **a/** Ã©s trivial, ja que `(map f '())` Ã©s sempre la seqÃ¼Ã¨ncia buida `()`.

L'apartat **b/**: En aquest cas desplegarem les funcions per a valors genÃ¨rics
d'`x` i d'`y`, i argumentarem que la igualtat es verifica. Ho farem a la pissarra.

---

## Funcions d'ordre superior

### `fold`: _The Scan Lemma_

Podem definir `scanl` i `scanr` en termes de `foldl` i `foldr`? Doncs sÃ­!

Definim dues funcions auxiliars `inits` i `tails`:

```Clojure
;; TÃ©nen sentit amb llistes, strings i vectors, no massa amb maps o conjunts

(defn inits
  [coll]
  (if (not (seq coll)) (seq (list '()))   ;; retorna la seqÃ¼Ã¨ncia (())
    (let [[x & xs] coll]          ;; <=== Heu estudiat el destructuring?
      (concat '(()) (map (partial cons x) (inits xs))))))

(defn tails
  [coll]
  (if (not (seq coll)) (seq (list '()))  ;; retorna la seqÃ¼Ã¨ncia (())
    (let [[_ & xs :as all] coll]  ;; <=== Heu estudiat el destructuring?
      (cons (seq all) (tails xs)))))

(inits '(1 2 3 4 5)) ğŸ‘‰ (() (1) (1 2) (1 2 3) (1 2 3 4) (1 2 3 4 5))
(tails '(1 2 3 4 5)) ğŸ‘‰ ((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5) ())

(inits [:a :b :c]) ğŸ‘‰ (() (:a) (:a :b) (:a :b :c))
(tails [:a :b :c]) ğŸ‘‰ ((:a :b :c) (:b :c) (:c) ())
 
(inits []) ğŸ‘‰ (())                            (tails []) ğŸ‘‰ (())
```

---

## Funcions d'ordre superior

### `fold`: _The Scan Lemma_

Aquestes funcions generen una seqÃ¼Ã¨ncia amb tots els prefixos (`inits`) o tots els 
sufixos (`tails`) d'una seqÃ¼Ã¨ncia determinada.

Aleshores, nomÃ©s ens cal aplicar `foldl` o `foldr` a cada una de les subseqÃ¼Ã¨ncies,
i per a aixÃ² tenim `map`:

```Clojure
;; Recordem que scanl requereix tres arguments (scanl f e s)
(def scanl' #((comp (partial map (partial foldl %1 %2)) inits) %3)) 

(scanl  #(+ %2 (* 2 %1)) 4 [1 2 3]) ğŸ‘‰ (4 9 20 43)
(scanl' #(+ %2 (* 2 %1)) 4 [1 2 3]) ğŸ‘‰ (4 9 20 43)

(scanl  conj #{} [:a :b :c]) ğŸ‘‰ (#{} #{:a} #{:b :a} #{:c :b :a})
(scanl' conj #{} [:a :b :c]) ğŸ‘‰ (#{} #{:a} #{:b :a} #{:c :b :a})

(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (scanl  (flip cons) '() '(1 2 3 4 5 6))) 
ğŸ‘‰ (() (1) (2 1) (3 2 1) (4 3 2 1) (5 4 3 2 1) (6 5 4 3 2 1))

(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (scanl' (flip cons) '() '(1 2 3 4 5 6)))
ğŸ‘‰ (() (1) (2 1) (3 2 1) (4 3 2 1) (5 4 3 2 1) (6 5 4 3 2 1))
```
---

## Funcions d'ordre superior

### `fold`: _The Scan Lemma_

Aquestes funcions generen una seqÃ¼Ã¨ncia amb tots els prefixos (`inits`) o tots els 
sufixos (`tails`) d'una seqÃ¼Ã¨ncia determinada.

Aleshores, nomÃ©s ens cal aplicar `foldl` o `foldr` a cada una de les subseqÃ¼Ã¨ncies,
i per a aixÃ² tenim `map`:

```Clojure
;; Recordem que scanr requereix tres arguments (scanr f e s)
(def scanr' #((comp (partial map (partial foldr %1 %2)) tails) %3))

(scanr  - 0 '(1 2 3 4 5)) ğŸ‘‰ (3 -2 4 -1 5 0)
(scanr' - 0 '(1 2 3 4 5)) ğŸ‘‰ (3 -2 4 -1 5 0)

(scanr  / 2 [8,12,24,4]) ğŸ‘‰ (8 1 12 2 2)
(scanr' / 2 [8,12,24,4]) ğŸ‘‰ (8 1 12 2 2)

(scanr  #(/ (+ %1 %2) 2) 54 [12,4,10,6]) ğŸ‘‰ (12 12 20 30 54)
(scanr' #(/ (+ %1 %2) 2) 54 [12,4,10,6]) ğŸ‘‰ (12 12 20 30 54)

```
Encara que hauria de ser obvi, val la pena destacar que, si `f` Ã©s pura:

`(= (last (scanl f z x))  (foldl f z x)) ğŸ‘‰ true`

`(= (first (scanr f z x)) (foldr f z x)) ğŸ‘‰ true`

---

## Funcions d'ordre superior

### Exemples

* Podem tornar al recorregut en profunditat d'un graf que vam veure a la 
[SessiÃ³ 02](https://jdelgadopin.github.io/CAP2024-25/s01_02.html#49). Podem fer-lo mÃ©s _funcional_ aprofitant 
que era iteratiu (podem convertir-lo fÃ cilment a recursiu final i aprofitar la TCO que ens proporciona `recur`)
i que ara coneixem la familia `fold`.

---

## Funcions d'ordre superior

### Exemples

* Podem tornar al recorregut en profunditat d'un graf que vam veure a la 
[SessiÃ³ 02](https://jdelgadopin.github.io/CAP2024-25/s01_02.html#49). Podem fer-lo mÃ©s _funcional_ aprofitant 
que era iteratiu (podem convertir-lo fÃ cilment a recursiu final i aprofitar la TCO que ens proporciona `recur`)
i que ara coneixem la familia `fold`:

La soluciÃ³ proposada seria:

```Clojure
(defn recorregut-profunditat
  "graf Ã©s un graf representat com hem vist a la transparÃ¨ncia anterior"
  "primer Ã©s el node del que es parteix per fer el recorregut"
  [graf primer]
  (letfn [(dfs [p vis]
            (cond
              (empty? p)              vis
              (some #{(peek p)} vis)  (recur (pop p) vis)
              :else                   (let [actual (peek p)]
                                        (recur (reduce conj (pop p) (actual graf))
                                               (conj vis actual)))))]
    (dfs [primer] [])))
```

**Exercici**: Compareu aquesta versiÃ³ amb la versiÃ³ de la [SessiÃ³ 02](https://jdelgadopin.github.io/CAP2024-25/s01_02.html#49).
Veureu que no sÃ³n tan diferents.

---

## Funcions d'ordre superior

### Exemples

* Fer una funciÃ³ `bin2int` que transformi una seqÃ¼Ã¨ncia de bits (nombres del conjunt {0,1}) en un
nombre enter (el bit de mÃ©s pes estÃ  a l'esquerra de la seqÃ¼Ã¨ncia):

```Clojure
(bin2int [1,0,1,1]) ğŸ‘‰ 11

(bin2int [1,0,0,0]) ğŸ‘‰ 8
```

---

## Funcions d'ordre superior

### Exemples

* Fer una funciÃ³ `bin2int` que transformi una seqÃ¼Ã¨ncia de bits (nombres del conjunt {0,1}) en un
nombre enter (el bit de mÃ©s pes estÃ  a l'esquerra de la seqÃ¼Ã¨ncia):

```Clojure
(bin2int [1,0,1,1]) ğŸ‘‰ 11

(bin2int [1,0,0,0]) ğŸ‘‰ 8
```

* SoluciÃ³:

```Clojure
;; Farem servir una expressiÃ³ similar a l'avaluaciÃ³ d'un polinomi amb Horner

(def bin2int (partial reduce #(+ (* 2 %1) %2) 0))
```

El mateix podrÃ­em fer per transformar una seqÃ¼Ã¨ncia de dÃ­gits de {0,1,...,9} en un enter (perÃ²
fent servir `#(+ (* 10 %1) %2)`).



---

## Funcions d'ordre superior

### Exemples

* Donada una seqÃ¼Ã¨ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funciÃ³
que retorni una seqÃ¼Ã¨ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
ğŸ‘‰ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
ğŸ‘‰ ([3 :trump] [5 :harris])

```
---

## Funcions d'ordre superior

### Exemples

* Donada una seqÃ¼Ã¨ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funciÃ³
que retorni una seqÃ¼Ã¨ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
ğŸ‘‰ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
ğŸ‘‰ ([3 :trump] [5 :harris])
```
CaldrÃ  una funciÃ³ per comptar quants cops apareix cada valor:

```Clojure
(def comptar (fn [x s] (count (filter (partial = x) s))))

(comptar "Vermell" ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) ğŸ‘‰ 2

(comptar "Groc" ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"])    ğŸ‘‰ 0
```
---

## Funcions d'ordre superior

### Exemples

* Donada una seqÃ¼Ã¨ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funciÃ³
que retorni una seqÃ¼Ã¨ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
ğŸ‘‰ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
ğŸ‘‰ ([3 :trump] [5 :harris])

```

CaldrÃ  una altra funciÃ³, auxiliar, per eliminar resultats duplicats:

```Clojure
(defn treu-duplicats [s] 
  (if (empty? s) '()
    (let [[cap & cua] s]
      (cons cap (filter (partial not= cap) (treu-duplicats cua))))))
      
(treu-duplicats ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
ğŸ‘‰ ("Vermell" "Blau" "Verd")
```

---

## Funcions d'ordre superior

### Exemples

* Donada una seqÃ¼Ã¨ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funciÃ³
que retorni una seqÃ¼Ã¨ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
ğŸ‘‰ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
ğŸ‘‰ ([3 :trump] [5 :harris])

```

* Amb aquestes funcions ja podem construir la funciÃ³ `resultat`:

```Clojure
(defn resultat [s]
  (sort (for [v (treu-duplicats s)] [(comptar v s) v])))
```

En tenim prou ordenant una llista per comprensiÃ³ que ens doni els resultats desitjats.

---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica mÃ©s gran: Volem una funciÃ³ que, donada una seqÃ¼Ã¨ncia, retorni totes
les **permutacions** possibles d'aquesta seqÃ¼Ã¨ncia.

L'enfocament que farem Ã©s el segÃ¼ent: Suposem que tenim totes les permutacions possibles de la
seqÃ¼Ã¨ncia donada, _menys el primer element_. Com trobarÃ­em totes les permutacions possibles? La soluciÃ³
Ã©s senzilla: NomÃ©s cal inserir el primer element a totes les permutacions que tenim, de totes les
maneres possibles.

Per exemple: Volem calcular `(perms [1 2 3])`, el resultat ha de ser `((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))`.

Imaginem que tenim ja calculat `(perms [2 3])`, Ã©s a dir, `((2 3) (3 2))`.

NomÃ©s caldria inserir l'`1` de totes les maneres possibles a `(2 3)`: `((1 2 3) (2 1 3) (2 3 1))`, i tambÃ©
fer-ho a `(3 2)`: `((1 3 2) (3 1 2) (3 2 1))`. N'hi hauria prou concatenant aquestes dues seqÃ¼Ã¨ncies
per obtenir el resultat final `((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))`.

---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica mÃ©s gran: Volem una funciÃ³ que, donada una seqÃ¼Ã¨ncia, retorni totes
les **permutacions** possibles d'aquesta seqÃ¼Ã¨ncia.

Suposem que tenim una funciÃ³ `(inserts elem seq)` que fa precisament aixÃ², inserir `elem` a `seq` de totes
les maneres possibles. En aquest cas n'hi hauria prou fent:

```Clojure
(map (partial inserts 1) (perms [2 3])) 
ğŸ‘‰ ( ((1 2 3) (2 1 3) (2 3 1)) ((1 3 2) (3 1 2) (3 2 1)) )

;; i ara fem la concatenaciÃ³:
(apply concat '( ((1 2 3) (2 1 3) (2 3 1)) ((1 3 2) (3 1 2) (3 2 1)) ))
ğŸ‘‰ ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))
```

AixÃ­ doncs, definirem primer `inserts`...

---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica mÃ©s gran: Volem una funciÃ³ que, donada una seqÃ¼Ã¨ncia, retorni totes
les **permutacions** possibles d'aquesta seqÃ¼Ã¨ncia.

La idea Ã©s partir d'haver inserit l'element a la cua de la seqÃ¼Ã¨ncia, i afegir-hi el primer
element de la seqÃ¼Ã¨ncia desprÃ©s:

```Clojure
(defn inserts
  "Insereix de totes les maneres possibles l'element x a la seqÃ¼Ã¨ncia s"
  [x s]
  (if (empty? s) (list (list x))
      (let [[cap & cua]          s
            resultat-parcial     (inserts x cua)]
        (cons (cons x s) (map (partial cons cap) resultat-parcial)))))

;;(inserts 0 [1,2,3,4]) 
;;         - ---------
;;         x     s
;; ğŸ‘‰ ((0 1 2 3 4) (1 0 2 3 4) (1 2 0 3 4) (1 2 3 0 4) (1 2 3 4 0))
;;     ----------- -----------------------------------------------
;;     (cons x s)     (map (partial cons cap) resultat-parcial)
;;
;; ja que:
;;(inserts 0 [2,3,4]) ğŸ‘‰ ((0 2 3 4) (2 0 3 4) (2 3 0 4) (2 3 4 0))
;;                        ---------------------------------------
;;                         resultat-parcial = (inserts 0 [2,3,4])
```
---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica mÃ©s gran: Volem una funciÃ³ que, donada una seqÃ¼Ã¨ncia, retorni totes
les **permutacions** possibles d'aquesta seqÃ¼Ã¨ncia.

Ara ja podem definir `perms` tal com l'hem descrit abans:

```Clojure
(defn perms
  "Calcular una seqÃ¼Ã¨ncia amb totes les permutacions d's"
  [s]
  (if (empty? s) '(())
    (let [[cap & cua]  s
          perms-cua    (perms cua)]
      (apply concat (map (partial inserts cap) perms-cua)))))
      
;;(perms [1 2 3]) ğŸ‘‰ ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))
;;
;;com la crida recursiva fa (perms [2 3]) ğŸ‘‰ ((2 3) (3 2))
;;
;; aleshores nomÃ©s ens cal:
;;(map (partial inserts 1) (perms [2 3])) 
;; ğŸ‘‰ ( ((1 2 3) (2 1 3) (2 3 1)) ((1 3 2) (3 1 2) (3 2 1)) )
;;
;; i finalment:
;;(apply concat '( ((1 2 3) (2 1 3) (2 3 1)) ((1 3 2) (3 1 2) (3 2 1)) ))
;; ğŸ‘‰ ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))
```
---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica mÃ©s gran: Volem una funciÃ³ que, donada una seqÃ¼Ã¨ncia, retorni totes
les **permutacions** possibles d'aquesta seqÃ¼Ã¨ncia.

Les dues funcions que hem fet, `perms` i l'auxiliar `inserts` **_tambÃ©_** es poden expressar en termes de
`fold` (ğŸ˜µâ€ğŸ’«ğŸ§ !).

Farem servir una funciÃ³ que resultarÃ  molt Ãºtil, no nomÃ©s per a aquest exemple, `concatMap`:

```Clojure
;; Suposem que f Ã©s pura, i que el resultat d'aplicar f Ã©s una seqÃ¼Ã¨ncia:
;; concatMap f = concat Â· (map f)
;;
(def concatMap  #((comp (partial apply concat) (partial map %1)) %2))

(concatMap #(map inc (range %1)) [1 2 3 4]) ğŸ‘‰ (1 1 2 1 2 3 1 2 3 4)

;; ja que (map #(map inc (range %1)) [1 2 3 4]) ğŸ‘‰ ((1) (1 2) (1 2 3) (1 2 3 4))
;; i (apply concat '((1) (1 2) (1 2 3) (1 2 3 4))) ğŸ‘‰ (1 1 2 1 2 3 1 2 3 4)

```
---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica mÃ©s gran: Volem una funciÃ³ que, donada una seqÃ¼Ã¨ncia, retorni totes
les **permutacions** possibles d'aquesta seqÃ¼Ã¨ncia.

Finalment:

```Clojure
(defn inserts
  "versiÃ³ d'inserts amb fold"
  [x s]
  (letfn [(step [y yss] ;; depÃ©n del fet que (first (inserts x ys)) = (cons x ys)
            (let [ys   (rest (first yss))]
              (cons (cons x (cons y ys)) (map (partial cons y) yss))))]
    (fold step (list (list x)) s)))

(defn perms
  "versiÃ³ de perms amb fold"
  [s]
  (letfn [(step [x xss]
            (concatMap (partial inserts x) xss))]
    (fold step '(()) s)))
    
(inserts 0 [1 2 3]) ğŸ‘‰ ((0 1 2 3) (1 0 2 3) (1 2 0 3) (1 2 3 0))

(perms [1 2 3]) ğŸ‘‰ ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))
```
**Exercici**: Analitzeu aquestes funcions fins entendre-les bÃ©
