class: center, up

# CAP - Funcions _First Class_

![:scale 50%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 3 i 4</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# SessiÃ³ 03

---

# Funcions _First Class_

<br> <br>

_In computer science, a programming language is said to have
first-class functions if it treats functions as first-class citizens.
This means **the language supports passing functions as arguments to
other functions, returning them as the values from other functions,
and assigning them to variables or storing them in data structures**.
Some programming language theorists require **support for anonymous
functions (function literals) as well**_. 

_In languages with first-class functions, the names of functions do not
have any special status; they are treated like ordinary variables with
a function type. The term was coined by Christopher Strachey in the
context of "functions as first-class citizens" in the mid-1960s._

.tiny[[.red[Source: Wikipedia]](https://en.wikipedia.org/wiki/First-class_function)]

---

# Funcions _First Class_

Ja hem vist "_dissimuladament_" alguns exemples:

* L'expressiÃ³ `(if (> x 0) + -)` retorna el valor-funciÃ³ lligat al sÃ­mbol `+` o al sÃ­mbol `-`, depÃ©n del valor d'`x`.

* La funciÃ³ `apply` requeria una funciÃ³ com a parÃ metre

* Igual que fem `(def s 345)` podem fer `(def quadrat (fn [x] (* x x)))`, Ã©s a dir, podem lligar funcions 
a noms per fer-les servir desprÃ©s: `(quadrat 7) ğŸ‘‰ 49`

El fet de tractar les funcions com a valors qualsevol, que poden passar-se com a argument a una funcio,
que poden retornar-se com a funcions i que poden vincular-se a un nom Ã©s _fonamental_ en les tÃ¨cniques associades
a la programaciÃ³ funcional.

Avui dia hi ha molt pocs llenguatges de programaciÃ³ que no donin suport a les funcions com a _first class citizens_.
Per exemple, les darreres versions de Java i de C++ han mirat d'afegir funcions de primera clase,
sense resoldre-ho satisfactÃ²riament en comparaciÃ³ amb Clojure, Common Lisp, Smalltalk, Javascript, Python, etc.red[*]

.footnote[.red[*] OpiniÃ³ subjectiva, que quedi clar]

---

# Funcions _First Class_

La _Clojure sequence library_ estÃ  composada, sobre tot, de funcions que requereixen funcions com a parÃ metre, Ã©s
a dir, de **_funcions d'ordre superior_** (_Higher Order Functions_)

AixÃ­ doncs, una petita mostra de les funcions d'aquesta _library_ poden ser (algunes les veurem amb una mica de detall):

.cols5050[
.col1[
* `map`

* `filter`

* `remove`

* `drop-while`

* `take-while`

* `every?`

* `some?`

]
.col2[
* `repeatedly`

* `reduce`

* `iterate`

* `apply`

* `partial`

* `comp`

* `sort-by`
]]

**Exercici**: Hi ha mÃ©s funcions a la _Seq library_. Feu-ne una ullada 
[aquÃ­](https://clojure.org/reference/sequences#_the_seq_library).

---

# Funcions d'ordre superior habituals

### `map`

Aplica una funciÃ³ a tots els elements d'una seqÃ¼Ã¨ncia.

**Exemples**:

```clojure
(map inc '(1 2 3))  ğŸ‘‰  (2 3 4)
```

```clojure
(map + '(1 2 3) '(4 5 6 7))  ğŸ‘‰  (5 7 9)
```

### `filter`

ObtÃ© els elements d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(filter even? '(2 1 4 6 7))  ğŸ‘‰  (2 4 6)
```

---

# Funcions d'ordre superior habituals

### `drop-while`

Elimina els primers elements consecutius d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(drop-while even? '(2 4 6 7 8))  ğŸ‘‰  (7 8)
```

### `take-while`

ObtÃ© els primers elements consecutius d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(take-while even? '(2 4 6 7 8))  ğŸ‘‰  (2 4 6)
```
---

# Funcions d'ordre superior habituals

### `reduce`

Desplega un operador `âŠ•` a una llista $(x_1 x_2 ... x_n)$ donant el resultat $((x1 âŠ• x2) âŠ• ...) âŠ• xn$.

**Exemples**:

```clojure
(reduce + '(2 4 6))  ğŸ‘‰  12
```

```clojure
(reduce * 1 '(2 3 4))  ğŸ‘‰  24
```

### `iterate`

`(iterate f x)` retorna la llista "_infinita_" `'(x (f x) (f (f x))...)`.

**Exemple**:

```clojure
(take 5 (iterate inc 1))  ğŸ‘‰  (1 2 3 4 5)

```

---

# Funcions d'ordre superior habituals

### `apply`

Aplica una funciÃ³ a una llista.

**Exemple**:

```clojure
(apply + 1 '(2 3))  ğŸ‘‰  6`           ; equivalent a (+ 1 2 3)
```

### `partial` 

Torna una funciÃ³ derivada de fixar parÃ metres d'una altra funciÃ³ que rep com a parÃ metre. EstÃ  relacionada amb la *currificaciÃ³*.

**Exemple**:

```clojure
((partial + 2) 4)  ğŸ‘‰  6`
```

```clojure
(def f (partial #(str %1 %2 "!") "Hola ")) 
(f "Gerard")  ğŸ‘‰  "Hola Gerard!"
```

---

# Funcions d'ordre superior habituals

### `comp` 

ComposiciÃ³ de funcions.

**Exemple**:

```clojure
((comp reverse sort) '(3 1 5))  ğŸ‘‰  (5 3 1)
```

```clojure
(def tres-mes-grans (comp (partial take 3) reverse sort))

(tres-mes-grans '(3 1 2 6 7))  ğŸ‘‰  (7 6 3)
```

### `every?`

Mira si un predicat es satisfÃ  per tots els elements d'una seqÃ¼Ã¨ncia.

**Exemple**:

```clojure
(every? even? '(2 4 6))  ğŸ‘‰  true
```
---

# Funcions d'ordre superior

L'Ãºs d'aquestes funcions d'ordre superior permet fer programes mÃ©s petits, ja que
augmenten considerablement l'expressivitat del llenguatge.

Veiem-ne un exemple: Volem una funciÃ³ que, donat un element i una colÂ·lecciÃ³, retorni
un _Ã­ndex_ que caracteritzi la posiciÃ³ d'allÃ² que busquem.
(_The Joy of Clojure_ p. 111).

AlgÃº que sap el Clojure que nosaltres sabem (de moment poquet ğŸ˜„) pot proposar:

```Clojure
(defn pos [e coll]
    (let [cmp (if (map? coll)
                 #(= (second %1) %2)
                 #(= %1 %2))]
       (loop [s coll idx 0]
           (when (seq s)             ;; (seq nil) ğŸ‘‰ nil
               (if (cmp (first s) e)
                   (if (map? coll)
                       (first (first s))
                       idx)
                   (recur (next s) (inc idx)))))))

(pos 3 [:a 1 :b 2 :c 3 :d 4])    ğŸ‘‰ 5
(pos :foo [:a 1 :b 2 :c 3 :d 4]) ğŸ‘‰ nil
(pos 3 {:a 1 :b 2 :c 3 :d 4})    ğŸ‘‰ :c
(pos \3 ":a 1 :b 2 :c 3 :d 4")   ğŸ‘‰ 13
```
---

# Funcions d'ordre superior

Aquesta funciÃ³ no Ã©s gens "_clojurian_". No Ã©s _idiomÃ tica_. Ã‰s essencialment una funciÃ³ que no tÃ©
gens en compte la possibilitat de fer servir funcions d'ordre superior (excepte
a la definiciÃ³ de `cmp`).

Generalitzem el problema mirant de transformar una colÂ·lecciÃ³ en una seqÃ¼Ã¨ncia
de parelles (vectors) `[Ã­ndex element]`:

```Clojure
(defn index [coll]
    (cond
        (map? coll) (seq coll)
        (set? coll) (map vector coll coll)
        :else (map vector (iterate inc 0) coll)))
        
(index [:a 1 :b 2 :c 3 :d 4])  ğŸ‘‰ ([0 :a] [1 1] [2 :b] [3 2] [4 :c] [5 3] [6 :d] [7 4])
(index {:a 1 :b 2 :c 3 :d 4})  ğŸ‘‰ ([:a 1] [:b 2] [:c 3] [:d 4])
(index ":a 1 :b 2 :c 3 :d 4")  ğŸ‘‰ ([0 \:] [1 \a] [2 \space] [3 \1] [4 \space] [5 \:] [6 \b] [7 \space] [8 \2] [9 \space] [10 \:] [11 \c] [12 \space] [13 \3] [14 \space] [15 \:] [16 \d] [17 \space] [18 \4])
(index #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ ([1 1] [4 4] [:c :c] [3 3] [2 2] [:b :b] [:d :d] [:a :a])
```

.tiny[Aplicar `index` a un vector, una llista o una _string_ com a argument
retorna una seqÃ¼Ã¨ncia de vectors de dos elements on el primer Ã©s
l'Ã­ndex i el segon l'element. Si apliquem `index` a un diccionari
senzillament aparellarÃ  claus i valors, i aplicar la funciÃ³ a un
conjunt (on el concepte d'Ã­ndex Ã©s _forÃ§at_, ja que no tÃ© gaire sentit
en dependre d'un ordre arbitrari) retornarÃ  una seqÃ¼Ã¨ncia amb els
elements aparellats amb ells mateixos.]

---

# Funcions d'ordre superior

Amb la funciÃ³ `index` Ã©s fÃ cil fer una versiÃ³ de `pos` mÃ©s senzilla:

```Clojure
(defn pos' [e coll]
    (let [element (first (drop-while #(not= (second %) e) (index coll)))]
        (first element)))
        
(pos' 3 [:a 1 :b 2 :c 3 :d 4])    ğŸ‘‰ 5
(pos' :foo [:a 1 :b 2 :c 3 :d 4]) ğŸ‘‰ nil
(pos' 3 {:a 1 :b 2 :c 3 :d 4})    ğŸ‘‰ :c
(pos' \3 ":a 1 :b 2 :c 3 :d 4")   ğŸ‘‰ 13

;; perÃ²

(pos  :d #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ 6
(pos' :d #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ :d
```

`pos'` Ã©s molt semblant a `pos`, excepte si la colÂ·lecciÃ³ Ã©s un conjunt. En aquest
cas, la decisiÃ³ que hem pres a la funciÃ³ `index` fa que el retorn sigui diferent:
`pos` retornarÃ  un Ã­ndex numÃ¨ric, reflectint l'ordre (arbitrari) que Clojure ha
donat als elements, i `pos'` retorna l'element en qÃ¼estiÃ³, si hi Ã©s.

Un dels avantatges de la possibilitat de fer servir funcions d'ordre
superior Ã©s que ens permet major expressivitat i per tant escriure codi 
mÃ©s compacte.

---

# Funcions d'ordre superior

Comparem

```Clojure
(defn pos [e coll]
    (let [cmp (if (map? coll)
                 #(= (second %1) %2)
                 #(= %1 %2))]
       (loop [s coll idx 0]
           (when (seq s)             ;; (seq nil) ğŸ‘‰ nil
               (if (cmp (first s) e)
                   (if (map? coll)
                       (first (first s))
                       idx)
                   (recur (next s) (inc idx)))))))
```
amb
```Clojure
(defn pos' [e coll]
    (letfn [(index [coll]
              (cond
                  (map? coll) (seq coll)
                  (set? coll) (map vector coll coll)
                  :else (map vector (iterate inc 0) coll)))]
       (let [element (first (drop-while #(not= (second %) e) (index coll)))]
           (first element))))
```
---

# Funcions d'ordre superior

Si tenim funcions d'ordre superior podem implementar estructures de dades. 
Perdem en eficiÃ¨ncia, perÃ² aquest Ã©s un exercici, un cop mÃ©s, en expressivitat.

Veiem un exemple: Estructures associatives. Imaginem que volem crear una 
estructura que em permeti associar claus a valors, i fer cerques sobre aquestes
claus per recuperar els valors associats. Operacions que volem sobre aquesta estructura: `crear`/`cercar`/`afegir`. 

Volem construir una estructura aixÃ­ fent servir _nomÃ©s_ funcions.

```Clojure
(defn crear []
    (fn [_] :default)) ;; retornem una funciÃ³ que retorna un valor per defecte

(defn cercar [estructura clau]
    (estructura clau))
    
(defn afegir [estructura clau valor]
    (fn [clau']
        (if (= clau' clau)
            valor
            (cercar estructura clau'))))

(let [d (afegir (afegir (afegir (afegir (crear) :a 1) :b 2) :c 3) :d 4)] 
    (cercar d :b)) ğŸ‘‰ 2

(let [d (afegir (afegir (afegir (afegir (crear) :a 1) :b 2) :c 3) :d 4)] 
    (cercar d :e)) ğŸ‘‰ :default
```
