class: center, up

# CAP - Funcions _First Class_

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 3 i 4</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# SessiÃ³ 03

---

## Funcions _First Class_

<br> <br>

_In computer science, a programming language is said to have
first-class functions if it treats functions as first-class citizens.
This means **the language supports passing functions as arguments to
other functions, returning them as the values from other functions,
and assigning them to variables or storing them in data structures**.
Some programming language theorists require **support for anonymous
functions (function literals) as well**_. 

_In languages with first-class functions, the names of functions do not
have any special status; they are treated like ordinary variables with
a function type. The term was coined by Christopher Strachey in the
context of "functions as first-class citizens" in the mid-1960s._

.tiny[[.red[Source: Wikipedia]](https://en.wikipedia.org/wiki/First-class_function)]

---

## Funcions _First Class_

Ja hem vist "_dissimuladament_" alguns exemples:

* L'expressiÃ³ `(if (> x 0) + -)` retorna el valor-funciÃ³ lligat al sÃ­mbol `+` o al sÃ­mbol `-`, depÃ©n del valor d'`x`.

* La funciÃ³ `apply` requeria una funciÃ³ com a parÃ metre

* Igual que fem `(def s 345)` podem fer `(def quadrat (fn [x] (* x x)))`, Ã©s a dir, podem lligar funcions 
a noms per fer-les servir desprÃ©s: `(quadrat 7) ğŸ‘‰ 49`

El fet de tractar les funcions com a valors qualsevol, que poden passar-se com a argument a una funcio,
que poden retornar-se com a funcions i que poden vincular-se a un nom Ã©s _fonamental_ en les tÃ¨cniques associades
a la programaciÃ³ funcional.

Avui dia hi ha molt pocs llenguatges de programaciÃ³ que no donin suport a les funcions com a _first class citizens_.
Les darreres versions de Java i de C++ han mirat d'afegir funcions de primera clase,
sense resoldre-ho satisfactÃ²riament en comparaciÃ³ amb Clojure, Common Lisp, Smalltalk, Javascript, Python, etc.red[*]

.footnote[.red[*] OpiniÃ³ parcialment subjectiva, que quedi clar]

---

## Funcions _First Class_

La _Clojure sequence library_ estÃ  composada, sobre tot, de funcions que requereixen funcions com a parÃ metre, Ã©s
a dir, de **_funcions d'ordre superior_** (_Higher Order Functions_)

AixÃ­ doncs, una petita mostra de les funcions d'aquesta _library_ poden ser (algunes les veurem amb una mica de detall):

.cols5050[
.col1[
* `map`

* `filter`

* `remove`

* `drop-while`

* `take-while`

* `every?`

* `some?`

]
.col2[
* `repeatedly`

* `reduce`

* `iterate`

* `apply`

* `partial`

* `comp`

* `sort-by`
]]

**Exercici**: Hi ha mÃ©s funcions a la _Seq library_. Feu-ne una ullada 
[aquÃ­](https://clojure.org/reference/sequences#_the_seq_library).

---

## Funcions d'ordre superior habituals

### `map`

Aplica una funciÃ³ a tots els elements d'una seqÃ¼Ã¨ncia.

**Exemples**:

```clojure
(map inc '(1 2 3))  ğŸ‘‰  (2 3 4)
```

```clojure
(map + '(1 2 3) '(4 5 6 7))  ğŸ‘‰  (5 7 9)
```

### `filter`

ObtÃ© els elements d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(filter even? '(2 1 4 6 7))  ğŸ‘‰  (2 4 6)
```

---

## Funcions d'ordre superior habituals

### `drop-while`

Elimina els primers elements consecutius d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(drop-while even? '(2 4 6 7 8))  ğŸ‘‰  (7 8)
```

### `take-while`

ObtÃ© els primers elements consecutius d'una seqÃ¼Ã¨ncia que satisfan un predicat.

**Exemple**:

```clojure
(take-while even? '(2 4 6 7 8))  ğŸ‘‰  (2 4 6)
```
---

## Funcions d'ordre superior habituals

### `reduce`

Desplega un operador `âŠ•` a una seqÃ¼Ã¨ncia $(x_1 x_2 ... x_n)$ donant el resultat $((x1 âŠ• x2) âŠ• ...) âŠ• xn$.

**Exemples**:

```clojure
(reduce + '(2 4 6))  ğŸ‘‰  12
```

```clojure
(reduce * 1 '(2 3 4))  ğŸ‘‰  24
```

### `iterate`

`(iterate f x)` retorna la seqÃ¼Ã¨ncia "_infinita_" `'(x (f x) (f (f x))...)`.

**Exemple**:

```clojure
(take 5 (iterate inc 1))  ğŸ‘‰  (1 2 3 4 5)

```

---

## Funcions d'ordre superior habituals

### `apply`

Aplica una funciÃ³ a una seqÃ¼Ã¨ncia.

**Exemple**:

```clojure
(apply + 1 '(2 3))  ğŸ‘‰  6`           ; equivalent a (+ 1 2 3)
```

### `partial` 

Torna una funciÃ³ derivada de fixar parÃ metres d'una altra funciÃ³ que rep com a parÃ metre. EstÃ  relacionada amb la *currificaciÃ³*.

**Exemple**:

```clojure
((partial + 2) 4)  ğŸ‘‰  6`
```

```clojure
(def f (partial #(str %1 %2 "!") "Hola ")) 
(f "Gerard")  ğŸ‘‰  "Hola Gerard!"
```

---

## Funcions d'ordre superior habituals

### `comp` 

ComposiciÃ³ de funcions.

**Exemple**:

```clojure
((comp reverse sort) '(3 1 5))  ğŸ‘‰  (5 3 1)
```

```clojure
(def tres-mes-grans (comp (partial take 3) reverse sort))

(tres-mes-grans '(3 1 2 6 7))  ğŸ‘‰  (7 6 3)
```

### `every?`

Mira si un predicat es satisfÃ  per tots els elements d'una seqÃ¼Ã¨ncia.

**Exemple**:

```clojure
(every? even? '(2 4 6))  ğŸ‘‰  true
```
---

## Funcions d'ordre superior

L'Ãºs d'aquestes funcions d'ordre superior permet fer programes mÃ©s petits, ja que
augmenten considerablement l'expressivitat del llenguatge.

Veiem-ne un exemple: Volem una funciÃ³ que, donat un element i una colÂ·lecciÃ³, retorni
un _Ã­ndex_ que caracteritzi la posiciÃ³ de l'element (`nil` si no hi Ã©s).
(_The Joy of Clojure_ p. 111).

AlgÃº que sap el Clojure que nosaltres sabem (de moment poquet ğŸ˜„) pot proposar:

```Clojure
(defn pos [e coll]
    (let [cmp (if (map? coll)
                 #(= (second %1) %2)
                 #(= %1 %2))]
       (loop [s coll idx 0]
           (when (seq s)             ;; (seq nil) ğŸ‘‰ nil
               (if (cmp (first s) e)
                   (if (map? coll)
                       (first (first s))
                       idx)
                   (recur (next s) (inc idx)))))))

(pos 3 [:a 1 :b 2 :c 3 :d 4])    ğŸ‘‰ 5
(pos :foo [:a 1 :b 2 :c 3 :d 4]) ğŸ‘‰ nil
(pos 3 {:a 1 :b 2 :c 3 :d 4})    ğŸ‘‰ :c
(pos \3 ":a 1 :b 2 :c 3 :d 4")   ğŸ‘‰ 13
```
---

## Funcions d'ordre superior

Aquesta funciÃ³ no Ã©s gens "_clojurian_". No Ã©s _idiomÃ tica_. Ã‰s essencialment una funciÃ³ que no tÃ©
gens en compte la possibilitat de fer servir funcions d'ordre superior (excepte
a la definiciÃ³ de `cmp`).

Generalitzem el problema mirant de transformar una colÂ·lecciÃ³ en una seqÃ¼Ã¨ncia
de parelles (vectors) `[Ã­ndex element]`:

```Clojure
(defn index [coll]
    (cond
        (map? coll) (seq coll)
        (set? coll) (map vector coll coll)
        :else (map vector (iterate inc 0) coll)))
        
(index [:a 1 :b 2 :c 3 :d 4])  ğŸ‘‰ ([0 :a] [1 1] [2 :b] [3 2] [4 :c] [5 3] [6 :d] [7 4])
(index {:a 1 :b 2 :c 3 :d 4})  ğŸ‘‰ ([:a 1] [:b 2] [:c 3] [:d 4])
(index ":a 1 :b 2 :c 3 :d 4")  ğŸ‘‰ ([0 \:] [1 \a] [2 \space] [3 \1] [4 \space] [5 \:] [6 \b] [7 \space] [8 \2] [9 \space] [10 \:] [11 \c] [12 \space] [13 \3] [14 \space] [15 \:] [16 \d] [17 \space] [18 \4])
(index #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ ([1 1] [4 4] [:c :c] [3 3] [2 2] [:b :b] [:d :d] [:a :a])
```

.tiny[Aplicar `index` a un vector, una llista o una _string_ com a argument
retorna una seqÃ¼Ã¨ncia de vectors de dos elements on el primer Ã©s
l'Ã­ndex i el segon l'element. Si apliquem `index` a un diccionari
senzillament aparellarÃ  claus i valors, i aplicar la funciÃ³ a un
conjunt (on el concepte d'Ã­ndex Ã©s _forÃ§at_, ja que no tÃ© gaire sentit
en dependre d'un ordre arbitrari) retornarÃ  una seqÃ¼Ã¨ncia amb els
elements aparellats amb ells mateixos.]

---

## Funcions d'ordre superior

Amb la funciÃ³ `index` Ã©s fÃ cil fer una versiÃ³ de `pos` mÃ©s senzilla:

```Clojure
(defn pos' [e coll]
    (let [element (first (drop-while #(not= (second %) e) (index coll)))]
        (first element)))
        
(pos' 3 [:a 1 :b 2 :c 3 :d 4])    ğŸ‘‰ 5
(pos' :foo [:a 1 :b 2 :c 3 :d 4]) ğŸ‘‰ nil
(pos' 3 {:a 1 :b 2 :c 3 :d 4})    ğŸ‘‰ :c
(pos' \3 ":a 1 :b 2 :c 3 :d 4")   ğŸ‘‰ 13

;; perÃ²

(pos  :d #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ 6
(pos' :d #{:a 1 :b 2 :c 3 :d 4}) ğŸ‘‰ :d
```

`pos'` Ã©s molt semblant a `pos`, excepte si la colÂ·lecciÃ³ Ã©s un conjunt. En aquest
cas, la decisiÃ³ que hem pres a la funciÃ³ `index` fa que el retorn sigui diferent:
`pos` retornarÃ  un Ã­ndex numÃ¨ric, reflectint l'ordre (arbitrari) que Clojure ha
donat als elements, i `pos'` retorna l'element en qÃ¼estiÃ³, si hi Ã©s.

Un dels avantatges de la possibilitat de fer servir funcions d'ordre
superior Ã©s que ens permet major expressivitat i per tant escriure codi 
mÃ©s compacte.

---

## Funcions d'ordre superior

Comparem

```Clojure
(defn pos [e coll]
    (let [cmp (if (map? coll)
                 #(= (second %1) %2)
                 #(= %1 %2))]
       (loop [s coll idx 0]
           (when (seq s)             ;; (seq nil) ğŸ‘‰ nil
               (if (cmp (first s) e)
                   (if (map? coll)
                       (first (first s))
                       idx)
                   (recur (next s) (inc idx)))))))
```
amb
```Clojure
(defn pos' [e coll]
    (letfn [(index [coll]
              (cond
                  (map? coll) (seq coll)
                  (set? coll) (map vector coll coll)
                  :else (map vector (iterate inc 0) coll)))]
       (let [element (first (drop-while #(not= (second %) e) (index coll)))]
           (first element))))
```

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

Hem dit abans que `(reduce âŠ• x0 '(x1 x2 ... xn))` desplega un operador `âŠ•` a 
una seqÃ¼Ã¨ncia donant com a resultat `(âŠ• (...(âŠ• (âŠ• x0 x1) x2)...) xn)`.

Veiem-ne exemples:

```Clojure
(reduce + 0 [1 2 3 4 5]) ğŸ‘‰ 15

(reduce conj #{} [:a :b :c]) ğŸ‘‰ #{:a :c :b}

(reduce       ;; nombres primers fins a 100 
  (fn [primes number]
    (if (some zero? (map (partial mod number) primes))
      primes
      (conj primes number)))
  [2]
  (take 98 (iterate inc 3))) 
ğŸ‘‰ [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]

(reduce       ;; primers 20 nombres de Fibonacci
  (fn [a b] (conj a (+' (last a) (last (butlast a)))))
  [0 1]                      
  (range 18))
ğŸ‘‰ [0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181]
```
---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

El que fa `reductions` Ã©s retornar tots els resultats intermedis de la invocaciÃ³ corresponent
de `reduce`. Ã‰s a dir, si `(reduce âŠ• x0 '(x1 x2 ... xn))` Ã©s `(âŠ• (...(âŠ• (âŠ• x0 x1) x2)...) xn)`,
aleshores:

```Clojure
(reductions âŠ• x0 '(x1 x2 ... xn)) ğŸ‘‰ (x0 (âŠ• x0 x1) (âŠ• (âŠ• x0 x1) x2) ...)
```

Per exemple:

```Clojure
(reductions + 0 [1 2 3 4 5]) ğŸ‘‰ (0 1 3 6 10 15)

(reductions conj #{} [:a :b :c]) ğŸ‘‰ (#{} #{:a} #{:b :a} #{:c :b :a})

(reductions     ;; primers fins a 7 (inclÃ²s)
  (fn [primes number]
    (if (some zero? (map (partial mod number) primes))
      primes
      (conj primes number)))
  [2]
  (take 5 (iterate inc 3)))
ğŸ‘‰ ([2] [2 3] [2 3] [2 3 5] [2 3 5] [2 3 5 7])
```
---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

Veiem alguns exemples mÃ©s:

```Clojure
(reduce / 64 [4,2,4]) ğŸ‘‰ 2
(reductions / 64 [4,2,4]) ğŸ‘‰ (64 16 8 2)

(reduce #(+ %2 (* 2 %1)) 4 [1 2 3]) ğŸ‘‰ 43
(reductions #(+ %2 (* 2 %1)) 4 [1 2 3]) ğŸ‘‰ (4 9 20 43)

(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (reduce (flip cons) '() '(1 2 3 4 5 6))) ğŸ‘‰ (6 5 4 3 2 1)
   
(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (reductions (flip cons) '() '(1 2 3 4 5 6)))
ğŸ‘‰(() (1) (2 1) (3 2 1) (4 3 2 1) (5 4 3 2 1) (6 5 4 3 2 1))
```

`reduce` tÃ© equivalents en prÃ cticament tots els llenguatges de programaciÃ³. 
S'anomena `foldl` a Haskell, `reduce` a Common Lisp, `inject:into:` a Smalltalk,
`iterator.fold` a Rust, `functools.reduce` a Python 3.x, `Iterable.fold` a Kotlin,
`array.reduce` a Javascript, `lists:foldl` a Erlang, i un molt llarg etc.red[*].

.footnote[.red[*] Si teniu interÃ©s mireu la [Wikipedia](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29)]

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

`reduce`/`reductions` tenen versions simÃ¨triques que no estan implementades a Clojure,
que podem anomenar `foldr`/`scanr` (igual que en Haskell, on `reduce` Ã©s `foldl` i
`reductions` Ã©s `scanl`).

PodrÃ­em implementar-les:

```Clojure
(defn foldr
  [f val coll]
  (if (empty? coll) val
      (f (first coll) (foldr f val (rest coll)))))

(defn scanr
  [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (reductions (flip f) e rlst)))))
```

on de la definiciÃ³ podem veure que `(foldr âŠ• x0 '(x1 x2 ... xn))` desplega 
l'operador `âŠ•` a una seqÃ¼Ã¨ncia calculant `(âŠ• x1 (âŠ• x2 (...(âŠ• xn x0)...)))`.
`scanr` retorna tots els resultats intermedis de la invocaciÃ³ corresponent
de `foldr`.

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

GrÃ ficament:

`(def y (reduce f x0 '(x1 x2 x3 x4)))`

.center[![:scale 50%](figures/foldl.png)]

`(def y (foldr f x0 '(x1 x2 x3 x4)))`

.center[![:scale 50%](figures/foldr.png)]

---

## Funcions d'ordre superior

### IncÃ­s: `reduce`/`reductions`

Per acabar l'incÃ­s, un exemple senzill ens ajudarÃ  a entendre millor les diferÃ¨ncies entre
aquestes funcions:

```Clojure
(reduce - 0 '(1 2 3 4 5)) ğŸ‘‰ -15 
;; (- (- (- (- (- 0 1) 2) 3) 4) 5)

(reductions - 0 '(1 2 3 4 5)) ğŸ‘‰ (0 -1 -3 -6 -10 -15)
;; 0 â‡’ 0, (- 0 1) â‡’ -1, (- (- 0 1) 2) â‡’ -3, (- (- (- 0 1) 2) 3) â‡’ -6, 
;; (- (- (- (- 0 1) 2) 3) 4) â‡’ -10, (- (- (- (- (- 0 1) 2) 3) 4) 5) â‡’ -15

(foldr - 0 '(1 2 3 4 5)) ğŸ‘‰ 3
;; (- 1 (- 2 (- 3 (- 4 (- 5 0)))))

(scanr - 0 '(1 2 3 4 5)) ğŸ‘‰ (3 -2 4 -1 5 0)
;; (- 1 (- 2 (- 3 (- 4 (- 5 0))))) â‡’ 3, (- 2 (- 3 (- 4 (- 5 0)))) â‡’ -2,
;; (- 3 (- 4 (- 5 0))) â‡’ 4, (- 4 (- 5 0)) â‡’ -1, (- 5 0) â‡’ 5, 0 â‡’ 0
```

---

## Funcions d'ordre superior

Un altre exemple: Recordem l'[algorisme de
Kadane](https://en.wikipedia.org/wiki/Maximum_subarray_problem) per
resoldre el **_Maximum Segment Sum Problem_**: Sigui V un vector de nombres 
que suposarem no pot ser buit.
Considerem totes els seus subvectors possibles (fins i tot el buit). Volem trobar
quant suma el subvector amb suma mÃ xima. 

Per exemple, si V = [31, -41,
59, 26, -53, 58, 97, -93, -23, 84] el resultat Ã©s 187, que correspÃ³n al 
subvector [59, 26, -53, 58, 97].

L'algorisme de Kadane Ã©s un algorisme $\mathcal{O}(n)$ (lineal en la mida del vector) que
resol el problema de manera Ã²ptima.

Una implementaciÃ³ en Clojure que NO fa servir funcions d'ordre superior:
```Clojure
(defn kadane
  "v Ã©s un vector de nombres"
  [v]
  (let [mida (count v)]
    (loop [i 0, resultat 0, actual 0, per-tractar v]
      (if (= mida i)
        resultat
        (let [elem-i   (first per-tractar)
              m        (max (+ actual elem-i) 0)] 
          (recur (inc i) (max resultat m) m (rest per-tractar)))))))
```
---

## Funcions d'ordre superior

Podem fer un algorisme _millor_ (mÃ©s clar, mÃ©s curt) fent servir funcions d'ordre superior? Al tanto, 
que volem un algorisme que tambÃ© sigui lineal $\mathcal{O}(n)$.

```Clojure
(def max0 #(max 0 (+ %1 %2)))

(defn scanr   ;; ja l'hem vist, Ã©s la mateixa funciÃ³
  [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (reductions (flip f) e rlst)))))

(def kadane #(apply max (scanr max0 0 %)))
```

En aquest exemple el paper clau el juga `reductions`, que ens ajuda a definir `scanr`. 

Es pot demostrar que aquest algorisme tambÃ© Ã©s lineal $\mathcal{O}(n)$.

---

## Funcions d'ordre superior

Comparem

```Clojure
(defn kadane
  "v Ã©s un vector de nombres"
  [v]
  (let [mida (count v)]
    (loop [i 0, resultat 0, actual 0, per-tractar v]
      (if (= mida i)
        resultat
        (let [elem-i   (first per-tractar)
              m        (max (+ actual elem-i) 0)] 
          (recur (inc i) (max resultat m) m (rest per-tractar)))))))
```

amb 

```Clojure
(defn kadane
  "coll Ã©s un vector de nombres"
  [coll]
  (letfn [(max0 [x y] (max 0 (+ x y)))
          (scanr [f e lst] (letfn [(flip [ff] (fn [x y] (ff y x)))]
                             (let [rlst   (reverse lst)]
                               (reverse (reductions (flip f) e rlst)))))]
    (apply max (scanr max0 0 coll))))
```
---

## Funcions d'ordre superior















---

class: center, middle

# SessiÃ³ 04

---

## Funcions d'ordre superior

### Els `fold`

Ja hem fet servir les funcions `reduce`/`reductions`. Aquestes funcions sÃ³n fonamentals
en programaciÃ³ funcional, juntament amb les versions simÃ¨triques `foldr`/`scanr`, que no
estan definides a Clojure. 

Recordem les definicions de `foldl`/`reduce`, `foldr`, `scanl`/`reductions` i 
`scanr`:

```Clojure
;; foldl / foldr

(def foldl reduce)

(defn foldr
  [f val coll]
  (if (empty? coll) val
      (f (first coll) (foldr f val (rest coll)))))

;; scanl / scanr

(def scanl reductions)

(defn scanr
  [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (reductions (flip f) e rlst)))))
```
