class: center, up

# CAP - Funcions _First Class_

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 2</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## Funcions _First Class_

<br>

_In computer science, a programming language is said to have
**first-class functions** if it treats functions as first-class citizens.
This means **the language supports passing functions as arguments to
other functions, returning them as the values from other functions,
and assigning them to variables or storing them in data structures**.
Some programming language theorists require **support for anonymous
functions (function literals) as well**_. 

_In languages with first-class functions, the names of functions do not
have any special status; they are treated like ordinary variables with
a function type. The term was coined by Christopher Strachey in the
context of "functions as first-class citizens" in the mid-1960s._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/First-class_function)]

---

## Funcions _First Class_

<br>

_In computer programming, a **pure function** is a function that has the following properties:_

* _the function **return values are identical for identical arguments** (no variation with local static variables, non-local variables, mutable reference arguments or input streams, i.e., referential transparency),_

* _the function has **no side effects** (no mutation of local static variables, non-local variables, mutable reference arguments or input/output streams)._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Pure_function)]

<br>

**NOTA**: Quan parlem de composici√≥ de funcions, en general, sempre
estarem suposant que la composici√≥ _t√© sentit_, i <ins>no ho farem
expl√≠cit</ins>. √âs a dir, si en algun moment parlem de `(comp f g)` (o, en
altre notaci√≥, `f¬∑g`) estarem suposant que **el rang de `g` est√† incl√≤s
en el domini d'`f`**. Com Clojure no √©s un llenguatge _tipat_, hem
d'expressar aquest requeriment textualment, en lloc de formar part de
les definicions formals de `f` i `g`.

---

## Funcions _First Class_

Ja hem vist "_dissimuladament_" alguns exemples:

* L'expressi√≥ `(if (> x 0) + -)` retorna el valor-funci√≥ lligat al s√≠mbol `+` o al s√≠mbol `-`, dep√©n del valor d'`x`.

* La funci√≥ `apply` requeria una funci√≥ com a par√†metre

* Igual que fem `(def s 345)` podem fer `(def quadrat (fn [x] (* x x)))`, √©s a dir, podem lligar funcions 
a noms per fer-les servir despr√©s: `(quadrat 7) üëâ 49`

El fet de tractar les funcions com a valors qualsevol, que poden passar-se com a argument a una funcio,
que poden retornar-se com a funcions i que poden vincular-se a un nom √©s _fonamental_ en les t√®cniques associades
a la programaci√≥ funcional.

Avui dia hi ha molt pocs llenguatges de programaci√≥ que no donin suport a les funcions com a _first class citizens_.
Les darreres versions de Java i de C++ han mirat d'afegir funcions de primera clase,
sense resoldre-ho satisfact√≤riament en comparaci√≥ amb Clojure, Common Lisp, Smalltalk, Javascript, Python, etc.red[*]

.footnote[.red[*] Opini√≥ parcialment subjectiva, que quedi clar]

---

## _Higher Order Functions_

La _Clojure sequence library_ est√† composada, sobre tot, de funcions que requereixen funcions com a par√†metre, √©s
a dir, de **_funcions d'ordre superior_** (_Higher Order Functions_)

Aix√≠ doncs, una petita mostra de les funcions d'aquesta _library_ poden ser (algunes les veurem amb una mica de detall):

.cols5050[
.col1[
* `map`

* `filter`

* `remove`

* `drop-while`

* `take-while`

* `every?`

* `some?`

]
.col2[
* `repeatedly`

* `reduce`

* `iterate`

* `apply`

* `partial`

* `comp`

* `sort-by`
]]

.small[**Exercici**: Hi ha m√©s funcions a la _Seq library_. Feu-ne una ullada 
[aqu√≠](https://clojure.org/reference/sequences#_the_seq_library).]

---

## Funcions d'ordre superior habituals

### `map`

Aplica una funci√≥ a tots els elements d'una seq√º√®ncia.

**Exemples**:

```clojure
(map inc '(1 2 3))  üëâ  (2 3 4)
```

```clojure
(map + '(1 2 3) '(4 5 6 7))  üëâ  (5 7 9)
```

### `filter`

Obt√© els elements d'una seq√º√®ncia que satisfan un predicat.

**Exemple**:

```clojure
(filter even? '(2 1 4 6 7))  üëâ  (2 4 6)
```

---

## Funcions d'ordre superior habituals

### `drop-while`

Elimina els primers elements consecutius d'una seq√º√®ncia que satisfan un predicat.

**Exemple**:

```clojure
(drop-while even? '(2 4 6 7 8))  üëâ  (7 8)
```

### `take-while`

Obt√© els primers elements consecutius d'una seq√º√®ncia que satisfan un predicat.

**Exemple**:

```clojure
(take-while even? '(2 4 6 7 8))  üëâ  (2 4 6)
```
---

## Funcions d'ordre superior habituals

### `reduce`

Desplega un operador `‚äï` a una seq√º√®ncia $(x_1 x_2 ... x_n)$ donant el resultat $((x1 ‚äï x2) ‚äï ...) ‚äï xn$.

**Exemples**:

```clojure
(reduce + '(2 4 6))  üëâ  12
```

```clojure
(reduce * 1 '(2 3 4))  üëâ  24
```

### `iterate`

`(iterate f x)` retorna la seq√º√®ncia "_infinita_" `'(x (f x) (f (f x))...)`.

**Exemple**:

```clojure
(take 5 (iterate inc 1))  üëâ  (1 2 3 4 5)

```

---

## Funcions d'ordre superior habituals

### `apply`

Aplica una funci√≥ a una seq√º√®ncia.

**Exemple**:

```clojure
(apply + 1 '(2 3))  üëâ  6`           ; equivalent a (+ 1 2 3)
```

### `partial` 

Torna una funci√≥ derivada de fixar par√†metres d'una altra funci√≥ que rep com a par√†metre. Est√† relacionada amb la *currificaci√≥*.

**Exemple**:

```clojure
((partial + 2) 4)  üëâ  6`
```

```clojure
(def f (partial #(str %1 %2 "!") "Hola ")) 
(f "Gerard")  üëâ  "Hola Gerard!"
```

---

## Funcions d'ordre superior habituals

### `comp` 

Composici√≥ de funcions.

**Exemple**:

```clojure
((comp reverse sort) '(3 1 5))  üëâ  (5 3 1)
```

```clojure
(def tres-mes-grans (comp (partial take 3) reverse sort))  ;; point-free style

(tres-mes-grans '(3 1 2 6 7))  üëâ  (7 6 3)
```

.small[Sobre el _point-free style_, o _Tacit Programming_, podeu mirar la [Wikipedia](https://en.wikipedia.org/wiki/Tacit_programming)]

### `every?`

Mira si un predicat es satisf√† per tots els elements d'una seq√º√®ncia.

**Exemple**:

```clojure
(every? even? '(2 4 6))  üëâ  true
```

---

## Funcions d'ordre superior

L'√∫s d'aquestes funcions d'ordre superior permet fer programes m√©s petits, ja que
augmenten considerablement l'expressivitat del llenguatge.

Compareu:

```Clojure
(defn prime? [n]    ;; sense funcions d'ordre superior
  (letfn [(find-divisor [i n]
            (cond
              (> i (inc (quot n 2)))   false
              (= (mod n i) 0)          true
              :else                    (recur (inc i) n)))]
    (if (< n 2) false
      (not (find-divisor 2 n)))))
```

amb

```Clojure
(defn prime? [n]    ;; amb funcions d'ordre superior
  (cond 
    (< n 2) false 
    :else (not-any? zero? (map #(rem n %) (range 2 (inc (quot n 2)))))))
```

per√≤...

---

## Funcions d'ordre superior

L'√∫s d'aquestes funcions d'ordre superior permet fer programes m√©s petits, ja que
augmenten considerablement l'expressivitat del llenguatge.

Compareu:

```Clojure
(defn prime? [n]    ;; sense funcions d'ordre superior
  (letfn [(find-divisor [i n]
            (cond
              (> i (inc (quot n 2)))   false
              (= (mod n i) 0)          true
              :else                    (recur (inc i) n)))]
    (if (< n 2) false
      (not (find-divisor 2 n)))))
```

amb

```Clojure
(defn prime? [n]    ;; amb funcions d'ordre superior
  (cond 
    (< n 2) false 
    :else (not-any? zero? (map #(rem n %) (range 2 (inc (quot n 2)))))))
```

...no s√≥n igual d'eficients!!!

---

## Funcions d'ordre superior

L'√∫s d'aquestes funcions d'ordre superior permet fer programes m√©s petits, ja que
augmenten considerablement l'expressivitat del llenguatge.

Compareu:

```Clojure
(defn prime? [n]    ;; sense funcions d'ordre superior
  (letfn [(find-divisor [i n]
            (cond
              (> i (inc (quot n 2)))   false
              (= (mod n i) 0)          true
              :else                    (recur (inc i) n)))]
    (if (< n 2) false
      (not (find-divisor 2 n)))))
```

amb

```Clojure
(defn prime? [n]    ;; amb funcions d'ordre superior
  (cond 
    (or (< n 2) (and (not= n 2) (zero? (rem n 2))))  false 
    :else   (let [m    (dec (quot n 2))] 
              (= m (count (take-while #(not= 0 (rem n %)) 
                                      (range 2 (inc (quot n 2)))))))))
```

---

## Funcions d'ordre superior

Veiem-ne un exemple una mica m√©s gran: Volem una funci√≥ que, donat un element i una col¬∑lecci√≥, retorni
un _√≠ndex_ que caracteritzi la posici√≥ de l'element (`nil` si no hi √©s).
(_The Joy of Clojure_ p. 111).

Alg√∫ que sap el Clojure que nosaltres sabem (de moment poquet üòÑ) pot proposar:

```Clojure
(defn pos [e coll]
    (let [cmp (if (map? coll)
                 #(= (second %1) %2)
                 #(= %1 %2))]
       (loop [s coll, idx 0]
           (when (seq s)             ;; (seq nil) üëâ nil
               (if (cmp (first s) e)
                   (if (map? coll)
                       (first (first s))
                       idx)
                   (recur (next s) (inc idx)))))))

(pos 3 [:a 1 :b 2 :c 3 :d 4])    üëâ 5
(pos :foo [:a 1 :b 2 :c 3 :d 4]) üëâ nil
(pos 3 {:a 1 :b 2 :c 3 :d 4})    üëâ :c
(pos \3 ":a 1 :b 2 :c 3 :d 4")   üëâ 13
```
---

## Funcions d'ordre superior

Aquesta funci√≥ no √©s gens "_clojurian_". No √©s _idiom√†tica_. √âs essencialment una funci√≥ que no t√©
gens en compte la possibilitat de fer servir funcions d'ordre superior (excepte
a la definici√≥ de `cmp`).

Generalitzem el problema mirant de transformar una col¬∑lecci√≥ en una seq√º√®ncia
de parelles (vectors) `[√≠ndex element]`:

```Clojure
(defn index [coll]
    (cond
        (map? coll) (seq coll)
        (set? coll) (map vector coll coll)
        :else (map vector (iterate inc 0) coll)))
        
(index [:a 1 :b 2 :c 3 :d 4])  üëâ ([0 :a] [1 1] [2 :b] [3 2] [4 :c] [5 3] [6 :d] [7 4])
(index {:a 1 :b 2 :c 3 :d 4})  üëâ ([:a 1] [:b 2] [:c 3] [:d 4])
(index ":a 1 :b 2 :c 3 :d 4")  üëâ ([0 \:] [1 \a] [2 \space] [3 \1] [4 \space] [5 \:] [6 \b] [7 \space] [8 \2] [9 \space] [10 \:] [11 \c] [12 \space] [13 \3] [14 \space] [15 \:] [16 \d] [17 \space] [18 \4])
(index #{:a 1 :b 2 :c 3 :d 4}) üëâ ([1 1] [4 4] [:c :c] [3 3] [2 2] [:b :b] [:d :d] [:a :a])
```

.tiny[Aplicar `index` a un vector, una llista o una _string_ com a argument
retorna una seq√º√®ncia de vectors de dos elements on el primer √©s
l'√≠ndex i el segon l'element. Si apliquem `index` a un diccionari
senzillament aparellar√† claus i valors, i aplicar la funci√≥ a un
conjunt (on el concepte d'√≠ndex √©s _for√ßat_, ja que no t√© gaire sentit
en dependre d'un ordre arbitrari) retornar√† una seq√º√®ncia amb els
elements aparellats amb ells mateixos.]

---

## Funcions d'ordre superior

Amb la funci√≥ `index` √©s f√†cil fer una versi√≥ de `pos` m√©s senzilla:

```Clojure
(defn pos' [e coll]
    (let [element (first (drop-while #(not= (second %) e) (index coll)))]
        (first element)))
        
(pos' 3 [:a 1 :b 2 :c 3 :d 4])    üëâ 5
(pos' :foo [:a 1 :b 2 :c 3 :d 4]) üëâ nil
(pos' 3 {:a 1 :b 2 :c 3 :d 4})    üëâ :c
(pos' \3 ":a 1 :b 2 :c 3 :d 4")   üëâ 13

;; per√≤

(pos  :d #{:a 1 :b 2 :c 3 :d 4}) üëâ 6
(pos' :d #{:a 1 :b 2 :c 3 :d 4}) üëâ :d
```

`pos'` √©s molt semblant a `pos`, excepte si la col¬∑lecci√≥ √©s un conjunt. En aquest
cas, la decisi√≥ que hem pres a la funci√≥ `index` fa que el retorn sigui diferent:
`pos` retornar√† un √≠ndex num√®ric, reflectint l'ordre (arbitrari) que Clojure ha
donat als elements, i `pos'` retorna l'element en q√ºesti√≥, si hi √©s.

Un dels avantatges de la possibilitat de fer servir funcions d'ordre
superior √©s que ens permet major expressivitat i per tant escriure codi 
m√©s compacte.

---

## Funcions d'ordre superior

Comparem

```Clojure
(defn pos [e coll]
    (let [cmp (if (map? coll)
                 #(= (second %1) %2)
                 #(= %1 %2))]
       (loop [s coll, idx 0]
           (when (seq s)             ;; (seq nil) üëâ nil
               (if (cmp (first s) e)
                   (if (map? coll)
                       (first (first s))
                       idx)
                   (recur (next s) (inc idx)))))))
```
amb
```Clojure
(defn pos' [e coll]
    (letfn [(index [coll]
              (cond
                  (map? coll) (seq coll)
                  (set? coll) (map vector coll coll)
                  :else (map vector (iterate inc 0) coll)))]
       (let [element (first (drop-while #(not= (second %) e) (index coll)))]
           (first element))))
```

---

## Funcions d'ordre superior

### Inc√≠s: `reduce`/`reductions`

Hem dit abans que `(reduce ‚äï x0 '(x1 x2 ... xn))` desplega un operador `‚äï` a 
una seq√º√®ncia donant com a resultat `(‚äï (...(‚äï (‚äï x0 x1) x2)...) xn)`.

Veiem-ne exemples:

```Clojure
(reduce + 0 [1 2 3 4 5]) üëâ 15

(reduce conj #{} [:a :b :c]) üëâ #{:a :c :b}

```

---

## Funcions d'ordre superior

### Inc√≠s: `reduce`/`reductions`

Hem dit abans que `(reduce ‚äï x0 '(x1 x2 ... xn))` desplega un operador `‚äï` a 
una seq√º√®ncia donant com a resultat `(‚äï (...(‚äï (‚äï x0 x1) x2)...) xn)`.

Veiem-ne exemples:

```Clojure
(reduce + 0 [1 2 3 4 5]) üëâ 15

(reduce conj #{} [:a :b :c]) üëâ #{:a :c :b}

(reduce       ;; nombres primers fins a 100 
  (fn [primes number]
    (if (some zero? (map (partial mod number) primes))
      primes
      (conj primes number)))
  [2]
  (take 98 (iterate inc 3))) 
üëâ [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]

(reduce       ;; primers 20 nombres de Fibonacci
  (fn [a b] (conj a (+' (last a) (last (butlast a)))))
  [0 1]                      
  (repeat 18 1))
üëâ [0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181]
```

---

## Funcions d'ordre superior

### Inc√≠s: `reduce`/`reductions`

El que fa `reductions` √©s retornar tots els resultats intermedis de la invocaci√≥ corresponent
de `reduce`. √âs a dir, si `(reduce ‚äï x0 '(x1 x2 ... xn))` √©s `(‚äï (...(‚äï (‚äï x0 x1) x2)...) xn)`,
aleshores:

```Clojure
(reductions ‚äï x0 '(x1 x2 ... xn)) üëâ (x0 (‚äï x0 x1) (‚äï (‚äï x0 x1) x2) ...)
```

Per exemple:

```Clojure
(reductions + 0 [1 2 3 4 5]) üëâ (0 1 3 6 10 15)

(reductions conj #{} [:a :b :c]) üëâ (#{} #{:a} #{:b :a} #{:c :b :a})

(reductions     ;; primers fins a 7 (incl√≤s)
  (fn [primes number]
    (if (some zero? (map (partial mod number) primes))
      primes
      (conj primes number)))
  [2]
  (take 5 (iterate inc 3)))
üëâ ([2] [2 3] [2 3] [2 3 5] [2 3 5] [2 3 5 7])
```
---

## Funcions d'ordre superior

### Inc√≠s: `reduce`/`reductions`

Veiem alguns exemples m√©s:

```Clojure
(reduce / 64 [4,2,4]) üëâ 2
(reductions / 64 [4,2,4]) üëâ (64 16 8 2)

(reduce #(+ %2 (* 2 %1)) 4 [1 2 3]) üëâ 43
(reductions #(+ %2 (* 2 %1)) 4 [1 2 3]) üëâ (4 9 20 43)

(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (reduce (flip cons) '() '(1 2 3 4 5 6))) üëâ (6 5 4 3 2 1)
   
(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (reductions (flip cons) '() '(1 2 3 4 5 6)))
üëâ(() (1) (2 1) (3 2 1) (4 3 2 1) (5 4 3 2 1) (6 5 4 3 2 1))
```

`reduce` t√© equivalents en pr√†cticament tots els llenguatges de programaci√≥. 
S'anomena `foldl` a Haskell, `reduce` a Common Lisp, `inject:into:` a Smalltalk,
`iterator.fold` a Rust, `functools.reduce` a Python 3, `Iterable.fold` a Kotlin,
`array.reduce` a Javascript, `lists:foldl` a Erlang, i un molt llarg etc.red[*].

.footnote[.red[*] Si teniu inter√©s mireu la [Wikipedia](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29)]

---

## Funcions d'ordre superior

### Inc√≠s: `reduce`/`reductions`

`reduce`/`reductions` tenen versions sim√®triques que no estan implementades a Clojure,
que podem anomenar `foldr`/`scanr` (igual que en Haskell, on `reduce` √©s `foldl` i
`reductions` √©s `scanl`).

Podr√≠em implementar-les:

```Clojure
(defn foldr
  [f val coll]
  (if (empty? coll) val
      (f (first coll) (foldr f val (rest coll)))))

(defn scanr
  [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (reductions (flip f) e rlst)))))
```

on de la definici√≥ podem veure que `(foldr ‚äï x0 '(x1 x2 ... xn))` desplega 
l'operador `‚äï` a una seq√º√®ncia calculant `(‚äï x1 (‚äï x2 (...(‚äï xn x0)...)))`.
`scanr` retorna tots els resultats intermedis de la invocaci√≥ corresponent
de `foldr`.

---

## Funcions d'ordre superior

### Inc√≠s: `reduce`/`reductions`

Gr√†ficament:

```Clojure
(def y (reduce f x0 '(x1 x2 x3 x4)))
```
.center[![:scale 50%](figures/foldl.png)]

```Clojure
(def y (foldr f x0 '(x1 x2 x3 x4)))
```
.center[![:scale 50%](figures/foldr.png)]

---

## Funcions d'ordre superior

### Inc√≠s: `reduce`/`reductions`

Per acabar l'inc√≠s, un exemple senzill ens ajudar√† a entendre millor les difer√®ncies entre
aquestes funcions:

```Clojure
(reduce - 0 '(1 2 3 4 5)) üëâ -15 
;; (- (- (- (- (- 0 1) 2) 3) 4) 5)

(reductions - 0 '(1 2 3 4 5)) üëâ (0 -1 -3 -6 -10 -15)
;; 0 ‚áí 0, (- 0 1) ‚áí -1, (- (- 0 1) 2) ‚áí -3, (- (- (- 0 1) 2) 3) ‚áí -6, 
;; (- (- (- (- 0 1) 2) 3) 4) ‚áí -10, (- (- (- (- (- 0 1) 2) 3) 4) 5) ‚áí -15



(foldr - 0 '(1 2 3 4 5)) üëâ 3
;; (- 1 (- 2 (- 3 (- 4 (- 5 0)))))

(scanr - 0 '(1 2 3 4 5)) üëâ (3 -2 4 -1 5 0)
;; (- 1 (- 2 (- 3 (- 4 (- 5 0))))) ‚áí 3, (- 2 (- 3 (- 4 (- 5 0)))) ‚áí -2,
;; (- 3 (- 4 (- 5 0))) ‚áí 4, (- 4 (- 5 0)) ‚áí -1, (- 5 0) ‚áí 5, 0 ‚áí 0
```

---

## Funcions d'ordre superior

Un altre exemple: Recordem l'[algorisme de
Kadane](https://en.wikipedia.org/wiki/Maximum_subarray_problem) per
resoldre el **_Maximum Segment Sum Problem_**: Sigui V un vector de nombres 
i considerem totes els seus subvectors possibles (fins i tot el buit). Volem trobar
quant suma el subvector amb suma m√†xima. 

Per exemple, si V = [31, -41,
59, 26, -53, 58, 97, -93, -23, 84] el resultat √©s 187, que corresp√≥n al 
subvector [59, 26, -53, 58, 97] (la suma del vector buit √©s zero).

L'algorisme de Kadane √©s un algorisme $\mathcal{O}(n)$ (lineal en la mida del vector) que
resol el problema de manera √≤ptima.

Una implementaci√≥ en Clojure que NO fa servir funcions d'ordre superior:
```Clojure
(defn kadane
  "v √©s un vector de nombres"
  [v]
  (let [mida (count v)]
    (loop [i 0, resultat 0, actual 0, per-tractar v]
      (if (= mida i)
        resultat
        (let [elem-i   (first per-tractar)
              m        (max (+ actual elem-i) 0)] 
          (recur (inc i) (max resultat m) m (rest per-tractar)))))))
```
---

## Funcions d'ordre superior

Podem fer un algorisme _millor_ (m√©s clar, m√©s curt) fent servir funcions d'ordre superior? Al tanto, 
que volem un algorisme que tamb√© sigui lineal $\mathcal{O}(n)$.

```Clojure
(def max0 #(max 0 (+ %1 %2)))

(defn scanr   ;; ja l'hem vist, √©s la mateixa funci√≥
  [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (reductions (flip f) e rlst)))))

(def kadane #(apply max (scanr max0 0 %)))
```

En aquest exemple el paper clau el juga `reductions`, que ens ajuda a definir `scanr`. 

Es pot demostrar que aquest algorisme tamb√© √©s lineal $\mathcal{O}(n)$.

---

## Funcions d'ordre superior

Comparem

```Clojure
(defn kadane
  "v √©s un vector de nombres"
  [v]
  (let [mida (count v)]
    (loop [i 0, resultat 0, actual 0, per-tractar v]
      (if (= mida i)
        resultat
        (let [elem-i   (first per-tractar)
              m        (max (+ actual elem-i) 0)] 
          (recur (inc i) (max resultat m) m (rest per-tractar)))))))
```

amb 

```Clojure
(defn kadane
  "coll √©s un vector de nombres"
  [coll]
  (letfn [(max0 [x y] (max 0 (+ x y)))
          (scanr [f e lst] (letfn [(flip [ff] (fn [x y] (ff y x)))]
                             (let [rlst   (reverse lst)]
                               (reverse (reductions (flip f) e rlst)))))]
    (apply max (scanr max0 0 coll))))
```
---

## Funcions d'ordre superior

Veiem un exemple m√©s: [Ordenaci√≥ per inserci√≥](https://en.wikipedia.org/wiki/Insertion_sort) (_Insertion Sort_)

Recordem el pseudo-codi de l'algorisme.red[*]:

```C
i ‚Üê 1
while i < length(A)
    j ‚Üê i
    while j > 0 and A[j-1] > A[j]
        swap A[j] and A[j-1]
        j ‚Üê j - 1
    end while
    i ‚Üê i + 1
end while
```

√âs un algorisme que dep√©n molt de la _mutabilitat_ de la col¬∑lecci√≥
`A`. A Clojure no √©s trivial traduir aquest pseudo-codi _literalment_.

Per exemple, donada la col¬∑lecci√≥ `A`, fer `swap A[j] and A[j-1]` podria fer-se (suposem que `A`
√©s un vector): `(assoc (assoc A j (A (dec j))) (dec j) (A j))`,
per√≤ no √©s trivial veure si avaluar aquesta expressi√≥ t√© el mateix cost que `swap A[j] and A[j-1]`, que 
√©s constant $\mathcal{O}(1)$.


.footnote[.red[*] [Font](https://en.wikipedia.org/wiki/Insertion_sort)]

---

## Funcions d'ordre superior

[Ordenaci√≥ per inserci√≥](https://en.wikipedia.org/wiki/Insertion_sort) (_Insertion Sort_)

En canvi, des d'un punt de vista _funcional_ l'ordenaci√≥ per inserci√≥ no √©s complicada:

```Clojure
(defn ordenacio-insercio 
  "Retorna una seq√º√®ncia amb els elements de la seq√º√®ncia xs ordenats"
  [xs]
  (letfn [(inserir [col x]
            "suposant que col est√† ordenada, insereix x tot mantenint l'ordre" 
            (concat (take-while #(<= % x) col) [x] (drop-while #(<= % x) col)))]
    (reduce inserir '() xs)))
    
(let [s  (shuffle (range 20))]
   (println s)
   (ordenacio-insercio s))
üëÅÔ∏è [14 9 16 5 17 1 15 8 10 0 12 3 19 7 4 11 18 6 2 13]
üëâ (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)

```

Per√≤ hem d'adaptar l'algorisme al punt de vista _funcional_. L'algorisme tal com est√† descrit
en pseudo-codi a la plana anterior no √©s gaire √∫til, m√©s que per entendre la idea _general_.

---

## Llistes per Comprensi√≥ (_List Comprehension_)

### La macro `for`

En Clojure la macro `for` ens permet processar i generar seq√º√®ncies de manera alternativa a 
les funcions de la _Clojure Sequence Library_.
No √©s un `for` com els que coneixem d'altres llenguatges de programaci√≥ 
(tot i que pot fer-se servir de manera similar en alguns casos).
Les llistes (seq√º√®ncies, en realitat) generades fent servir `for` 
s'anomenen **_llistes per comprensi√≥_**.

En lloc d'intentar fer una descripci√≥ general, veiem alguns exemples:

```Clojure
(for [i [1 2 3 4 5]] (* 2 i)) üëâ (2 4 6 8 10)

(for [i (range 4) j (range 3)] [i j])
üëâ ([0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2] [3 0] [3 1] [3 2])

;; Podem afegir els modificadors :when :while :let

(for [x (range 1 6) :let [y (* x x), z (* x x x)]] [x y z])
üëâ ([1 1 1] [2 4 8] [3 9 27] [4 16 64] [5 25 125])

(for [x (range 3) y (range 3) :when (not= x y)] [x y])
üëâ ([0 1] [0 2] [1 0] [1 2] [2 0] [2 1])

(for [x (range 3) y (range 3) :while (not= x y)] [x y])  ;; !!!
üëâ ([1 0] [2 0] [2 1])
```
---

## Llistes per Comprensi√≥ (_List Comprehension_)

### La macro `for`

La difer√®ncia entre fer servir `:when` i `:while` √©s subtil:

```Clojure
;; Suposem que tenim una funci√≥ prime? ja definida

(for [x (range 3 33 2) :when (prime? x)] x)  üëâ (3 5 7 11 13 17 19 23 29 31)

(for [x (range 3 33 2) :while (prime? x)] x) üëâ (3 5 7)


(for [x (range 3 13 2) :when (prime? x), y (range 3 13 2) :when (prime? y)] 
     [x y])
üëâ ([3 3] [3 5] [3 7] [3 11] [5 3] [5 5] [5 7] [5 11] [7 3] 
    [7 5] [7 7] [7 11] [11 3] [11 5] [11 7] [11 11]) 

(for [x (range 3 13 2) :while (prime? x), y (range 3 13 2) :while (prime? y)] 
     [x y])
üëâ ([3 3] [3 5] [3 7] [5 3] [5 5] [5 7] [7 3] [7 5] [7 7])

```

√âs f√†cil veure que fent servir `for` podem aconseguir el mateix que aconseguim amb algunes
funcions de la _Clojure Sequence Library_. De fet, precisament aix√≤ forma
part dels [exercicis](https://gebakx.github.io/cap/problemes/llistes-comprensio.pdf) 
que corresponen a les sessions de laboratori d'aquest tema.

.small[[Font](https://clojuredocs.org/clojure.core/for)]

---

## Funcions d'ordre superior

### `fold`

Ja hem fet servir les funcions `reduce`/`reductions`. Aquestes funcions s√≥n fonamentals
en programaci√≥ funcional.red[*]. Recordem les definicions de `foldl`/`reduce`, `foldr`, `scanl`/`reductions` i 
`scanr`, i definim `fold`:

```Clojure
;; foldl / foldr / fold
(defn foldl [f x0 s]                 (defn foldr [f x0 s]
  (if (empty? s) x0                    (if (empty? s) x0
      (let [[cap & cua] s]                 (let [[cap & cua] s]
        (recur f (f x0 cap) cua))))          (f cap (foldr f x0 cua)))))

(def fold foldr)

;; scanl / scanr
(defn scanl [f x0 s]                  ;; (def scanl reductions)
  (if (empty? s) (list x0)
      (let [[cap & cua] s]
        (cons x0 (scanl f (f x0 cap) cua)))))
        
(defn scanr [f e lst]
  (letfn [(flip [ff] (fn [x y] (ff y x)))]
    (let [rlst   (reverse lst)]
      (reverse (scanl (flip f) e rlst)))))
```

.footnote[.red[*] 
[_A tutorial on the universality and expressiveness of fold_](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/tutorial-on-the-universality-and-expressiveness-of-fold/CDBAA53C7120E23CBBBE206FD47FDBAA)
]

---

## Funcions d'ordre superior

### `fold`: Processar Seq√º√®ncies

En aquesta sessi√≥ ens centrarem sobre tot en la idea de <ins>_processar seq√º√®ncies_</ins>. 
Molts problemes pr√†ctics es poden pensar en aquests termes,
adequadament combinats amb funcions d'ordre superior.

Ja hem vist exemples de la versatilitat de `reduce`/`foldl`. En aquesta sessi√≥ ens concentrarem en
`fold` (`foldr` en realitat.red[*]).

```Clojure
;; Definim funcions conegudes que *nom√©s* accepten dos arguments:
(def suma #(+ %1 %2))
(def prod #(* %1 %2))
(def and2 #(and %1 %2))
(def or2  #(or %1 %2))

;; Podem definir les funcions de Clojure a partir d'aquestes fent √∫s de fold:
(def suma_generalitzada    (partial fold suma 0))
(def producte_generalitzat (partial fold prod 1))
(def and_generalitzat      (partial fold and2 true))
(def or_generalitzat       (partial fold or2 false))

(suma_generalitzada (range 10)) üëâ 45
(producte_generalitzat (map inc (range 10))) üëâ 3628800 ;; 10!
```

.footnote[.red[*] 
No confondre amb `clojure.core.reducers/fold`, que √©s _una mena de_
`reduce` paral¬∑lelitzable
]

---

## Funcions d'ordre superior

### `fold`: Processar Seq√º√®ncies

Per√≤ aix√≤ nom√©s √©s una mostra molt trivial de les capacitats de `fold`.
Mirem de fer funcions una mica m√©s complicades:

```Clojure
(def mida (partial fold #(inc %2)  0))
(mida '()) üëâ 0
(mida [])  üëâ 0
(mida (range 10))       üëâ 10
(mida (vec (range 10))) üëâ 10

(def invertir (partial fold #(concat %2 [%1]) '()))
(invertir '()) üëâ ()
(invertir []) üëâ ()
(invertir (range 10)) üëâ (9 8 7 6 5 4 3 2 1 0)
(invertir (vec (range 10))) üëâ (9 8 7 6 5 4 3 2 1 0)
(apply str (invertir "Hola M√≥n!")) üëâ "!n√≥M aloH"

(def my-map (fn [f,s] (fold #(cons (f %1) %2) '() s)))
(my-map inc (range 2 15 3)) üëâ (3 6 9 12 15) ;;(range 2 15 3) üëâ (2 5 8 11 14)

(def my-filter (fn [p,s] (fold #(if (p %1) (cons %1 %2) %2) '() s)))
(my-filter even? (range 2 30)) üëâ (2 4 6 8 10 12 14 16 18 20 22 24 26 28)
```

---

## Funcions d'ordre superior

### `fold`: La Propietat Universal

No √©s casualitat que `fold` sigui capa√ß d'expressar tantes operacions diferents. En realitat, 
la definici√≥ de `(foldr ‚äï x0 '(x1 x2 ... xn))` com a `(‚äï x1 (‚äï x2 (...(‚äï xn x0)...)))`
captura un patr√≥ molt freq√ºent en definicions recursives.

Disposant de funcions d'ordre superior, podem expressar una relaci√≥
entre `fold` i aquest patr√≥ de funci√≥ recursiva:

```Clojure
;; Suposem un valor v i una funci√≥ *pura* f, definim la funci√≥ recursiva g:
(defn g [s]
  (if (empty? s) v
    (f (first s) (g (rest s)))))
```

Es pot demostrar que.red[*]:

```Clojure
g = (partial fold f v)              ;; g = fold f v
```
Aquesta relaci√≥ s'anomena **_la propietat universal de fold_**.


.footnote[.red[*] Nom√©s per a llistes de mida finita. Aquesta afirmaci√≥ tindr√† m√©s sentit
a final de curs. Els detalls i demostracions els podeu trobar 
a l'[article](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/tutorial-on-the-universality-and-expressiveness-of-fold/CDBAA53C7120E23CBBBE206FD47FDBAA)
que hem citat abans.]

---

## Funcions d'ordre superior

### `fold`: La Propietat Universal

Veiem un exemple d'aplicaci√≥ d'aquesta propietat:

```Clojure
;; Definici√≥ de map, suposant que no tingu√©ssim map a Clojure (!)
(defn map [ff s]
  (if (empty? s) 
    '()
    (cons (ff (first s)) (map ff (rest s)))))
```
Volem aplicar la propietat universal, caldria trobar quina √©s la `g` en aquest cas.
Considerant que `g` t√© com a argument una seq√º√®ncia `s`, nom√©s podem equiparar
`g` a `(partial map ff)`. En aquest cas, la nostra definici√≥ recursiva de `(partial map ff)` s√≠ 
que t√© l'estructura que requerim de la `g` de la definici√≥ de la plana anterior (suposant, per√≤, que
`ff` √©s pura).

Aleshores, trobar la resta d'elements √©s senzill: El valor `v` seria
`'()`, i la funci√≥ `f` seria `#(cons (ff %1) %2)`.

Per tant, segons la propietat universal, podem afirmar que, si `f` √©s pura:

```Clojure
(partial map f) = (partial fold #(cons (f %1) %2) '()) ;; map f = fold cons¬∑f ()
```
---

## Funcions d'ordre superior

### `fold`: La Propietat de Fusi√≥ (_The fusion property of fold_)

Hi ha altres propietats que ens poden ser √∫tils a l'hora de pensar programes
funcionals. La **_Propietat de Fusi√≥_** diu:

Siguin `h`, `g`, i `f` funcions pures i `w` i `v` valors donats. Si es verifica que:

```Clojure
(h w)       = v                       ;;       h w = v
(h (g x y)) = (f x (h y))             ;; h (g x y) = f x (h y)
```
Aleshores tenim que:

```Clojure
(comp h (partial fold g w)) = (partial fold f v)     ;; h ¬∑ fold g w = fold f v
```

Veiem una aplicaci√≥ de la propietat de fusi√≥ argumentant que, 
donades dues funcions pures `ff` i `gg`:

```Clojure
;; Escrivim en Clojure que: map ff ¬∑ map gg = map (ff¬∑gg)
(comp (partial map ff) (partial map gg)) = (partial map (comp ff gg))
```

.small[**Exercici**: Per qu√® √©s interessant aquesta propietat? Qu√® en traiem nosaltres
de saber que `map f ¬∑ map g = map (f¬∑g)`, per a `f` i `g` pures?]

---

## Funcions d'ordre superior

### `fold`: La Propietat de Fusi√≥ (_The fusion property of fold_)

Continuant amb l'exemple de la plana anterior, caldria identificar els
diferents elements de la definici√≥ de la propietat general de fusi√≥. 
Per fer aix√≤ substituirem a la propietat de fusi√≥ dos dels `map` per 
la seva expressi√≥ en termes de `fold`

```Clojure
(comp (partial map ff) (partial map gg)) = (partial map (comp ff gg))
‚â°
(comp (partial map ff) (partial fold #(cons (gg %1) %2) '())) = 
                                 (partial fold #(cons ((comp ff gg) %1) %2) '())
```

Aqu√≠ √©s, per√≤, on volem arribar. Aquesta expressi√≥ s√≠ que ens permetr√†
identificar tots els elements que apareixen a la formulaci√≥ general de
la propietat:

```Clojure
w ‚áí '()                    v ‚áí '()                    h ‚áí (partial map ff)

g ‚áí #(cons (gg %1) %2)     f ‚áí #(cons ((comp ff gg) %1) %2)
```

Si amb aquestes substitucions es verifica la premisa de la propietat de fusi√≥, aleshores
podrem dir que la igualtat anterior √©s certa gr√†cies a aquesta propietat.

---

## Funcions d'ordre superior

### `fold`: La Propietat de Fusi√≥ (_The fusion property of fold_)

Per a deduir aquesta igualtat amb la propietat de fusi√≥, caldria que es verifiqu√©s
(ara que podem identificar els diferents elements de la premisa):

```Clojure
;; a/ (h w) = v

;;      h          w     v
;;--------------  ---   ---
((partial map ff) '()) = ()

;; b/ (h (g x y)) = (f x (h y))

;;      h                  g
;;--------------   -----------------
((partial map ff) (#(cons (gg %1) %2) x y)) =
                            (#(cons ((comp ff gg) %1) %2) x ((partial map ff) y))
;;                           ---------------------------     ----------------
;;                                       f                           h

```
L'apartat **a/** √©s trivial, ja que `(map f '())` √©s sempre la seq√º√®ncia buida `()`.

L'apartat **b/**: En aquest cas desplegarem les funcions per a valors gen√®rics
d'`x` i d'`y`, i argumentarem que la igualtat es verifica. Ho farem a la pissarra.

---

## Funcions d'ordre superior

### `fold`: _The Scan Lemma_

Podem definir `scanl` i `scanr` en termes de `foldl` i `foldr`? Doncs s√≠!

Definim dues funcions auxiliars `inits` i `tails`:

```Clojure
;; T√©nen sentit amb llistes, strings i vectors, no massa amb maps o conjunts

(defn inits
  [coll]
  (if (not (seq coll)) (seq (list '()))   ;; retorna la seq√º√®ncia (())
    (let [[x & xs] coll]          ;; <=== Heu estudiat el destructuring?
      (concat '(()) (map (partial cons x) (inits xs))))))

(defn tails
  [coll]
  (if (not (seq coll)) (seq (list '()))  ;; retorna la seq√º√®ncia (())
    (let [[_ & xs :as all] coll]  ;; <=== Heu estudiat el destructuring?
      (cons (seq all) (tails xs)))))

(inits '(1 2 3 4 5)) üëâ (() (1) (1 2) (1 2 3) (1 2 3 4) (1 2 3 4 5))
(tails '(1 2 3 4 5)) üëâ ((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5) ())

(inits [:a :b :c]) üëâ (() (:a) (:a :b) (:a :b :c))
(tails [:a :b :c]) üëâ ((:a :b :c) (:b :c) (:c) ())
 
(inits []) üëâ (())                            (tails []) üëâ (())
```

---

## Funcions d'ordre superior

### `fold`: _The Scan Lemma_

Aquestes funcions generen una seq√º√®ncia amb tots els prefixos (`inits`) o tots els 
sufixos (`tails`) d'una seq√º√®ncia determinada.

Aleshores, nom√©s ens cal aplicar `foldl` o `foldr` a cada una de les subseq√º√®ncies,
i per a aix√≤ tenim `map`:

```Clojure
;; Recordem que scanl requereix tres arguments (scanl f e s)
(def scanl' #((comp (partial map (partial foldl %1 %2)) inits) %3)) 

(scanl  #(+ %2 (* 2 %1)) 4 [1 2 3]) üëâ (4 9 20 43)
(scanl' #(+ %2 (* 2 %1)) 4 [1 2 3]) üëâ (4 9 20 43)

(scanl  conj #{} [:a :b :c]) üëâ (#{} #{:a} #{:b :a} #{:c :b :a})
(scanl' conj #{} [:a :b :c]) üëâ (#{} #{:a} #{:b :a} #{:c :b :a})

(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (scanl  (flip cons) '() '(1 2 3 4 5 6))) 
üëâ (() (1) (2 1) (3 2 1) (4 3 2 1) (5 4 3 2 1) (6 5 4 3 2 1))

(letfn [(flip [ff] (fn [x y] (ff y x)))]
   (scanl' (flip cons) '() '(1 2 3 4 5 6)))
üëâ (() (1) (2 1) (3 2 1) (4 3 2 1) (5 4 3 2 1) (6 5 4 3 2 1))
```
---

## Funcions d'ordre superior

### `fold`: _The Scan Lemma_

Aquestes funcions generen una seq√º√®ncia amb tots els prefixos (`inits`) o tots els 
sufixos (`tails`) d'una seq√º√®ncia determinada.

Aleshores, nom√©s ens cal aplicar `foldl` o `foldr` a cada una de les subseq√º√®ncies,
i per a aix√≤ tenim `map`:

```Clojure
;; Recordem que scanr requereix tres arguments (scanr f e s)
(def scanr' #((comp (partial map (partial foldr %1 %2)) tails) %3))

(scanr  - 0 '(1 2 3 4 5)) üëâ (3 -2 4 -1 5 0)
(scanr' - 0 '(1 2 3 4 5)) üëâ (3 -2 4 -1 5 0)

(scanr  / 2 [8,12,24,4]) üëâ (8 1 12 2 2)
(scanr' / 2 [8,12,24,4]) üëâ (8 1 12 2 2)

(scanr  #(/ (+ %1 %2) 2) 54 [12,4,10,6]) üëâ (12 12 20 30 54)
(scanr' #(/ (+ %1 %2) 2) 54 [12,4,10,6]) üëâ (12 12 20 30 54)

```
Encara que hauria de ser obvi, val la pena destacar que, si `f` √©s pura:

`(= (last (scanl f z x))  (foldl f z x)) üëâ true`

`(= (first (scanr f z x)) (foldr f z x)) üëâ true`

---

## Funcions d'ordre superior

### Exemples

* Podem tornar al recorregut en profunditat d'un graf que vam veure
[anteriorment](https://jdelgadopin.github.io/CAP2024-25/s01_02.html#48). Podem fer-lo m√©s _funcional_ aprofitant 
que era iteratiu (podem convertir-lo f√†cilment a recursiu final i aprofitar la TCO que ens proporciona `recur`)
i que ara coneixem la familia `fold`.

---

## Funcions d'ordre superior

### Exemples

* Podem tornar al recorregut en profunditat d'un graf que vam veure
[anteriorment](https://jdelgadopin.github.io/CAP2024-25/s01_02.html#48). Podem fer-lo m√©s _funcional_ aprofitant 
que era iteratiu (podem convertir-lo f√†cilment a recursiu final i aprofitar la TCO que ens proporciona `recur`)
i que ara coneixem la familia `fold`:

La soluci√≥ proposada seria:

```Clojure
(defn recorregut-profunditat
  "graf √©s un graf representat com hem vist a la transpar√®ncia anterior"
  "primer √©s el node del que es parteix per fer el recorregut"
  [graf primer]
  (letfn [(dfs [p vis]
            (cond
              (empty? p)              vis
              (some #{(peek p)} vis)  (recur (pop p) vis)
              :else                   (let [actual (peek p)]
                                        (recur (reduce conj (pop p) (actual graf))
                                               (conj vis actual)))))]
    (dfs [primer] [])))
```

.small[**Exercici**: Compareu aquesta versi√≥ amb la versi√≥ del 
[Tema 1](https://jdelgadopin.github.io/CAP2024-25/s01_02.html#48).
Veureu que no s√≥n tan diferents.]

---

## Funcions d'ordre superior

### Exemples

* Fer una funci√≥ `bin2int` que transformi una seq√º√®ncia de bits (nombres del conjunt {0,1}) en un
nombre enter (el bit de m√©s pes est√† a l'esquerra de la seq√º√®ncia):

```Clojure
(bin2int [1,0,1,1]) üëâ 11

(bin2int [1,0,0,0]) üëâ 8
```

---

## Funcions d'ordre superior

### Exemples

* Fer una funci√≥ `bin2int` que transformi una seq√º√®ncia de bits (nombres del conjunt {0,1}) en un
nombre enter (el bit de m√©s pes est√† a l'esquerra de la seq√º√®ncia):

```Clojure
(bin2int [1,0,1,1]) üëâ 11

(bin2int [1,0,0,0]) üëâ 8
```

* Soluci√≥:

```Clojure
;; Farem servir una expressi√≥ similar a l'avaluaci√≥ d'un polinomi amb Horner

(def bin2int (partial reduce #(+ (* 2 %1) %2) 0))
```

El mateix podr√≠em fer per transformar una seq√º√®ncia de d√≠gits de {0,1,...,9} en un enter (per√≤
fent servir `#(+ (* 10 %1) %2)`).



---

## Funcions d'ordre superior

### Exemples

* Donada una seq√º√®ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funci√≥
que retorni una seq√º√®ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
üëâ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
üëâ ([3 :trump] [5 :harris])

```
---

## Funcions d'ordre superior

### Exemples

* Donada una seq√º√®ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funci√≥
que retorni una seq√º√®ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
üëâ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
üëâ ([3 :trump] [5 :harris])
```
Caldr√† una funci√≥ per comptar quants cops apareix cada valor:

```Clojure
(def comptar (fn [x s] (count (filter (partial = x) s))))

(comptar "Vermell" ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) üëâ 2

(comptar "Groc" ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"])    üëâ 0
```
---

## Funcions d'ordre superior

### Exemples

* Donada una seq√º√®ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funci√≥
que retorni una seq√º√®ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
üëâ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
üëâ ([3 :trump] [5 :harris])

```

Caldr√† una altra funci√≥, auxiliar, per eliminar resultats duplicats:

```Clojure
(defn treu-duplicats [s] 
  (if (empty? s) '()
    (let [[cap & cua] s]
      (cons cap (filter (partial not= cap) (treu-duplicats cua))))))
      
(treu-duplicats ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
üëâ ("Vermell" "Blau" "Verd")
```
---

## Funcions d'ordre superior

### Exemples

* Donada una seq√º√®ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funci√≥
que retorni una seq√º√®ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
üëâ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
üëâ ([3 :trump] [5 :harris])

```

.small[**Exercici**: Fent servir la **propietat universal de `fold`**, demostrar que la funci√≥ `treu-duplicats` que
acabem de fer √©s equivalent a aquesta altra funci√≥ `treu-duplicats'`]

```Clojure
(defn treu-duplicats' [s]
  (fold #(cons %1 (filter (partial not= %1) %2)) '() s))
      
(treu-duplicats' ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
üëâ ("Vermell" "Blau" "Verd")
```
---

## Funcions d'ordre superior

### Exemples

* Donada una seq√º√®ncia amb diferents valors, per exemple
`["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]`, feu una funci√≥
que retorni una seq√º√®ncia amb el nombre de vegades que apareix cada
valor, juntament amb el valor, ordenats creixentment:

```Clojure
(resultat ["Vermell", "Blau", "Verd", "Blau", "Blau", "Vermell"]) 
üëâ ([1 "Verd"] [2 "Vermell"] [3 "Blau"])

(resultat [:trump, :trump, :harris, :harris, :harris, :harris, :harris, :trump])
üëâ ([3 :trump] [5 :harris])

```

* Amb aquestes funcions ja podem construir la funci√≥ `resultat`:

```Clojure
(defn resultat [s]
  (sort (for [v (treu-duplicats s)] [(comptar v s) v])))
```

En tenim prou ordenant una llista per comprensi√≥ que ens doni els resultats desitjats.

---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica m√©s gran: Volem una funci√≥ que, donada una seq√º√®ncia, retorni totes
les **permutacions** possibles d'aquesta seq√º√®ncia.

L'enfocament que farem √©s el seg√ºent: Suposem que tenim totes les permutacions possibles de la
seq√º√®ncia donada, _menys el primer element_. Com trobar√≠em totes les permutacions possibles? La soluci√≥
√©s senzilla: Nom√©s cal inserir el primer element a totes les permutacions que tenim, de totes les
maneres possibles.

Per exemple: Volem calcular `(perms [1 2 3])`, el resultat ha de ser `((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))`.

Imaginem que tenim ja calculat `(perms [2 3])`, √©s a dir, `((2 3) (3 2))`.

Nom√©s caldria inserir l'`1` de totes les maneres possibles a `(2 3)`: `((1 2 3) (2 1 3) (2 3 1))`, i tamb√©
fer-ho a `(3 2)`: `((1 3 2) (3 1 2) (3 2 1))`. N'hi hauria prou concatenant aquestes dues seq√º√®ncies
per obtenir el resultat final `((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))`.

---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica m√©s gran: Volem una funci√≥ que, donada una seq√º√®ncia, retorni totes
les **permutacions** possibles d'aquesta seq√º√®ncia.

Suposem que tenim una funci√≥ `(inserts elem seq)` que fa precisament aix√≤, inserir `elem` a `seq` de totes
les maneres possibles. En aquest cas n'hi hauria prou fent:

```Clojure
(map (partial inserts 1) (perms [2 3])) 
üëâ ( ((1 2 3) (2 1 3) (2 3 1)) ((1 3 2) (3 1 2) (3 2 1)) )

;; i ara fem la concatenaci√≥:
(apply concat '( ((1 2 3) (2 1 3) (2 3 1)) ((1 3 2) (3 1 2) (3 2 1)) ))
üëâ ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))
```

Aix√≠ doncs, definirem primer `inserts`...

---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica m√©s gran: Volem una funci√≥ que, donada una seq√º√®ncia, retorni totes
les **permutacions** possibles d'aquesta seq√º√®ncia.

La idea √©s partir d'haver inserit l'element a la cua de la seq√º√®ncia, i afegir-hi el primer
element de la seq√º√®ncia despr√©s:

```Clojure
(defn inserts
  "Insereix de totes les maneres possibles l'element x a la seq√º√®ncia s"
  [x s]
  (if (empty? s) (list (list x))
      (let [[cap & cua]          s
            resultat-parcial     (inserts x cua)]
        (cons (cons x s) (map (partial cons cap) resultat-parcial)))))

;;(inserts 0 [1,2,3,4]) 
;;         - ---------
;;         x     s
;; üëâ ((0 1 2 3 4) (1 0 2 3 4) (1 2 0 3 4) (1 2 3 0 4) (1 2 3 4 0))
;;     ----------- -----------------------------------------------
;;     (cons x s)     (map (partial cons cap) resultat-parcial)
;;
;; ja que:
;;(inserts 0 [2,3,4]) üëâ ((0 2 3 4) (2 0 3 4) (2 3 0 4) (2 3 4 0))
;;                        ---------------------------------------
;;                         resultat-parcial = (inserts 0 [2,3,4])
```
---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica m√©s gran: Volem una funci√≥ que, donada una seq√º√®ncia, retorni totes
les **permutacions** possibles d'aquesta seq√º√®ncia.

Ara ja podem definir `perms` tal com l'hem descrit abans:

```Clojure
(defn perms
  "Calcular una seq√º√®ncia amb totes les permutacions d's"
  [s]
  (if (empty? s) '(())
    (let [[cap & cua]  s
          perms-cua    (perms cua)]
      (apply concat (map (partial inserts cap) perms-cua)))))
      
;;(perms [1 2 3]) üëâ ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))
;;
;;com la crida recursiva fa (perms [2 3]) üëâ ((2 3) (3 2))
;;
;; aleshores nom√©s ens cal:
;;(map (partial inserts 1) (perms [2 3])) 
;; üëâ ( ((1 2 3) (2 1 3) (2 3 1)) ((1 3 2) (3 1 2) (3 2 1)) )
;;
;; i finalment:
;;(apply concat '( ((1 2 3) (2 1 3) (2 3 1)) ((1 3 2) (3 1 2) (3 2 1)) ))
;; üëâ ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))
```
---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica m√©s gran: Volem una funci√≥ que, donada una seq√º√®ncia, retorni totes
les **permutacions** possibles d'aquesta seq√º√®ncia.

Les dues funcions que hem fet, `perms` i l'auxiliar `inserts` **_tamb√©_** es poden expressar en termes de
`fold` (üòµ‚Äçüí´üß†!).

Farem servir una funci√≥ que resultar√† molt √∫til, no nom√©s per a aquest exemple, `concatMap`:

```Clojure
;; Suposem que f √©s pura, i que el resultat d'aplicar f √©s una seq√º√®ncia:
;; concatMap f = concat ¬∑ (map f)
;;
(def concatMap  #((comp (partial apply concat) (partial map %1)) %2))

(concatMap #(map inc (range %1)) [1 2 3 4]) üëâ (1 1 2 1 2 3 1 2 3 4)

;; ja que (map #(map inc (range %1)) [1 2 3 4]) üëâ ((1) (1 2) (1 2 3) (1 2 3 4))
;; i (apply concat '((1) (1 2) (1 2 3) (1 2 3 4))) üëâ (1 1 2 1 2 3 1 2 3 4)

```
---

## Funcions d'ordre superior

### Exemples

* Veiem un exemple una mica m√©s gran: Volem una funci√≥ que, donada una seq√º√®ncia, retorni totes
les **permutacions** possibles d'aquesta seq√º√®ncia.

Finalment:

```Clojure
(defn inserts
  "versi√≥ d'inserts amb fold"
  [x s]
  (letfn [(step [y yss] ;; dep√©n del fet que (first (inserts x ys)) = (cons x ys)
            (let [ys   (rest (first yss))]
              (cons (cons x (cons y ys)) (map (partial cons y) yss))))]
    (fold step (list (list x)) s)))

(defn perms
  "versi√≥ de perms amb fold"
  [s]
  (letfn [(step [x xss]
            (concatMap (partial inserts x) xss))]
    (fold step '(()) s)))
    
(inserts 0 [1 2 3]) üëâ ((0 1 2 3) (1 0 2 3) (1 2 0 3) (1 2 3 0))

(perms [1 2 3]) üëâ ((1 2 3) (2 1 3) (2 3 1) (1 3 2) (3 1 2) (3 2 1))
```
.small[**Exercici**: Analitzeu aquestes funcions fins entendre-les b√©]

---

## Funcions d'ordre superior

<br>

Portem algunes classes parlant de Funcions _First Class_ i de *Funcions
d'Ordre Superior*, per√≤ nom√©s les hem fet servir com a argument
d'altres funcions.


Aix√≤ ha estat _deliberat_: **Les funcions en Clojure no s√≥n _nom√©s_ funcions**. Quan definim
funcions amb altres funcions com a par√†metre podem ignorar aquest fet, ja que les funcions amb les 
que hem treballat fins ara s√≥n essencialment pures (tret d'algun `println` que hem fet servir).


Sense sortir del tema de _Funcions d'Ordre Superior_, voldrem posar √®mfasi ara en el fet que **_les 
funcions poden retornar funcions_**. I aqu√≠ ja no podem passar per alt el fet que les funcions s√≥n en
realitat _closures_. En el proper tema comen√ßarem a parlar de **_Closures_**
