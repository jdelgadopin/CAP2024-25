class: center, up

# CAP - T√®cniques de Programaci√≥ amb FOS

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 4</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## T√®cniques de Programaci√≥ amb FOS

En aquest tema veurem t√®cniques de programaci√≥ fortament lligades al fet de tenir _Funcions d'Ordre 
Superior_ (FOS). En alguns casos seran t√®cniques noves, que encara no hem vist, i en alguns casos ens
limitarem a posar nom a t√®cniques que ja hem fet servir en posar exemples dins els dos temes anteriors.

Comen√ßarem per una t√®cnica que ja hem vist quan hem insistit en fer servir el _point-free style_ 
o _Tacit programming_, √©s a dir, en definir funcions a partir de la composici√≥ d'altres funcions. 
En fer servir aquest estil sovint no cal fer expl√≠cits els par√†metres (d'aqu√≠ l'expressi√≥ _point-free_).

Definir funcions fent servir la composici√≥ de funcions s'anomena **_pipelining_**. A Clojure, la funci√≥
`comp`, juntament amb la possibilitat de definir funcions _parcials_ fent servir `partial`, ens 
permet fer servir molt f√†cilment aquesta t√®cnica.

Al [laboratori](https://gebakx.github.io/cap/problemes/first-class.pdf) heu tingut ocasi√≥ de 
practicar el _pipelining_, per exemple:

```Clojure
(def prod-of-evens (comp (partial apply *) (partial filter even?)))

(def scalar-product (comp (partial apply +) (partial map *)))
```


---

## _Pipelining_

Un altre exemple, l'[exercici 4](https://gebakx.github.io/cap/firstClass.html#18) de la sessi√≥ de 
[Funcions _First-Class_](https://gebakx.github.io/cap/firstClass.html) podr√≠em haver-lo resolt
aix√≠:

```Clojure
;; Escriu una funci√≥ que, donat un vector de maps amb les claus :preu i 
;; :quantitat, calculi el total per cada element (preu * quantitat), elimini 
;; els que tinguin un valor total inferior a 100 i sumi tots els totals.

(def exercici4 (comp (partial apply +) 
                     (partial filter #(< 100 %)) 
                     (partial map #(* (:preu %) (:quantitat %)))))
```


De vegades, per√≤, tot i tenint ocasi√≥ de fer servir el _pipelining_ no l'hem utilitzat. Si
recordeu la versi√≥ funcional de l'[algorisme de Kadane](https://jdelgadopin.github.io/CAP2024-25/s03_04.html#27):
```Clojure
(def kadane #(apply max (scanr max0 0 %)))
```
podr√≠em haver-ho definit:
```Clojure
(def kadane (comp (partial apply max) (partial scanr max0 0)))
```
---

##_Pipelining_: El Patr√≥

El mateix concepte de _pipeline_ √©s considerat un patr√≥ de disseny.red[*]

_The Pipeline pattern organizes a series of computational steps so
that each step handles a specific aspect of processing. In Clojure,
this translates well due to its functional programming paradigm that
supports higher-order functions and data immutability._

```Clojure
;; Segons el lloc web font d'aquesta transpar√®ncia...

(defn run-pipeline [data & steps]
  (reduce (fn [d step] (step d)) data steps))
```
Us [sona](https://jdelgadopin.github.io/CAP2024-25/s05_06.html#33)?... √âs for√ßa similar
al `my-comp` que vam definir el tema passat.

```Clojure
(defn my-comp [& funcs]
  "funcs: llista de funcions d'un par√†metre tals que 't√© sentit' composar-les"
  (fn [arg] 
      "arg ha de pert√†nyer al domini de la darrera funci√≥ de funcs"
      (fold #(%1 %2) arg funcs)))
```

.footnote[.red[*] [Pipeline in Clojure](https://softwarepatternslexicon.com/patterns-clojure/behavioral/pipeline/)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Suposem que tenim funcions `f1`,`f2`,...,`fn` amb `k1`,`k2`,..., `kn` par√†metres cada una (`ki` > 0).
Per expressar:

```Clojure
(fn ... (f2 (f1 x ...) ...) ...)
```
Podem fer servir `->`, on es passa com a _primer_ argument el resultat de l'aplicaci√≥ de
la funci√≥ anterior:

```Clojure
  (-> x (f1 ...)  ;; on ... representa els k1-1 arguments restants d'f1
        (f2 ...)  ;; on ... representa els k2-1 arguments restants d'f2
        ...
        (fn ...)) ;; on ... representa els kn-1 arguments restants d'fn
```
Si alguna de les funcions `fi` t√© un sol par√†metre, no cal fer servir par√®ntesi, nom√©s
cal escriure el nom.

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Veiem-ne exemples (fixem-nos que no cal escriure `partial`):

```Clojure
(* (+ (- (/ 2 1) 3) 4 )5)      üëâ 15
(-> 2 (/ 1) (- 3) (+ 4) (* 5)) üëâ 15 

(str (str (str "Aix√≤" " " "√©s" " ") 
          "un" " " "exemple" " " "de") 
     " " "la" " " "macro" " " "->")   üëâ "Aix√≤ √©s un exemple de la macro ->"
(->
 (str "Aix√≤" " " "√©s" " ")
 (str "un" " " "exemple" " " "de")
 (str " " "la" " " "macro" " " "->")) üëâ "Aix√≤ √©s un exemple de la macro ->"
 
(.toUpperCase (first ["pollastre" "xai"]))  üëâ "POLLASTRE"
(-> ["pollastre" "xai"] first .toUpperCase) üëâ "POLLASTRE"
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Seguim amb exemples:

```Clojure
(assoc (assoc (assoc {} :clau1 24) :clau2 36) :clau3 48) 
üëâ {:clau1 24, :clau2 36, :clau3 48}
(-> {}
    (assoc :clau1 24)
    (assoc :clau2 36)
    (assoc :clau3 48)) üëâ {:clau1 24, :clau2 36, :clau3 48}
    
(conj (conj (conj [] 3) 5) 7) üëâ [3 5 7]
(-> []
    (conj 3)
    (conj 5)
    (conj 7)) üëâ [3 5 7]
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-last_ (->>)

Suposem que tenim funcions `f1`,`f2`,...,`fn` amb `k1`,`k2`,..., `kn` par√†metres cada una (`ki` > 0).
Per expressar:

```Clojure
(fn ... (f2 ... (f1 ... x)))
```
Podem fer servir `->>`, on es passa com a _darrer_ argument el resultat de l'aplicaci√≥ de
la funci√≥ anterior:

```Clojure
  (->> x (f1 ...)  ;; on ... representa els k1-1 arguments restants d'f1
         (f2 ...)  ;; on ... representa els k2-1 arguments restants d'f2
         ...
         (fn ...)) ;; on ... representa els kn-1 arguments restants d'fn
```
Si alguna de les funcions `fi` t√© un sol par√†metre, no cal fer servir par√®ntesi, nom√©s
cal escriure el nom.

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-last_ (->>)

Veiem-ne exemples (fixem-nos que no cal escriure `partial`):

```Clojure
(reduce + (map #(* % %) (filter odd? (range 10)))) üëâ 165
(->> (range 10)
     (filter odd?)
     (map #(* % %))
     (reduce +)) üëâ 165
     
(def prod-of-evens (comp (partial apply *) (partial filter even?)))
(defn prod-of-evens' [s]
  (->> s
       (filter even?)
       (apply *)))
(prod-of-evens  (range 1 21)) üëâ 3715891200
(prod-of-evens' (range 1 21)) üëâ 3715891200
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Exercicis Recapitulatoris

* Considereu una seq√º√®ncia de parells `'[(n1,n2) (n3,n4) ...]` que
  implementa les arestes d'un graf no dirigit (no hi ha arestes
  repetides ni auto-bucles). Feu una funci√≥ `grau` que calculi el grau
  d'un vertex donat. Els vertexos es representen amb nombres.

* Sobre la mateixa representaci√≥ de les arestes d'un graf no dirigit,
  feu ara una funci√≥ `ve√Øns` que retorni els ve√Øns d‚Äôun v√®rtex donat,
  en ordre creixent.

* Donats dos vectors d‚Äôenters `x=(x1,...,xn)` i `y=(y1,...,yn)` de la
  mateixa mida, el seu producte escalar √©s `(apply + (map * x y))`.
  Suposant que podem permutar les coordenades de cada vector de la
  forma que volguem, podem escollir dues permutacions dels dos vectors
  que tinguin producte escalar m√≠nim. Escriviu una funci√≥ `minProd`
  que, donats dos vectors de la mateixa mida, retorni el seu producte
  escalar m√≠nim.
  
* Feu una funci√≥ `zerosNones` que, donat un `n ‚â• 0`,
  retorni totes les combinacions de `z` zeros i `u` uns tals que `z + u = n`

* Els divisors propis d‚Äôun nombre `n` s√≥n tots els divisors positius de `n` m√©s petits que `n`.
  Feu una funci√≥ `divisors` _eficient_ que retorni tots els divisors propis d'un nombre `n`
  ordenats decreixentment.

---

## _Pipelining_

Finalment, feu una ullada a aquest video: **The Power of Function
Composition**, per Conor Hoekstra al congr√©s _Lambda World 2024_, com a m√≠nim fins
el minut **27:30**. 

Tot i que el podeu veure tot, ja que √©s for√ßa
interessant i veureu _en acci√≥_ llenguatges de programaci√≥ que
segurament no coneixeu.

.center[![:scale 90%](figures/lambda2024video.png)]

El podeu trobar a [youtube.com/watch?v=W7fjzdEJnvY](https://www.youtube.com/watch?v=W7fjzdEJnvY)

---

## _Continuation-Passing Style_ (CPS)

A la [Wikipedia](https://en.wikipedia.org/wiki/Continuation-passing_style) diu:

_In functional programming, **continuation-passing style** (CPS) is a
style of programming **in which control is passed explicitly in the form
of a continuation**. This is contrasted with direct style, which is the
usual style of programming. Gerald Jay Sussman and Guy L. Steele, Jr.
coined the phrase in AI Memo 349 (1975)_

Una funci√≥ escrita en CPS requereix un par√†metre addicional: Una
**_continuaci√≥_ expl√≠cita**, que √©s una funci√≥ d'un par√†metre.

Les funcions en CPS <ins>_no retornen mai_</ins>. Un cop han acabat de calcular el que sigui
que calculin, <ins>_cal invocar la continuaci√≥ amb aquest resultat_</ins>. Per exemple:

```Clojure
;; La funci√≥ identitat, en CPS
(defn identity-cps [x,cont]
  (cont x))
  
(identity-cps "Hola M√≥n!", identity) üëâ "Hola M√≥n!"
(identity-cps "Hola M√≥n!", #(apply str (concat % " Josep"))) üëâ "Hola M√≥n! Josep"
```

---

## _Continuation-Passing Style_: Exemples

Veiem alguns exemples una miqueta m√©s interessants que la `identity-cps`:

El factorial:
```Clojure
(defn fact-cps [n cont]
  (if (< n 2)
    (cont 1)
    (recur (dec n) (fn [m]
                     (cont (* n m))))))

(fact-cps  5 identity) üëâ 120
(fact-cps 10 identity) üëâ 3628800
(fact-cps 10 #(/ % 2)) üëâ 1814400
```
El coeficient binomial $\binom{n}{k} = \frac{n!}{k!(n-k)!}$
```Clojure
(defn binomial-coef-cps [n k cont]
  (fact-cps n (fn [factn]
                (fact-cps k 
                    (fn [factk]
                      (fact-cps (- n k) 
                          (fn [factnk] (cont (/ factn (* factk factnk))))))))))
                    
(binomial-coef-cps 7 4 identity) üëâ 35
(binomial-coef-cps 6 3 identity) üëâ 20
```
---

## _Continuation-Passing Style_: Exemples

Sigui $n$ qualsevol natural estrictament positiu. Considereu el proc√©s
seg√ºent: Si $n$ √©s parell, dividiu-lo per dos. Altrament,
multipliqueu-lo per 3 i sumeu-li 1. Quan arribeu a 1, pareu.

Per exemple, comen√ßant en $n=3$, s‚Äôobt√© la seq√º√®ncia de Collatz $S(3):
3,10,5,16,8,4,2,1$. La mida d‚Äôaquesta seq√º√®ncia √©s 7. Des de l‚Äôany 1937 es conjectura que aquest proc√©s acaba per a
qualsevol $n$ inicial, encara que no ho ha sabut demostrar ning√∫. En
aquest problema suposarem que la conjectura √©s certa.

Escriu una funci√≥ `mida-collatz` que, donat un natural $n > 0$, retorni
la mida de la seq√º√®ncia de Collatz corresponent a $n$, √©s a dir, quantes
iteracions del proc√©s descrit m√©s amunt calen per arribar a 1.

.cols5050[
.col1[
```Clojure
(defn mida-collatz [n]
  (if (== n 1) 0
    (let [nxt (if (zero? (mod n 2)) 
                (quot n 2) 
                (inc (* 3 n)))]
      (inc (mida-collatz nxt)))))

(mida-collatz 97)  üëâ 118
(mida-collatz 871) üëâ 178
```
]
.col2[
```Clojure
(defn mida-collatz-cps [n cont]
  (if (== n 1) (cont 0)
    (let [nxt (if (zero? (mod n 2)) 
                (quot n 2) 
                (inc (* 3 n)))]
      (recur nxt (fn [v] 
                   (cont (inc v)))))))

(mida-collatz-cps 97 identity)  üëâ 118
(mida-collatz-cps 871 identity) üëâ 178
```
]]

---

## _Continuation-Passing Style_: Exemples

.cols5050[
.col1[
```Clojure
(defn fibonacci [n]
  (if (< n 2) n
    (+ (fibonacci (dec n)) 
       (fibonacci (- n 2)))))

(fibonacci 10) üëâ 55
(fibonacci 40) üëâ 102334155
```
]
.col2[
```Clojure
(defn fibonacci-cps [n cont]
  (if (< n 2) (cont n)
    (recur (dec n) 
       (fn [fn1] 
         (fibonacci-cps (- n 2) 
            (fn [fn2] 
              (cont (+ fn1 fn2))))))))
               
(fibonacci-cps 10 identity) üëâ 55
(fibonacci-cps 40 identity)
üëâ Execution error (StackOverflowError)
```
]]

Aix√≠ doncs, despr√©s de veure aquests exemples la idea hauria d'estar clara: Fer
expl√≠cit el "_lloc_" on aniran a parar els resultats de tot all√≤ que
es calcula, √©s a dir, en realitat **_fem expl√≠cit el flux de
control del programa_**. All√≤ que anomenem **_continuaci√≥_** no √©s m√©s
que la funci√≥ que rebr√† el resultat del que sigui que calculi la
funci√≥ en q√ºesti√≥, aquella a la que se li ha passat la continuaci√≥ com
a argument.

Cal fixar-se en el detall que **_en CPS totes les invocacions de la continuaci√≥ sempre es
fan en tail position_**. Aix√≤ √©s precisament perqu√® la continuaci√≥ rep el valor final
d'all√≤ que es vol calcular, no cal fer cap proc√©s posterior.

---

## _Continuation-Passing Style_: _Tail Call Optimization_

Aquest estil de programar √©s poc llegible, farrag√≥s i per tant els
programadors _humans_ no l'acostumen a fer servir. El quid de la
q√ºesti√≥, per√≤, √©s que la conversi√≥ de codi _normal_ a codi en CPS es
pot programar, √©s a dir, automatitzar. Aix√≤ fa que el CPS s'hagi fet servir
sobre tot com a representaci√≥ interm√®dia per a eines que han de
manipular codi de manera autom√†tica, p.ex. compiladors.

Malgrat tot, en Clojure tenim un problema... la relaci√≥ entre CPS & TCO.red[*]:

_Every call in CPS is a tail call, and the continuation is explicitly
passed. **Using CPS without tail call optimization (TCO) will cause not
only the constructed continuation to potentially grow during
recursion, but also the call stack. This is usually undesirable**, but
has been used in interesting ways -see the Chicken Scheme compiler. As
CPS and TCO eliminate the concept of an implicit function return,
their combined use can eliminate the need for a run-time stack._

A Clojure podem resoldre-ho quan la crida √©s recursiva final, aleshores podem fer
servir `recur`, i tot i aix√≤ no podrem aplicar TCO a la crida a la continuaci√≥.
En altre cas, per√≤, no hi ha TCO. Ho hem vist amb l'exemple del
`fibonacci-cps`.

.footnote[.red[*] [Font](https://en.wikipedia.org/wiki/Continuation-passing_style)]

---

## _Continuation-Passing Style_: Exercicis Recapitulatoris

Encara que en Clojure el CPS no √©s especialment √∫til...

* Feu versions CPS de `my-map`, `my-filter`, i `my-reduce`, considerant que podeu partir de
les seg√ºents implementacions:

```Clojure
(defn my-map [f s]
  (if (empty? s) '()
      (let [[cap & cua] s]
        (cons (f cap) (my-map f cua)))))

(defn my-filter [p s]
  (if (empty? s) '()
      (let [[cap & cua] s]
        (if (p cap)
          (cons cap (my-filter p cua))
          (my-filter p cua)))))

(defn my-reduce [f x0 s]
  (if (empty? s) x0
      (let [[cap & cua] s]
        (recur f (f x0 cap) cua))))
```

---

## _Continuation-Passing Style_

Alguns enlla√ßos interessants:

* [pulley.cps](https://github.com/positronic-solutions/pulley.cps)
  _is part of the pulley collection of libraries. It
  provides a source-to-source compiler for **transforming normal Clojure
  code to Clojure code in Continuation Passing Style (CPS)**, as well as
  runtime support for executing the transformed code._
  
* [Cascade](https://github.com/lilactown/cascade) _is a library of
  continuation-passing, thunk producing versions of many Clojure core
  functions. The goal is to allow essentially unbounded recursion and
  mutual recursion of seq operations. This means that the seq
  operations in this library must not use the call stack. Instead,
  **they use a combination of continuation-passing to ensure that
  operations can always be in the tail position** and trampolining to
  ensure that operations do not use the call stack._
  
* [Rama on Clojure‚Äôs terms, and the magic of continuation-passing style](https://blog.redplanetlabs.com/2024/10/10/rama-on-clojures-terms-and-the-magic-of-continuation-passing-style/)
  (10 d'octubre de 2024) Nathan Marz, Blog Red Planet Labs.

---

## _Continuation-Passing Style_

Si voleu llegir m√©s sobre el _Continuation-Passing Style_ (per√≤ no en Clojure):

.cols5050[
.col1[
![:scale 70%](figures/compiling.jpg)

.small[[Compiling with Continuations](https://doi.org/10.1017/CBO9780511609619)]
]
.col2[
![:scale 85%](figures/essentials.jpg)

.small[[Essentials of Programming Languages 3rd.ed.](https://eopl3.com/) Una de les principals
difer√®ncies entre les tres edicions √©s precisament l'algorisme per transformar codi a CPS]
]
]


  
