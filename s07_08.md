class: center, up

# CAP - T√®cniques de Programaci√≥ amb FOS

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 7 i 8</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# Sessi√≥ 07

---

## T√®cniques de Programaci√≥ amb FOS

En aquest tema veurem t√®cniques de programaci√≥ fortament lligades al fet de tenir _Funcions d'Ordre 
Superior_ (FOS). En alguns casos seran t√®cniques noves, que encara no hem vist, i en alguns casos ens
limitarem a posar nom a t√®cniques que ja hem fet servir en posar exemples dins els dos temes anteriors.

Comen√ßarem per una t√®cnica que ja hem vist quan hem insistit en fer servir el _point-free style_ 
o _Tacit programming_, √©s a dir, en definir funcions a partir de la composici√≥ d'altres funcions. 
En fer servir aquest estil sovint no cal fer expl√≠cits els par√†metres (d'aqu√≠ l'expressi√≥ _point-free_).

Definir funcions fent servir la composici√≥ de funcions s'anomena **_pipelining_**. A Clojure, la funci√≥
`comp`, juntament amb la possibilitat de definir funcions _parcials_ fent servir `partial`, ens 
permet fer servir molt f√†cilment aquesta t√®cnica.

Al [laboratori](https://gebakx.github.io/cap/problemes/first-class.pdf) heu tingut ocasi√≥ de 
practicar el _pipelining_, per exemple:

```Clojure
(def prod-of-evens (comp (partial apply *) (partial filter even?)))

(def scalar-product (comp (partial apply +) (partial map *)))
```


---

## _Pipelining_

Un altre exemple, l'[exercici 4](https://gebakx.github.io/cap/firstClass.html#17) de la sessi√≥ de 
[Funcions _First-Class_](https://gebakx.github.io/cap/firstClass.html) podr√≠em haver-lo resolt
aix√≠:

```Clojure
;; Escriu una funci√≥ que, donat un vector de maps amb les claus :preu i 
;; :quantitat, calculi el total per cada element (preu * quantitat), elimini 
;; els que tinguin un valor total inferior a 100 i sumi tots els totals.

(def exercici4 (comp (partial apply +) 
                     (partial filter #(< 100 %)) 
                     (partial map #(* (:preu %) (:quantitat %)))))
```


De vegades, per√≤, tot i tenint ocasi√≥ de fer servir el _pipelining_ no l'hem utilitzat. Si
recordeu la versi√≥ funcional de l'[algorsime de Kadane](https://jdelgadopin.github.io/CAP2024-25/s03_04.html#27):
```Clojure
(def kadane #(apply max (scanr max0 0 %)))
```
podr√≠em haver-ho definit:
```Clojure
(def kadane (comp (partial apply max) (partial scanr max0 0)))
```
---

##_Pipelining_: El Patr√≥

El mateix concepte de _pipeline_ √©s considerat un patr√≥ de disseny.red[*]

_The Pipeline pattern organizes a series of computational steps so
that each step handles a specific aspect of processing. In Clojure,
this translates well due to its functional programming paradigm that
supports higher-order functions and data immutability._

```Clojure
;; Segons el lloc web font d'aquesta transpar√®ncia...

(defn run-pipeline [data & steps]
  (reduce (fn [d step] (step d)) data steps))
```
Us [sona](https://jdelgadopin.github.io/CAP2024-25/s05_06.html#35)?... √âs for√ßa similar
al `my-comp` que vam definir la sessi√≥ passada.

```Clojure
(defn my-comp [& funcs]
  "funcs: llista de funcions d'un par√†metre tals que 't√© sentit' composar-les"
  (fn [arg] 
      "arg ha de pert√†nyer al domini de la darrera funci√≥ de funcs"
      (fold #(%1 %2) arg funcs)))
```

.footnote[.red[*] [Pipeline in Clojure](https://softwarepatternslexicon.com/patterns-clojure/behavioral/pipeline/)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Suposem que tenim funcions `f1`,`f2`,...,`fn` amb `k1`,`k2`,..., `kn` par√†metres cada una (`ki` > 0).
Per expressar:

```Clojure
(fn ... (f2 (f1 x ...) ...) ...)
```
Podem fer servir `->`, on es passa com a _primer_ argument el resultat de l'aplicaci√≥ de
la funci√≥ anterior:

```Clojure
  (-> x (f1 ...)  ;; on ... representa els k1-1 arguments restants d'f1
        (f2 ...)  ;; on ... representa els k2-1 arguments restants d'f2
        ...
        (fn ...)) ;; on ... representa els kn-1 arguments restants d'fn
```
Si alguna de les funcions `fi` t√© un sol par√†metre, no cal fer servir par√®ntesi, nom√©s
cal escriure el nom.

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Veiem-ne exemples (fixem-nos que no cal escriure `partial`):

```Clojure
(* (+ (- (/ 2 1) 3) 4 )5)      üëâ 15
(-> 2 (/ 1) (- 3) (+ 4) (* 5)) üëâ 15 

(str (str (str "Aix√≤" " " "√©s" " ") 
          "un" " " "exemple" " " "de") 
     " " "la" " " "macro" " " "->")   üëâ "Aix√≤ √©s un exemple de la macro ->"
(->
 (str "Aix√≤" " " "√©s" " ")
 (str "un" " " "exemple" " " "de")
 (str " " "la" " " "macro" " " "->")) üëâ "Aix√≤ √©s un exemple de la macro ->"
 
(.toUpperCase (first ["pollastre" "xai"]))  üëâ "POLLASTRE"
(-> ["pollastre" "xai"] first .toUpperCase) üëâ "POLLASTRE"
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Seguim amb exemples:

```Clojure
(assoc (assoc (assoc {} :clau1 24) :clau2 36) :clau3 48) 
üëâ {:clau1 24, :clau2 36, :clau3 48}
(-> {}
    (assoc :clau1 24)
    (assoc :clau2 36)
    (assoc :clau3 48)) üëâ {:clau1 24, :clau2 36, :clau3 48}
    
(conj (conj (conj [] 3) 5) 7) üëâ [3 5 7]
(-> []
    (conj 3)
    (conj 5)
    (conj 7)) üëâ [3 5 7]
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-last_ (->>)

Suposem que tenim funcions `f1`,`f2`,...,`fn` amb `k1`,`k2`,..., `kn` par√†metres cada una (`ki` > 0).
Per expressar:

```Clojure
(fn ... (f2 ... (f1 ... x)))
```
Podem fer servir `->>`, on es passa com a _darrer_ argument el resultat de l'aplicaci√≥ de
la funci√≥ anterior:

```Clojure
  (->> x (f1 ...)  ;; on ... representa els k1-1 arguments restants d'f1
         (f2 ...)  ;; on ... representa els k2-1 arguments restants d'f2
         ...
         (fn ...)) ;; on ... representa els kn-1 arguments restants d'fn
```
Si alguna de les funcions `fi` t√© un sol par√†metre, no cal fer servir par√®ntesi, nom√©s
cal escriure el nom.

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-last_ (->>)

Veiem-ne exemples (fixem-nos que no cal escriure `partial`):

```Clojure
(reduce + (map #(* % %) (filter odd? (range 10)))) üëâ 165
(->> (range 10)
     (filter odd?)
     (map #(* % %))
     (reduce +)) üëâ 165
     
(def prod-of-evens (comp (partial apply *) (partial filter even?)))
(defn prod-of-evens' [s]
  (->> s
       (filter even?)
       (apply *)))
(prod-of-evens  (range 1 21)) üëâ 3715891200
(prod-of-evens' (range 1 21)) üëâ 3715891200
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Exercicis Recapitulatoris

* Considereu una seq√º√®ncia de parells `'[(n1,n2) (n3,n4) ...]` que
  implementa les arestes d'un graf no dirigit (no hi ha arestes
  repetides ni auto-bucles). Feu una funci√≥ `grau` que calculi el grau
  d'un vertex donat. Els vertexos es representen amb nombres.

* Sobre la mateixa representaci√≥ de les arestes d'un graf no dirigit,
  feu ara una funci√≥ `ve√Øns` que retorni els ve√Øns d‚Äôun v√®rtex donat,
  en ordre creixent.

* Donats dos vectors d‚Äôenters `x=(x1,...,xn)` i `y=(y1,...,yn)` de la
  mateixa mida, el seu producte escalar √©s `(apply + (map * x y))`.
  Suposant que podem permutar les coordenades de cada vector de la
  forma que volguem, podem escollir dues permutacions dels dos vectors
  que tinguin producte escalar m√≠nim. Escriviu una funci√≥ `minProd`
  que, donats dos vectors de la mateixa mida, retorni el seu producte
  escalar m√≠nim.
  
* Feu una funci√≥ `zerosNones` que, donat un `n ‚â• 0`,
  retorni totes les combinacions de `z` zeros i `u` uns tals que `z + u = n`

* Els divisors propis d‚Äôun nombre `n` s√≥n tots els divisors positius de `n` m√©s petits que `n`.
  Feu una funci√≥ `divisors` _eficient_ que retorni tots els divisors propis d'un nombre `n`
  ordenats decreixentment.

---

