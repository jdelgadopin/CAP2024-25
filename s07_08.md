class: center, up

# CAP - T√®cniques de Programaci√≥ amb FOS

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 7 i 8</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# Sessi√≥ 07

---

## T√®cniques de Programaci√≥ amb FOS

En aquest tema veurem t√®cniques de programaci√≥ fortament lligades al fet de tenir _Funcions d'Ordre 
Superior_ (FOS). En alguns casos seran t√®cniques noves, que encara no hem vist, i en alguns casos ens
limitarem a posar nom a t√®cniques que ja hem fet servir en posar exemples dins els dos temes anteriors.

Comen√ßarem per una t√®cnica que ja hem vist quan hem insistit en fer servir el _point-free style_ 
o _Tacit programming_, √©s a dir, en definir funcions a partir de la composici√≥ d'altres funcions. 
En fer servir aquest estil sovint no cal fer expl√≠cits els par√†metres (d'aqu√≠ l'expressi√≥ _point-free_).

Definir funcions fent servir la composici√≥ de funcions s'anomena **_pipelining_**. A Clojure, la funci√≥
`comp`, juntament amb la possibilitat de definir funcions _parcials_ fent servir `partial`, ens 
permet fer servir molt f√†cilment aquesta t√®cnica.

Al [laboratori](https://gebakx.github.io/cap/problemes/first-class.pdf) heu tingut ocasi√≥ de 
practicar el _pipelining_, per exemple:

```Clojure
(def prod-of-evens (comp (partial apply *) (partial filter even?)))

(def scalar-product (comp (partial apply +) (partial map *)))
```


---

## _Pipelining_

Un altre exemple, l'[exercici 4](https://gebakx.github.io/cap/firstClass.html#17) de la sessi√≥ de 
[Funcions _First-Class_](https://gebakx.github.io/cap/firstClass.html) podr√≠em haver-lo resolt
aix√≠:

```Clojure
;; Escriu una funci√≥ que, donat un vector de maps amb les claus :preu i 
;; :quantitat, calculi el total per cada element (preu * quantitat), elimini 
;; els que tinguin un valor total inferior a 100 i sumi tots els totals.

(def exercici4 (comp (partial apply +) 
                     (partial filter #(< 100 %)) 
                     (partial map #(* (:preu %) (:quantitat %)))))
```


De vegades, per√≤, tot i tenint ocasi√≥ de fer servir el _pipelining_ no l'hem utilitzat. Si
recordeu la versi√≥ funcional de l'[algorsime de Kadane](https://jdelgadopin.github.io/CAP2024-25/s03_04.html#27):
```Clojure
(def kadane #(apply max (scanr max0 0 %)))
```
podr√≠em haver-ho definit:
```Clojure
(def kadane (comp (partial apply max) (partial scanr max0 0)))
```
---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Suposem que tenim funcions `f1`,`f2`,...,`fn` amb `k1`,`k2`,..., `kn` par√†metres cada una (`ki` > 0).
Per expressar:

```Clojure
(fn ... (f2 (f1 x ...) ...) ...)
```
Podem fer servir `->`, on es passa com a _primer_ argument el resultat de l'aplicaci√≥ de
la funci√≥ anterior:

```Clojure
  (-> x (f1 ...)  ;; on ... representa els k1-1 arguments restants d'f1
        (f2 ...)  ;; on ... representa els k2-1 arguments restants d'f2
        ...
        (fn ...)) ;; on ... representa els kn-1 arguments restants d'fn
```
Si alguna de les funcions `fi` t√© un sol par√†metre, no cal fer servir par√®ntesi, nom√©s
cal escriure el nom.

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Veiem-ne exemples (fixem-nos que no cal escriure `partial`):

```Clojure
(* (+ (- (/ 2 1) 3) 4 )5)      üëâ 15
(-> 2 (/ 1) (- 3) (+ 4) (* 5)) üëâ 15 

(str (str (str "Aix√≤" " " "√©s" " ") 
          "un" " " "exemple" " " "de") 
     " " "la" " " "macro" " " "->")   üëâ "Aix√≤ √©s un exemple de la macro ->"
(->
 (str "Aix√≤" " " "√©s" " ")
 (str "un" " " "exemple" " " "de")
 (str " " "la" " " "macro" " " "->")) üëâ "Aix√≤ √©s un exemple de la macro ->"
 
(.toUpperCase (first ["pollastre" "xai"]))  üëâ "POLLASTRE"
(-> ["pollastre" "xai"] first .toUpperCase) üëâ "POLLASTRE"
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Seguim amb exemples:

```Clojure
(assoc (assoc (assoc {} :clau1 24) :clau2 36) :clau3 48) 
üëâ {:clau1 24, :clau2 36, :clau3 48}
(-> {}
    (assoc :clau1 24)
    (assoc :clau2 36)
    (assoc :clau3 48)) üëâ {:clau1 24, :clau2 36, :clau3 48}
    
(conj (conj (conj [] 3) 5) 7) üëâ [3 5 7]
(-> []
    (conj 3)
    (conj 5)
    (conj 7)) üëâ [3 5 7]
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-last_ (->>)

Suposem que tenim funcions `f1`,`f2`,...,`fn` amb `k1`,`k2`,..., `kn` par√†metres cada una (`ki` > 0).
Per expressar:

```Clojure
(fn ... (f2 ... (f1 ... x)))
```
Podem fer servir `->>`, on es passa com a _darrer_ argument el resultat de l'aplicaci√≥ de
la funci√≥ anterior:

```Clojure
  (->> x (f1 ...)  ;; on ... representa els k1-1 arguments restants d'f1
         (f2 ...)  ;; on ... representa els k2-1 arguments restants d'f2
         ...
         (fn ...)) ;; on ... representa els kn-1 arguments restants d'fn
```
Si alguna de les funcions `fi` t√© un sol par√†metre, no cal fer servir par√®ntesi, nom√©s
cal escriure el nom.

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-last_ (->>)

Veiem-ne exemples (fixem-nos que no cal escriure `partial`):

```Clojure
(reduce + (map #(* % %) (filter odd? (range 10)))) üëâ 165
(->> (range 10)
     (filter odd?)
     (map #(* % %))
     (reduce +)) üëâ 165
     
(def prod-of-evens (comp (partial apply *) (partial filter even?)))
(defn prod-of-evens' [s]
  (->> s
       (filter even?)
       (apply *)))
(prod-of-evens  (range 1 21)) üëâ 3715891200
(prod-of-evens' (range 1 21)) üëâ 3715891200
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Exercici Recapitulatori

Hi ha una manera interessant d'implementar una cua, que √©s mitjan√ßant dues llistes (_llistes_ perqu√® √©s
poc cost√≥s afegir elements al davant de la llista amb `cons`). Una cont√© part de la cua, i l'altra 
cont√© el que resta de la cua, per√≤ invertit.

```Clojure
;; No Clojure => 
Cua[:a :b :c :d :e] = ((:a :b) (:e :d :c))
```

Feu una funci√≥ `generador_cues`, amb les operacions habituals (`reset`,`push`,`top`,`pop`,
`empty?`, `equal`), que implement una cua d'aquesta manera, fent servir _closures_ i _pipelining_
(sempre que es pugui) a l'hora de definir les operacions.

Un joc de proves podria ser:

```Clojure
(def q (generador_cues)) üëâ #'user/q

```


