class: center, up

# CAP - T√®cniques de Programaci√≥ amb FOS

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Tema 4</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

## T√®cniques de Programaci√≥ amb FOS

En aquest tema veurem t√®cniques de programaci√≥ fortament lligades al fet de tenir _Funcions d'Ordre 
Superior_ (FOS). En alguns casos seran t√®cniques noves, que encara no hem vist, i en alguns casos ens
limitarem a posar nom a t√®cniques que ja hem fet servir en posar exemples dins els dos temes anteriors.

Comen√ßarem per una t√®cnica que ja hem vist quan hem insistit en fer servir el _point-free style_ 
o _Tacit programming_, √©s a dir, en definir funcions a partir de la composici√≥ d'altres funcions. 
En fer servir aquest estil sovint no cal fer expl√≠cits els par√†metres (d'aqu√≠ l'expressi√≥ _point-free_).

Definir funcions fent servir la composici√≥ de funcions s'anomena **_pipelining_**. A Clojure, la funci√≥
`comp`, juntament amb la possibilitat de definir funcions _parcials_ fent servir `partial`, ens 
permet fer servir molt f√†cilment aquesta t√®cnica.

Al [laboratori](https://gebakx.github.io/cap/problemes/first-class.pdf) heu tingut ocasi√≥ de 
practicar el _pipelining_, per exemple:

```Clojure
(def prod-of-evens (comp (partial apply *) (partial filter even?)))

(def scalar-product (comp (partial apply +) (partial map *)))
```


---

## _Pipelining_

Un altre exemple, l'[exercici 4](https://gebakx.github.io/cap/firstClass.html#18) de la sessi√≥ de 
[Funcions _First-Class_](https://gebakx.github.io/cap/firstClass.html) podr√≠em haver-lo resolt
aix√≠:

```Clojure
;; Escriu una funci√≥ que, donat un vector de maps amb les claus :preu i 
;; :quantitat, calculi el total per cada element (preu * quantitat), elimini 
;; els que tinguin un valor total inferior a 100 i sumi tots els totals.

(def exercici4 (comp (partial apply +) 
                     (partial filter #(< 100 %)) 
                     (partial map #(* (:preu %) (:quantitat %)))))
```


De vegades, per√≤, tot i tenint ocasi√≥ de fer servir el _pipelining_ no l'hem utilitzat. Si
recordeu la versi√≥ funcional de l'[algorisme de Kadane](https://jdelgadopin.github.io/CAP2024-25/s03_04.html#27):
```Clojure
(def kadane #(apply max (scanr max0 0 %)))
```
podr√≠em haver-ho definit:
```Clojure
(def kadane (comp (partial apply max) (partial scanr max0 0)))
```
---

##_Pipelining_: El Patr√≥

El mateix concepte de _pipeline_ √©s considerat un patr√≥ de disseny.red[*]

_The Pipeline pattern organizes a series of computational steps so
that each step handles a specific aspect of processing. In Clojure,
this translates well due to its functional programming paradigm that
supports higher-order functions and data immutability._

```Clojure
;; Segons el lloc web font d'aquesta transpar√®ncia...

(defn run-pipeline [data & steps]
  (reduce (fn [d step] (step d)) data steps))
```
Us [sona](https://jdelgadopin.github.io/CAP2024-25/s05_06.html#33)?... √âs for√ßa similar
al `my-comp` que vam definir el tema passat.

```Clojure
(defn my-comp [& funcs]
  "funcs: llista de funcions d'un par√†metre tals que 't√© sentit' composar-les"
  (fn [arg] 
      "arg ha de pert√†nyer al domini de la darrera funci√≥ de funcs"
      (fold #(%1 %2) arg funcs)))
```

.footnote[.red[*] [Pipeline in Clojure](https://softwarepatternslexicon.com/patterns-clojure/behavioral/pipeline/)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Suposem que tenim funcions `f1`,`f2`,...,`fn` amb `k1`,`k2`,..., `kn` par√†metres cada una (`ki` > 0).
Per expressar:

```Clojure
(fn ... (f2 (f1 x ...) ...) ...)
```
Podem fer servir `->`, on es passa com a _primer_ argument el resultat de l'aplicaci√≥ de
la funci√≥ anterior:

```Clojure
  (-> x (f1 ...)  ;; on ... representa els k1-1 arguments restants d'f1
        (f2 ...)  ;; on ... representa els k2-1 arguments restants d'f2
        ...
        (fn ...)) ;; on ... representa els kn-1 arguments restants d'fn
```
Si alguna de les funcions `fi` t√© un sol par√†metre, no cal fer servir par√®ntesi, nom√©s
cal escriure el nom.

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Veiem-ne exemples (fixem-nos que no cal escriure `partial`):

```Clojure
(* (+ (- (/ 2 1) 3) 4 )5)      üëâ 15
(-> 2 (/ 1) (- 3) (+ 4) (* 5)) üëâ 15 

(str (str (str "Aix√≤" " " "√©s" " ") 
          "un" " " "exemple" " " "de") 
     " " "la" " " "macro" " " "->")   üëâ "Aix√≤ √©s un exemple de la macro ->"
(->
 (str "Aix√≤" " " "√©s" " ")
 (str "un" " " "exemple" " " "de")
 (str " " "la" " " "macro" " " "->")) üëâ "Aix√≤ √©s un exemple de la macro ->"
 
(.toUpperCase (first ["pollastre" "xai"]))  üëâ "POLLASTRE"
(-> ["pollastre" "xai"] first .toUpperCase) üëâ "POLLASTRE"
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-first_ (->)

Seguim amb exemples:

```Clojure
(assoc (assoc (assoc {} :clau1 24) :clau2 36) :clau3 48) 
üëâ {:clau1 24, :clau2 36, :clau3 48}
(-> {}
    (assoc :clau1 24)
    (assoc :clau2 36)
    (assoc :clau3 48)) üëâ {:clau1 24, :clau2 36, :clau3 48}
    
(conj (conj (conj [] 3) 5) 7) üëâ [3 5 7]
(-> []
    (conj 3)
    (conj 5)
    (conj 7)) üëâ [3 5 7]
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-last_ (->>)

Suposem que tenim funcions `f1`,`f2`,...,`fn` amb `k1`,`k2`,..., `kn` par√†metres cada una (`ki` > 0).
Per expressar:

```Clojure
(fn ... (f2 ... (f1 ... x)))
```
Podem fer servir `->>`, on es passa com a _darrer_ argument el resultat de l'aplicaci√≥ de
la funci√≥ anterior:

```Clojure
  (->> x (f1 ...)  ;; on ... representa els k1-1 arguments restants d'f1
         (f2 ...)  ;; on ... representa els k2-1 arguments restants d'f2
         ...
         (fn ...)) ;; on ... representa els kn-1 arguments restants d'fn
```
Si alguna de les funcions `fi` t√© un sol par√†metre, no cal fer servir par√®ntesi, nom√©s
cal escriure el nom.

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Les _arrow macros_

Clojure ens proporciona un parell de macros que ens aniran molt b√© per
utilitzar _pipelining_ i fer m√©s llegibles les funcions resultants: Les **_arrow macros _** (**->** i
**->>**). La idea √©s senzilla.red[*]: Convertir una s√®rie de crides imbricades a funci√≥ en
en un flux lineal de crides a funci√≥.

### La macro _thread-last_ (->>)

Veiem-ne exemples (fixem-nos que no cal escriure `partial`):

```Clojure
(reduce + (map #(* % %) (filter odd? (range 10)))) üëâ 165
(->> (range 10)
     (filter odd?)
     (map #(* % %))
     (reduce +)) üëâ 165
     
(def prod-of-evens (comp (partial apply *) (partial filter even?)))
(defn prod-of-evens' [s]
  (->> s
       (filter even?)
       (apply *)))
(prod-of-evens  (range 1 21)) üëâ 3715891200
(prod-of-evens' (range 1 21)) üëâ 3715891200
```

.footnote[.red[*][Font](https://clojure.org/guides/threading_macros)]

---

## _Pipelining_: Exercicis Recapitulatoris

* Considereu una seq√º√®ncia de parells `'[(n1,n2) (n3,n4) ...]` que
  implementa les arestes d'un graf no dirigit (no hi ha arestes
  repetides ni auto-bucles). Feu una funci√≥ `grau` que calculi el grau
  d'un vertex donat. Els vertexos es representen amb nombres.

* Sobre la mateixa representaci√≥ de les arestes d'un graf no dirigit,
  feu ara una funci√≥ `ve√Øns` que retorni els ve√Øns d‚Äôun v√®rtex donat,
  en ordre creixent.

* Donats dos vectors d‚Äôenters `x=(x1,...,xn)` i `y=(y1,...,yn)` de la
  mateixa mida, el seu producte escalar √©s `(apply + (map * x y))`.
  Suposant que podem permutar les coordenades de cada vector de la
  forma que volguem, podem escollir dues permutacions dels dos vectors
  que tinguin producte escalar m√≠nim. Escriviu una funci√≥ `minProd`
  que, donats dos vectors de la mateixa mida, retorni el seu producte
  escalar m√≠nim.
  
* Feu una funci√≥ `zerosNones` que, donat un `n ‚â• 0`,
  retorni totes les combinacions de `z` zeros i `u` uns tals que `z + u = n`

* Els divisors propis d‚Äôun nombre `n` s√≥n tots els divisors positius de `n` m√©s petits que `n`.
  Feu una funci√≥ `divisors` _eficient_ que retorni tots els divisors propis d'un nombre `n`
  ordenats decreixentment.

---

## _Pipelining_

Finalment, feu una ullada a aquest video: **The Power of Function
Composition**, per Conor Hoekstra al congr√©s _Lambda World 2024_, com a m√≠nim fins
el minut **27:30**. 

Tot i que el podeu veure tot, ja que √©s for√ßa
interessant i veureu _en acci√≥_ llenguatges de programaci√≥ que
segurament no coneixeu.

.center[![:scale 90%](figures/lambda2024video.png)]

El podeu trobar a [youtube.com/watch?v=W7fjzdEJnvY](https://www.youtube.com/watch?v=W7fjzdEJnvY)

---

## _Continuation-Passing Style_ (CPS)

A la [Wikipedia](https://en.wikipedia.org/wiki/Continuation-passing_style) diu:

_In functional programming, **continuation-passing style** (CPS) is a
style of programming **in which control is passed explicitly in the form
of a continuation**. This is contrasted with direct style, which is the
usual style of programming. Gerald Jay Sussman and Guy L. Steele, Jr.
coined the phrase in AI Memo 349 (1975)_

Una funci√≥ escrita en CPS requereix un par√†metre addicional: Una
**_continuaci√≥_ expl√≠cita**, que √©s una funci√≥ d'un par√†metre.red[*].

Les funcions en CPS <ins>_no retornen mai_</ins>. Un cop han acabat de calcular el que sigui
que calculin, <ins>_cal invocar la continuaci√≥ amb aquest resultat_</ins>. Per exemple:

```Clojure
;; La funci√≥ identitat, en CPS
(defn identity-cps [x,cont]
  (cont x))
  
(identity-cps "Hola M√≥n!", identity) üëâ "Hola M√≥n!"
(identity-cps "Hola M√≥n!", #(apply str (concat % " Josep"))) üëâ "Hola M√≥n! Josep"
```
.footnote[.red[*Font]: _The Joy of Clojure_, secci√≥ 7.3.4, p. 163]

---

## _Continuation-Passing Style_: Exemples

Veiem alguns exemples una miqueta m√©s interessants que la `identity-cps`:

El factorial:
```Clojure
(defn fact-cps [n cont]
  (if (< n 2)
    (cont 1)
    (recur (dec n) (fn [m]
                     (cont (* n m))))))

(fact-cps  5 identity) üëâ 120
(fact-cps 10 identity) üëâ 3628800
(fact-cps 10 #(/ % 2)) üëâ 1814400
```
El coeficient binomial $\binom{n}{k} = \frac{n!}{k!(n-k)!}$
```Clojure
(defn binomial-coef-cps [n k cont]
  (fact-cps n (fn [factn]
                (fact-cps k 
                    (fn [factk]
                      (fact-cps (- n k) 
                          (fn [factnk] (cont (/ factn (* factk factnk))))))))))
                    
(binomial-coef-cps 7 4 identity) üëâ 35
(binomial-coef-cps 6 3 identity) üëâ 20
```
---

## _Continuation-Passing Style_: Exemples

Sigui $n$ qualsevol natural estrictament positiu. Considereu el proc√©s
seg√ºent: Si $n$ √©s parell, dividiu-lo per dos. Altrament,
multipliqueu-lo per 3 i sumeu-li 1. Quan arribeu a 1, pareu.

Per exemple, comen√ßant en $n=3$, s‚Äôobt√© la seq√º√®ncia de Collatz $S(3):
3,10,5,16,8,4,2,1$. La mida d‚Äôaquesta seq√º√®ncia √©s 7. Des de l‚Äôany 1937 es conjectura que aquest proc√©s acaba per a
qualsevol $n$ inicial, encara que no ho ha sabut demostrar ning√∫. En
aquest problema suposarem que la conjectura √©s certa.

Escriu una funci√≥ `mida-collatz` que, donat un natural $n > 0$, retorni
la mida de la seq√º√®ncia de Collatz corresponent a $n$, √©s a dir, quantes
iteracions del proc√©s descrit m√©s amunt calen per arribar a 1.

.cols5050[
.col1[
```Clojure
(defn mida-collatz [n]
  (if (== n 1) 0
    (let [nxt (if (zero? (mod n 2)) 
                (quot n 2) 
                (inc (* 3 n)))]
      (inc (mida-collatz nxt)))))

(mida-collatz 97)  üëâ 118
(mida-collatz 871) üëâ 178
```
]
.col2[
```Clojure
(defn mida-collatz-cps [n cont]
  (if (== n 1) (cont 0)
    (let [nxt (if (zero? (mod n 2)) 
                (quot n 2) 
                (inc (* 3 n)))]
      (recur nxt (fn [v] 
                   (cont (inc v)))))))

(mida-collatz-cps 97 identity)  üëâ 118
(mida-collatz-cps 871 identity) üëâ 178
```
]]

---

## _Continuation-Passing Style_: Exemples

El CPS pot ser √∫til en cas de voler interrompre l'execuci√≥ d'una funci√≥. 

Veiem un exemple:
Suposem seq√º√®ncies "_multi-nivell_" amb nombres. Per exemple: 
`'(((1)) 2 ((3 4) (5 6) ((((7)))) (((8)) 9) 10))`. Volem fer una funci√≥ que multipliqui
tots els nombres d'aquestes seq√º√®ncies.

Aquesta pot ser una soluci√≥:

```Clojure
(defn producte-seq
  "s √©s una seq√º√®ncia 'multi-nivell' de nombres, o un nombre"
  [s]
  (cond
    (number? s) s
    :else (if (empty? s) 1
              (let [[cap & cua] s
                    prod-cap    (producte-seq cap)
                    prod-cua    (producte-seq cua)]
                (* prod-cap prod-cua)))))
                
(producte-seq '(((1)) 2 ((3 4) (5 6) ((((7)))) (((8)) 9) 10))) üëâ 3628800
(producte-seq '())   üëâ 1
(producte-seq  3 )   üëâ 3
(producte-seq '(10)) üëâ 10
```
Si un dels nombres √©s `0` podr√≠em retornar immediatament, sense procedir amb el
que queda de c√†lcul. Aquesta soluci√≥, per√≤, no ho fa.

---

## _Continuation-Passing Style_: Exemples

Podem passar aquesta funci√≥ a CPS:

```Clojure
(defn producte-seq-cps
  "s √©s una seq√º√®ncia multi-nivell de nombres, o un nombre"
  [s cont]
  (cond
    (number? s) (cont s)
    :else (if (empty? s) (cont 1)
              (let [[cap & cua] s]
                (recur cap (fn [v]
                             (producte-seq-cps cua (fn [w]
                                                     (cont (* v w))))))))))
                                                     
(producte-seq-cps '(((1)) 2 ((3 4) (5 6) ((((7)))) (((8)) 9) 10)) identity)
üëâ 3628800
(producte-seq-cps '() identity)   üëâ 1
(producte-seq-cps  3  identity)   üëâ 3
(producte-seq-cps '(10) identity) üëâ 10
```
Aquesta funci√≥ no fa el que volem, no interromp el c√†lcul si troba un `0`. En canvi, en veiem
la possibilitat, ja que podem invocar la continuaci√≥ `cont` original, la que
es passa en la crida a `producte-seq-cps`, en trobar un `0`, o continuar
l'execuci√≥ en altre cas. En aquest cas no fem distinci√≥...

---

## _Continuation-Passing Style_: Exemples

Haur√≠em de diferenciar aquestes continuacions, l'original i les que continuen el c√†lcul.
Per a aix√≤, fem una funci√≥ auxiliar `go`:

```Clojure
(defn producte-seq-cps
  "s √©s una seq√º√®ncia multi-nivell de nombres, o un nombre"
  [s cont]
  (letfn [(go [s cont']
             (cond
               (number? s) (if (zero? s)
                             (cont 0)    ;; <-- Atenci√≥
                             (cont' s))  ;; <-- Atenci√≥
               :else (if (empty? s) (cont' 1)
                         (let [[cap & cua] s]
                           (recur cap (fn [v]
                                        (go cua (fn [w]
                                                  (cont' (* v w))))))))))]
    (go s cont)))
    
(producte-seq-cps '(((1)) 2 ((3 4) (5 6) ((((7)))) (((8)) 9) 10)) identity)
üëâ 3628800
```

Quan trobem un nombre, si √©s `0` invoquem la continuaci√≥ original, la que fem
servir a la crida original a la funci√≥ `producte-seq-cps`, en altre cas invoquem
la continuaci√≥ de la crida a `go`. Quan fem servir la continuaci√≥ original, tot all√≤
que est√† pendent de resoldre deixa d'estar-ho, senzillament no es fa.

---

## _Continuation-Passing Style_: Exemples

Ara modifiquem les funcions per afegir un `println` cada cop que trobem un nombre:

.cols5050[
.col1[
```Clojure
(producte-seq 
   '(((1)) 2 ((3 4) (5 6) (((7))))))
üëÅÔ∏è 1
üëÅÔ∏è 2
üëÅÔ∏è 3
üëÅÔ∏è 4
üëÅÔ∏è 5
üëÅÔ∏è 6
üëÅÔ∏è 7
üëâ 5040

(producte-seq 
   '(((1)) 2 ((3 0) (5 6) (((7))))))
üëÅÔ∏è 1
üëÅÔ∏è 2
üëÅÔ∏è 3
üëÅÔ∏è 0
üëÅÔ∏è 5
üëÅÔ∏è 6
üëÅÔ∏è 7
üëâ 0
```
]
.col2[
```Clojure
(producte-seq-cps 
   '(((1)) 2 ((3 4) (5 6) (((7)))))
    identity)
üëÅÔ∏è 1
üëÅÔ∏è 2
üëÅÔ∏è 3
üëÅÔ∏è 4
üëÅÔ∏è 5
üëÅÔ∏è 6
üëÅÔ∏è 7
üëâ 5040

(producte-seq-cps 
   '(((1)) 2 ((3 0) (5 6) (((7)))))
    identity)
üëÅÔ∏è 1
üëÅÔ∏è 2
üëÅÔ∏è 3
üëâ 0
```
]]

---

## _Continuation-Passing Style_: Exemples

.cols5050[
.col1[
```Clojure
(defn fibonacci [n]
  (if (< n 2) n
    (+ (fibonacci (dec n)) 
       (fibonacci (- n 2)))))

(fibonacci 10) üëâ 55
(fibonacci 40) üëâ 102334155
```
]
.col2[
```Clojure
(defn fibonacci-cps [n cont]
  (if (< n 2) (cont n)
    (recur (dec n) 
       (fn [fn1] 
         (fibonacci-cps (- n 2) 
            (fn [fn2] 
              (cont (+ fn1 fn2))))))))
               
(fibonacci-cps 10 identity) üëâ 55
(fibonacci-cps 40 identity)
üëâ Execution error (StackOverflowError)
```
]]

Aix√≠ doncs, despr√©s de veure aquests exemples la idea hauria d'estar clara: Fer
expl√≠cit el "_lloc_" on aniran a parar els resultats de tot all√≤ que
es calcula, √©s a dir, en realitat **_fem expl√≠cit el flux de
control del programa_**. All√≤ que anomenem **_continuaci√≥_** no √©s m√©s
que la funci√≥ que rebr√† el resultat del que sigui que calculi la
funci√≥ en q√ºesti√≥, aquella a la que se li ha passat la continuaci√≥ com
a argument.

Cal fixar-se en el detall que **_en CPS totes les invocacions de la continuaci√≥ sempre es
fan en tail position_**. Aix√≤ √©s precisament perqu√® la continuaci√≥ rep el valor final
d'all√≤ que es vol calcular, no cal fer cap proc√©s posterior.

---

## _Continuation-Passing Style_: _Tail Call Optimization_

Aquest estil de programar √©s poc llegible, farrag√≥s i per tant els
programadors _humans_ no l'acostumen a fer servir. El quid de la
q√ºesti√≥, per√≤, √©s que la conversi√≥ de codi _normal_ a codi en CPS es
pot programar, √©s a dir, automatitzar. Aix√≤ fa que el CPS s'hagi fet servir
sobre tot com a representaci√≥ interm√®dia per a eines que han de
manipular codi de manera autom√†tica, p.ex. compiladors.

Malgrat tot, en Clojure tenim un problema... la relaci√≥ entre CPS & TCO.red[*]:

_Every call in CPS is a tail call, and the continuation is explicitly
passed. **Using CPS without tail call optimization (TCO) will cause not
only the constructed continuation to potentially grow during
recursion, but also the call stack. This is usually undesirable**, but
has been used in interesting ways -see the Chicken Scheme compiler. As
CPS and TCO eliminate the concept of an implicit function return,
their combined use can eliminate the need for a run-time stack._

A Clojure podem resoldre-ho quan la crida √©s recursiva final, aleshores podem fer
servir `recur`. Tot i aix√≤, no hi ha manera d'aplicar TCO a la crida a la continuaci√≥,
i ens podem trobar amb un `StackOverflowError`.

.footnote[.red[*] [Font](https://en.wikipedia.org/wiki/Continuation-passing_style)]

---

## _Continuation-Passing Style_: Exercicis Recapitulatoris

* Feu versions CPS de `my-map`, `my-filter`, i `my-reduce`:

```Clojure
(defn my-map [f s]
  (if (empty? s) '()
      (let [[cap & cua] s]
        (cons (f cap) (my-map f cua)))))

(defn my-filter [p s]
  (if (empty? s) '()
      (let [[cap & cua] s]
        (if (p cap)
          (cons cap (my-filter p cua))
          (my-filter p cua)))))

(defn my-reduce [f x0 s]
  (if (empty? s) x0
      (let [[cap & cua] s]
        (recur f (f x0 cap) cua))))
```

fixem-nos, per√≤, que:

```Clojure
(my-reduce     +' 0 (range 1 100000)) üëâ 4999950000
(my-reduce-cps +' 0 (range 1 100000) identity) 
üëâ Execution error (StackOverflowError)
```

---

## _Continuation-Passing Style_

Alguns enlla√ßos interessants:

* [pulley.cps](https://github.com/positronic-solutions/pulley.cps)
  _is part of the pulley collection of libraries. It
  provides a source-to-source compiler for **transforming normal Clojure
  code to Clojure code in Continuation Passing Style (CPS)**, as well as
  runtime support for executing the transformed code._
  
* [Cascade](https://github.com/lilactown/cascade) _is a library of
  continuation-passing, thunk producing versions of many Clojure core
  functions. The goal is to allow essentially unbounded recursion and
  mutual recursion of seq operations. This means that the seq
  operations in this library must not use the call stack. Instead,
  **they use a combination of continuation-passing to ensure that
  operations can always be in the tail position** and trampolining to
  ensure that operations do not use the call stack._
  
* [Rama on Clojure‚Äôs terms, and the magic of continuation-passing style](https://blog.redplanetlabs.com/2024/10/10/rama-on-clojures-terms-and-the-magic-of-continuation-passing-style/)
  (10 d'octubre de 2024) Nathan Marz, Blog Red Planet Labs.

---

## _Continuation-Passing Style_

Si voleu llegir m√©s sobre el _Continuation-Passing Style_ (per√≤ no en Clojure):

.cols5050[
.col1[
![:scale 70%](figures/compiling.jpg)

.small[[Compiling with Continuations](https://doi.org/10.1017/CBO9780511609619)]
]
.col2[
![:scale 85%](figures/essentials.jpg)

.small[[Essentials of Programming Languages 3rd.ed.](https://eopl3.com/) Una de les principals
difer√®ncies entre les tres edicions √©s precisament l'algorisme per transformar codi a CPS]
]
]

---

## Trampolins

Si alguna cosa est√† clara a aquestes al√ßades de curs √©s com d'important es la recursivitat en
la programaci√≥ funcional, i per tant com d'important √©s fer alguna cosa respecte al problema
de l'`StackOverflowError`.

Si tingu√©ssim TCO general, el problema est√† resolt. Fent servir CPS puc passar qualsevol
funci√≥ a una funci√≥ on totes les crides estan en _tail position_. Per√≤ a Clojure no tenim
TCO general.

La possibilitat de fer servir funcions d'ordre superior ens permet afrontar aquest problema
des d'un altre punt de vista: El **_trampolining_**.red[*].

A grans trets, la idea √©s que les funcions no retornin valors, sin√≤ _funcions que retornen valors_.
Aix√≠ no acumulem informaci√≥ a la pila, a canvi de requerir, _grosso modo_, dues crides a funci√≥
per cada crida a funci√≥ que cal fer.

Clojure t√© `trampoline`.red[*]

* Vegeu documentaci√≥ [clojuredocs.org/clojure.core/trampoline](https://clojuredocs.org/clojure.core/trampoline)

* Codi font: [L√≠nia 6730 del codi font de Clojure](https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj)

.footnote[.red[*Font]: _The Joy of Clojure_, secci√≥ 7.3.3, p. 161] 

---

## Trampolins

El codi font de la funci√≥ Clojure √©s:

```Clojure
(defn trampoline
  "trampoline can be used to convert algorithms requiring mutual
  recursion without stack consumption. Calls f with supplied args, if
  any. If f returns a fn, calls that fn with no arguments, and
  continues to repeat, until the return value is not a fn, then
  returns that non-fn value. Note that if you want to return a fn as a
  final value, you must wrap it in some data structure and unpack it
  after trampoline returns."
  {:added "1.0"
   :static true}
  ([f]
     (let [ret (f)]
       (if (fn? ret)
         (recur ret)
         ret)))
  ([f & args]
     (trampoline #(apply f args))))
```

---

## Trampolins

