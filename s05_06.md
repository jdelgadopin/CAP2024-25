class: center, up

# CAP - _Closures_ - Model d'Entorns

![:scale 50%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 5 i 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# Sessió 05

---

## _Closures_: Introducció

### Definició

_In programming languages, a **closure**, also lexical closure or function
closure, is a technique for **implementing lexically scoped name binding
in a language with first-class functions**. Operationally, a closure is
a record storing a **function together with an environment**. The
environment is a mapping associating each free variable of the
function (variables that are used locally, but defined in an enclosing
scope) with the value or reference to which the name was bound when
the closure was created. Unlike a plain function, **a closure allows
the function to access those captured variables through the closure's
copies of their values or references, even when the function is
invoked outside their scope**._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29)]

---

## _Closures_: Introducció

Definim una funció `sumador`:

```Clojure
(defn sumador [n] (fn [x] (+ n x)))
```
Invocar aquesta funció implica retornar una funció:
```Clojure
(def suma_5 (sumador 5))
```
Ara `suma_5` està vinculat a una funció `(fn [x] (+ n x))` amb un nom **_lliure_**, `n`, tot i que:
```Clojure
(suma_5 1000) 👉 1005
(suma_5 -5)   👉 0
(suma_5 25)   👉 30
```
és a dir, `n` té vinculat el valor 5. Així, `n` és lliure respecte a la funció `(fn [x] (+ n x))` 
(`n` no és un paràmetre de la funció, tampoc és local), però aquesta funció, _d'alguna manera_, "sap"
que existeix un lligam entre `n` i el valor `5`.

**On està guardat aquest vincle entre `n` i el valor `5`?**

---

## _Closures_: Introducció

A Clojure la **_visibilitat_** dels diferents símbols ve determinada
pel seu **_context lèxic_** (**_lexical scope_**), i aquest és
fàcilment determinat a partir del _text_ del programa (per això
s'anomena _lèxic_).

En l'exemple de la plana anterior, el context lèxic de `(fn [x] (+ n x))` conté el símbol `n`, i qualsevol
lligam que aquest pugui tenir amb un valor. 

Així, el que ha retornat la funció `sumador` **NO** és només una funció,
és **una funció que ha capturat el seu context lèxic**.

Això és el que anomenarem **_closure_**: <ins>_funció que captura el seu context lèxic_</ins>.

Els paràmetres d'una funció formen part del context lèxic del cos d'una funció, però la definició
de símbols locals fent servir `let` també afegeix símbols al context lèxic del cos del `let`.

```Clojure
(def sumador #(let [n %] (fn [x] (+ n x)))) 👉 #'user/sumador

(def suma_10 (sumador 10)) 👉 #'user/suma_10

(suma_10 50) 👉 60
```

---

# _Closures_: Exemples

Si tenim funcions d'ordre superior podem implementar estructures de dades. 
Perdem en eficiència, però aquest és un exercici, un cop més, en expressivitat.

Veiem un exemple: Estructures associatives. Imaginem que volem crear una 
estructura que em permeti associar claus a valors, i fer cerques sobre aquestes
claus per recuperar els valors associats. Operacions que volem sobre aquesta estructura: `crear`/`cercar`/`afegir`. 

Volem construir una estructura així fent servir _només_ funcions.

```Clojure
(defn crear []
    (fn [_] :default)) ;; retornem una funció que retorna un valor per defecte

(defn cercar [estructura clau]
    (estructura clau))
    
(defn afegir [estructura clau valor]
    (fn [clau']
        (if (= clau' clau)
            valor
            (cercar estructura clau'))))

(let [d (afegir (afegir (afegir (afegir (crear) :a 1) :b 2) :c 3) :d 4)] 
    (cercar d :b)) 👉 2

(let [d (afegir (afegir (afegir (afegir (crear) :a 1) :b 2) :c 3) :d 4)] 
    (cercar d :e)) 👉 :default
```
