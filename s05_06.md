class: center, up

# CAP - _Closures_ - Model d'Entorns

![:scale 40%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 5 i 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# SessiÃ³ 05

---

## _Closures_: IntroducciÃ³

### DefiniciÃ³

_In programming languages, a **closure**, also lexical closure or function
closure, is a technique for **implementing lexically scoped name binding
in a language with first-class functions**. Operationally, a closure is
a record storing a **function together with an environment**. The
environment is a mapping associating each free variable of the
function (variables that are used locally, but defined in an enclosing
scope) with the value or reference to which the name was bound when
the closure was created. Unlike a plain function, **a closure allows
the function to access those captured variables through the closure's
copies of their values or references, even when the function is
invoked outside their scope**._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29)]

---

## _Closures_: IntroducciÃ³

Definim una funciÃ³ `sumador`:

```Clojure
(defn sumador [n] (fn [x] (+ n x)))
```
Invocar aquesta funciÃ³ implica retornar una funciÃ³:
```Clojure
(def suma_5 (sumador 5))
```
Ara `suma_5` estÃ  vinculat a una funciÃ³ `(fn [x] (+ n x))` amb un nom **_lliure_**, `n`, tot i que:
```Clojure
(suma_5 1000) ğŸ‘‰ 1005
(suma_5 -5)   ğŸ‘‰ 0
(suma_5 25)   ğŸ‘‰ 30
```
Ã©s a dir, `n` estÃ  vinculat al valor 5. AixÃ­, `n` Ã©s lliure respecte a la funciÃ³ `(fn [x] (+ n x))` 
(`n` no Ã©s un parÃ metre de la funciÃ³, tampoc Ã©s local), perÃ² aquesta funciÃ³ `suma_5` <ins>_d'alguna manera sap_</ins>
que existeix un lligam entre `n` i el valor `5`.

**D'on treu `suma_5` aquest lligam entre `n` i el valor `5`?**

---

## _Closures_: IntroducciÃ³

A Clojure la **_visibilitat_** dels diferents sÃ­mbols ve determinada
pel seu **_context lÃ¨xic_** (**_lexical scope_**), que Ã©s
fÃ cilment determinat a partir del _text_ del programa (per aixÃ²
s'anomena _lÃ¨xic_).

En l'exemple de la plana anterior, el context lÃ¨xic de `(fn [x] (+ n x))` contÃ© el sÃ­mbol `n`, i qualsevol
lligam que aquest pugui tenir amb un valor. 

AixÃ­, el que ha retornat la funciÃ³ `sumador` **NO** Ã©s _nomÃ©s_ una funciÃ³,
Ã©s **una funciÃ³ que ha capturat el seu context lÃ¨xic**.

AixÃ² Ã©s el que anomenarem <ins>**_closure_**</ins>: <ins>_funciÃ³ que captura el seu context lÃ¨xic_</ins>.

Els parÃ metres d'una funciÃ³ formen part del context lÃ¨xic del cos de la funciÃ³. La definiciÃ³
de sÃ­mbols locals fent servir `let` tambÃ© afegeix sÃ­mbols al context lÃ¨xic del cos del `let`.

```Clojure
(def sumador #(let [n %] (fn [x] (+ n x)))) ğŸ‘‰ #'user/sumador

(def suma_10 (sumador 10)) ğŸ‘‰ #'user/suma_10

(suma_10 50) ğŸ‘‰ 60
```

---

## _Closures_: IntroducciÃ³

Cal entendre bÃ© el concepte de _captura del context lÃ¨xic_, ja que una
funciÃ³ es <ins>**_crea_**</ins> dins un determinat context lÃ¨xic i es
pot <ins>**_cridar_**</ins> (<ins>**_invocar_**</ins>) dins d'altres
contextos lÃ¨xics. Veiem-ne un exemple senzill: En aquest codi,

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) ğŸ‘‰ #'user/foo

(foo) ğŸ‘‰ 1

(let [bar 5] (foo)) ğŸ‘‰ ???
```

Quin valor retorna `(let [bar 5] (foo))`?

---

## _Closures_: IntroducciÃ³

Cal entendre bÃ© el concepte de _captura del context lÃ¨xic_, ja que una
funciÃ³ es <ins>**_crea_**</ins> dins un determinat context lÃ¨xic i es
pot <ins>**_cridar_**</ins> (<ins>**_invocar_**</ins>) dins d'altres
contextos lÃ¨xics. Veiem-ne un exemple senzill: En aquest codi,

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) ğŸ‘‰ #'user/foo

(foo) ğŸ‘‰ 1

(let [bar 5] (foo)) ğŸ‘‰ ???
```

Quin valor retorna `(let [bar 5] (foo))`?

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) ğŸ‘‰ #'user/foo

(foo) ğŸ‘‰ 1

(let [bar 5] (foo)) ğŸ‘‰ 1
```
Ja que el nom `bar` (i el corresponent lligam al valor `1`) capturat
per `foo` Ã©s el que pertany al **_context lÃ¨xic en el moment de
<ins>crear</ins> la funciÃ³_**, no al context lÃ¨xic en el moment de
<ins>_cridar_</ins> la funciÃ³.

---

## _Closures_: Funcions d'ordre superior

Les _closures_ poden **_compartir_** el context lÃ¨xic:

```Clojure
(defn sumador_amb_consulta
  "Retorna dues closures que comparteixen el mateix context lÃ¨xic"
  [n]
  [#(+ % n), #(identity n)])
  
(let [[suma, quÃ¨-val-n] (sumador_amb_consulta 100)]
  (println (suma 100))
  (println (suma 10))
  (quÃ¨-val-n)) ğŸ‘‰ 100
ğŸ‘ï¸ 200
ğŸ‘ï¸ 110
```
Les dues funcions `suma` i `quÃ¨-val-n` han capturat el context lÃ¨xic del moment en que han estat 
<ins>**_creades_**</ins>, dins la invocaciÃ³ de `sumador_amb_consulta`. Aquest context lÃ¨xic, perÃ²,
Ã©s el **_mateix_** per a les dues funcions.


Fixem-nos que aquest context lÃ¨xic capturat provÃ© de parÃ metres de
funcions o bÃ© de noms locals que lliguem amb `let`. AixÃ² implica que
aquests contextos lÃ¨xics sÃ³n **_immutables_**, Ã©s a dir, un cop
lligats els noms a uns valors, no podem modificar aquest lligam. Els
valors lligats als noms capturats estan "_congelats_".

De moment, continuarem explorant les possibilitats de les _closures_
que capturen un context lÃ¨xic immutable...

---

## _Closures_: Estructures associatives amb funcions

Si tenim funcions d'ordre superior podem implementar estructures de dades. 
Perdem en eficiÃ¨ncia, perÃ² aquest Ã©s un exercici, un cop mÃ©s, en expressivitat.

Veiem un exemple: Estructures associatives. Imaginem que volem crear una 
estructura que em permeti associar claus a valors, i fer cerques sobre aquestes
claus per recuperar els valors associats. Operacions que volem sobre aquesta 
estructura: `crear`/`cercar`/`afegir`. 

Volem construir una estructura aixÃ­ fent servir <ins>_nomÃ©s_</ins> funcions.

```Clojure
(defn crear []
    (fn [_] :default)) ;; retornem una funciÃ³ que retorna un valor per defecte

(defn cercar [estructura clau]
    (estructura clau))
    
(defn afegir [estructura [clau valor]]
    (fn [clau']
        (if (= clau' clau)
            valor
            (cercar estructura clau'))))

(def d (reduce afegir (crear) [[:a 1], [:b 2], [:c 3], [:d 4]]))

(cercar d :b) ğŸ‘‰ 2
(cercar d :d) ğŸ‘‰ 4
(cercar d :e) ğŸ‘‰ :default
```
---

## _Closures_: Estructures associatives amb funcions

Podem fer quelcom de similar d'una manera mÃ©s compacta (i mÃ©s difÃ­cil d'entendre ğŸ˜€)


```Clojure
(defn crear
  ([] (crear (fn [_] :default)))
  ([prev]
   (letfn [(afegir [k v]
             (letfn [(cercar [k2]
                       (if (= k k2) v
                           (prev k2)))]
               [cercar, (crear cercar)]))]
     afegir)))
     
(let [ afegir1 (crear)
      [cercar2, afegir2] (afegir1 :a 1)
      [cercar3, afegir3] (afegir2 :b 2)
      [cercar4, afegir4] (afegir3 :c 3)
      [cercar5, afegir5] (afegir4 :d 4)]
  (println (cercar5 :a))
  (println (cercar5 :c))
  (println (cercar5 :b))
  (println (cercar5 :d))
  (println (cercar3 :c))) ğŸ‘‰ nil
ğŸ‘ï¸ 1
ğŸ‘ï¸ 3
ğŸ‘ï¸ 2
ğŸ‘ï¸ 4
ğŸ‘ï¸ :default

```
---

## _Closures_: Un altre exemple

Veiem un altre exemple: Implementeu `repetits`, que Ã©s una funciÃ³ que retorna
una funciÃ³ per detectar arguments repetits. Com a efecte secundari de
les crides repetides, s'escriu cada argument que s'ha utilitzat abans
en una seqÃ¼Ã¨ncia de crides repetides. Per tant, si un argument
apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
el trobi (diferent del primer cop). La funciÃ³ `detector` forma part
de la implementaciÃ³ de `repetits`, cal determinar com s'utilitza.red[*].
<ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
qualsevol altre colÂ·lecciÃ³_
 
```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
(defn repetits
  [k]
  ??)

(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) ğŸ‘‰ #'user/f
ğŸ‘ï¸ 7
ğŸ‘ï¸ 1
ğŸ‘ï¸ 5
ğŸ‘ï¸ 1
```
.footnote[.red[*] [Font](https://cs61a.org/exam/fa18/mt1/61a-fa18-mt1_sol.pdf)]

---

## _Closures_: Un altre exemple

Veiem un altre exemple: Implementeu `repetits`, que Ã©s una funciÃ³ que retorna
una funciÃ³ per detectar arguments repetits. Com a efecte secundari de
les crides repetides, s'escriu cada argument que s'ha utilitzat abans
en una seqÃ¼Ã¨ncia de crides repetides. Per tant, si un argument
apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
el trobi (diferent del primer cop). La funciÃ³ `detector` forma part
de la implementaciÃ³ de `repetits`, cal determinar com s'utilitza.red[*].
<ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
qualsevol altre colÂ·lecciÃ³_
 
```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
(defn repetits
  [k]
  ((detector (fn [_] false)) k))
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) ğŸ‘‰ #'user/f
ğŸ‘ï¸ 7
ğŸ‘ï¸ 1
ğŸ‘ï¸ 5
ğŸ‘ï¸ 1
```
.footnote[.red[*] [Font](https://cs61a.org/exam/fa18/mt1/61a-fa18-mt1_sol.pdf)]

---

## _Closures_: Un altre exemple

Fixeu-vos que el que retorna la crida repetida a `repetits` tÃ© "_memÃ²ria_" (â€¼)

```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ((detector (fn [_] false)) k))

(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) ğŸ‘‰ #'user/f
ğŸ‘ï¸ 7
ğŸ‘ï¸ 1
ğŸ‘ï¸ 5
ğŸ‘ï¸ 1

(def ff (f 2))     ğŸ‘‰ #'user/ff
ğŸ‘ï¸ 2

(def fff (ff 8))   ğŸ‘‰ #'user/fff

(def ffff (fff 8)) ğŸ‘‰ #'user/ffff
ğŸ‘ï¸ 8

```

---

## _Closures_: Un patrÃ³ d'Ãºs

Aquests dos darrers exemples, la versiÃ³ compacta de `crear` i el `repetits`, tenen un _patrÃ³
comÃº_, freqÃ¼ent en l'Ãºs del retorn de _closures_. Mirem de generalitzar (informalment):

```Clojure
(defn fun 
  [f]
  (letfn [(g [params de g]
            ... crear una nova funciÃ³ nova_f, que inclogui alguna crida a f
            ... crida a (fun nova_f))]
    g))
```

AixÃ² permet anar explotant els diferents contextos lÃ¨xics que s'han anat capturant a mida
que es va cridant la funciÃ³ retornada `g` en diversos estadis del procÃ©s a realitzar. AixÃ­, podem 
anar _emmagatzemant_ informaciÃ³, malgrat la immutabilitat dels contextos capturats.

La crida `(fun nova_f)` en realitat nomÃ©s serveix per donar mÃ©s context a la nova `g` que serÃ 
retornada, a partir de la funciÃ³ `nova_f` que ja fa servir la `f` que s'ha utilitzat com a argument
en la crida anterior.

Estudiem amb detall l'exemple del `repetits`, per ilÂ·lustrar el patrÃ³...

---

## _Closures_: Un patrÃ³ d'Ãºs

```Clojure
;; (repetits 1) en realitat crida a ((detector (fn [_] false)) 1)
;; Pas 1        f1
;;        -------------
(detector (fn [_] false)) â¡ï¸  g1
;; on (g1 1) Ã©s
 (when (f1 1) (println 1))
 (detector #(or (= % 1) (f1 %)))

;; Pas 2           f2
;;        --------------------
(detector #(or (= % 1) (f1 %))) â¡ï¸  g2
;; on (g2 7) Ã©s (suposem que la segÃ¼ent crida es fa amb 7)
 (when (f2 7) (println 7))
 (detector #(or (= % 7) (f2 %)))
 
;; Pas 3           f3
;;        --------------------
(detector #(or (= % 7) (f2 %))) â¡ï¸  g3
;; on (g3 1) Ã©s (suposem que la segÃ¼ent crida es fa amb 1)
 (when (f3 1) (println 1))
 (detector #(or (= % 1) (f3 %)))
 
;; Pas 4           f4
;;        --------------------
(detector #(or (= % 1) (f3 %))) â¡ï¸  g4
;; on (g4 5) Ã©s (suposem que la segÃ¼ent crida es fa amb 5)
 (when (f4 5) (println 5))
 (detector #(or (= % 5) (f4 %)))
 
;; ...
```

---

## _Closures_: Un patrÃ³ d'Ãºs

Fixem-nos quÃ¨ passa en avaluar les diferents `g` que van apareixen, concretament, en les crides a 
`(fk i)` que determinen si un argument `i` s'escriu o no:

```Clojure
;; Pas 1
(f1 1) = ((fn [_] false) 1) = false  ;; per tant l'1 no s'escriu

;; Pas 2
(f2 7) = (#(or (= % 1) (f1 %)) 7) = (f1 7) = 
                                  = ((fn [_] false) 7) = false
;; per tant el 7 no s'escriu

;; Pas 3
(f3 1) = (#(or (= % 7) (f2 %)) 1) = (f2 1) = 
                                  = (#(or (= % 1) (f1 %)) 1) = true 
;; per tant el 1 sÃ­ s'escriu

;; Pas 4
(f4 5) = (#(or (= % 1) (f3 %)) 5) = (f3 5) = 
                                  = (#(or (= % 7) (f2 %)) 5) = ... = false
;; per tant el 5 no s'escriu

;; ...

``` 
Com que cada `fk` Ã©s un _closure_, ha capturat l'Ãºs de `f{k-1}` i
aixÃ­, _implÃ­citament_, la invocaciÃ³ de totes les funcions que s'han
definit fins el moment, sent capaÃ§ de _memoritzar_ (en els contextos
lÃ¨xics capturats) cada un dels elements que han aparegut.

---

## _Closures_: Divideix i venÃ§


Esperem que estigui clar a hores d'ara que la capacitat de fer
servir funcions d'ordre superior ens permet treballar a nivells
d'abstracciÃ³ mÃ©s "_alts_" dels que podem assolir si no tenim aquesta
capacitat.

Un dels exemples mÃ©s clars d'aixÃ² Ã©s la possibilitat d'"_algorismitzar_" esquemes de
disseny algorÃ­smic. Veiem com passar de l'esquema al programa amb l'esquema de **_Dividir i VÃ¨ncer_**.red[*].

_In computer science, **divide and conquer** is an **algorithm design
paradigm**. A divide-and-conquer algorithm recursively breaks down a
problem into two or more sub-problems of the same or related type,
until these become simple enough to be solved directly. The solutions
to the sub-problems are then combined to give a solution to the
original problem_.

Exemples coneguts de l'aplicaciÃ³ d'aquest esquema sÃ³n: la cerca binÃ ria, Quicksort,
Mergesort, producte rÃ pid de Karatsuba, la multiplicaciÃ³ de matrius de Strassen, l'algorisme de
Cooley-Tukey per calcular la transformada rÃ pida de Fourier, etc.

Anem a veure com transformar aquest esquema, o _design paradigm_, en
un programa. Farem servir el cas mÃ©s senzill, deixem com a
**exercici** la seva generalitzaciÃ³.

.footnote[.red[*] [Font](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm)]

---

## _Closures_: Divideix i venÃ§

Suposem que els valors sobre els que treballarem sÃ³n **vectors**. I suposem tambÃ© que disposem
de les segÃ¼ents quatre funcions: 

* `trivial`: FunciÃ³ que detecta el cas trivial, o cas base, del problema
* `directe`: AcciÃ³ a realitzar en el cas base.
* `dividir`: Si no estem en el cas base, cal dividir el problema en dos sub-problemes.
* `vÃ¨ncer`: AcciÃ³ a realitzar per composar les solucions dels subproblemes.

Aleshores, donat un problema concret sobre vectors pel que hem
definit les funcions anteriors, i l'esquema en forma de programa `dIv`
(encara per definir), el programa per resoldre el problema seria:

```Clojure
(def soluciÃ³ (dIv trivial directe dividir vÃ¨ncer))
```
Concretem-ho amb un exemple clÃ ssic: **Quicksort**

---

## _Closures_: Divideix i venÃ§

Les funcions anteriors pel cas particular del _Quicksort_ podrien ser:

```Clojure
(def trivial #(< (count %) 2)) ;; vector buit o amb un sol element

(def directe identity)         ;; no cal fer res en el cas base

(defn dividir
  "vct tÃ© mÃ©s d'un element"
  [vct]
  (let [[x & rstv] vct         ;; el pivot serÃ  el primer element del vector
        menors (filter #(<= % x) rstv)
        majors (filter #(> % x)  rstv)]
    [menors,majors]))          ;; retornem les dos subvectors

(defn vÃ¨ncer
  "Pel quicksort no ens importa la parella de vectors originals"
  [vct _ [sol1 sol2]]
  (concat sol1 [(first vct)] sol2))  ;; combinem solucions amb el pivot
```
Aleshores...
```Clojure
(def quicksort (dIv trivial directe dividir vÃ¨ncer))

(let [s  (shuffle (range 20))]
   (println s)
   (quicksort s))
ğŸ‘ï¸ [9 6 15 3 2 4 13 5 17 7 11 1 14 12 0 16 18 10 19 8]
ğŸ‘‰ (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)
```

---

## _Closures_: Divideix i venÃ§

Finalment, com Ã©s `dIv`? Naturalment Ã©s una _closure_ on, donades les
funcions mencionades, es retorna una funciÃ³ que nomÃ©s requereix
l'entrada del problema (en aquest cas un vector, o seqÃ¼Ã¨ncia). Com hem
dit abans, aquest Ã©s el cas mÃ©s senzill, on suposem que la
descomposiciÃ³ del problema Ã©s en dos subproblemes:

```Clojure
(defn dIv
  [trivial directe dividir vÃ¨ncer]
  (letfn [(dIv' [vct]
            (if (trivial vct)
              (directe vct)
              (let [[x1 x2] (dividir vct)
                    y1 (dIv' x1)
                    y2 (dIv' x2)]
                (vÃ¨ncer vct [x1,x2] [y1,y2]))))]
    dIv'))
```
Fixem-nos que Ã©s prÃ cticament una _transcripciÃ³ literal_ de l'esquema de _dividir i vÃ¨ncer_ 
que tots coneixem.

Aquest Ã©s un gran exemple de fins a quin punt tenir funcions d'ordre superior pot canviar la nostra
manera de programar.

---

## _Closures_: El model d'entorns

Una manera de copsar aquest mecanisme de captura del context lÃ¨xic Ã©s
mitjanÃ§ant el **_model d'entorns_**<sup>.red[1]</sup>, que ens permet entendre:
__QuÃ¨ passa quan es crida una funciÃ³?__<sup>.red[2]</sup>.

Quan es **_crida_** una funciÃ³ es **_crea un nou entorn_** on s'aparellen els
parÃ metres (formals) i els arguments de la crida a la funciÃ³.
L'aparellament Ã©s posicional si no hi intervenen mecanismes de
_destructuring_, en altre cas l'aparellament ve determinat per l'esquema
de _destructuring_ proporcionat.

Aquest nou entorn creat en cridar la funciÃ³ serÃ  l'entorn on s'ubiquen
els noms nous que apareixen en el cos de la funciÃ³. Aquest entorn nou
s'ha de vincular a l'**_entorn de <ins>creaciÃ³</ins> de la funciÃ³_** (anomenat
**_entorn pare_** del nou entorn creat), que Ã©s on comenÃ§arÃ  la cerca dels
noms _lliures_ que apareixen en el cos de la funciÃ³.

AixÃ­ es crea una **_cadena d'entorns_** que comenÃ§a en l'entorn
pare de la funciÃ³-_closure_ (l'entorn on s'ha _creat_), i Ã©s essencialment
el **_context lÃ¨xic_** que la funciÃ³-_closure_ captura.

.footnote[.red[1] Cal tenir clar que Ã©s un _model_, Ã©s a dir, no Ã©s
una descripciÃ³ acurada de com ho implementa Clojure. Ã‰s
una versiÃ³ simplificada que ens permet entendre quÃ¨ succeeix, sense
entrar en tot detall. 

.red[2] Veure
[SICP](https://web.mit.edu/6.001/6.037/sicp.pdf), capÃ­tol 3 (encara
que s'explica fent servir Scheme) o [Composing
Programs](https://www.composingprograms.com/), seccions 1.3 i 1.6, per
a una explicaciÃ³ fent servir Python (sense mencionar el `let`)]

---

## _Closures_: El model d'entorns

I per quÃ¨ parlem nomÃ©s de les crides a funciÃ³? Per quÃ¨ no parlem dels
contextos lÃ¨xics que es creen en un `let`?

**_Un `let` Ã©s essencialment una sÃ¨rie de crides a funciÃ³_**.

Fer (ignorem el _destructuring_, per simplificar, perÃ² no perdem generalitat)
```Clojure
(let [x1 expr1, x2 expr2, ..., xn exprn] cos-del-let)
```
Ã©s el mateix (en el que pertoca el que estem tractant, poden haver diferÃ¨ncies en aspectes que no sÃ³n importants
ara en aquest context) que:
```Clojure
((fn [x1]
     ((fn [x2]
          ...
          ((fn [xn] cos-del-let) exprn)...) expr2) expr1))
```

**Exercici**: Un `let` podria ser equivalent a: 
```Clojure
((fn [x1, x2, ..., xn] cos-del-let) expr1, expr2, ..., exprn)
```
Per quina raÃ³ NO ho Ã©s?

---

## _Closures_: El model d'entorns

Veiem un exemple no trivial d'aquesta equivalÃ¨ncia entre el `let` i
les crides a funcions. Recordeu la plana
[10](https://jdelgadopin.github.io/CAP2024-25/s05_06.html#10)?

Transformem aquell `let` en crides a funcions:

```Clojure
((fn [afegir1]
   ((fn [[cercar2,afegir2]]
      ((fn [[cercar3,afegir3]]
         ((fn [[cercar4,afegir4]]
            ((fn [[cercar5,afegir5]]
               (println (cercar5 :a))
               (println (cercar5 :c))
               (println (cercar5 :b))
               (println (cercar5 :d))
               (println (cercar3 :c)))
             (afegir4 :d 4)))
          (afegir3 :c 3)))
       (afegir2 :b 2)))
    (afegir1 :a 1)))
 (crear)) ğŸ‘‰ nil
ğŸ‘ï¸ 1
ğŸ‘ï¸ 3
ğŸ‘ï¸ 2
ğŸ‘ï¸ 4
ğŸ‘ï¸ :default
```
---

## _Closures_: El model d'entorns

Veiem un exemple en Python, fent servir el [Python Tutor](https://pythontutor.com):

.cols5050[
.col1[
```Python
from math import sin, cos, pi
def combine_funcs(op):
    def combined(f,g):
        def val(x):
            return op(f(x),g(x))
        return val
    return combined
    
fadd = combine_funcs(lambda x,y: x + y)
h    = fadd(sin, cos)
print(h(pi / 4))
```
```Clojure
(require '[clojure.math :as m])
(defn combine_funcs [op]
  (letfn [(combined [f g]
            (letfn [(val [x] 
                      (op (f x) (g x)))]
               val))]
    combined))

(let [fadd (combine_funcs #(+ %1 %2))
      h    (fadd m/sin m/cos)]
  (println (h (/ m/PI 4))))
```
]
.col2[
![:scale 100%](figures/entorns_exemple.png)
]
]


---

## _Closures_

<br>

I si el context lÃ¨xic contÃ© entitats **_<ins>mutables</ins>_**?

<br>

**_One of the conclusions that we reached was that the "object" need not
be a primitive notion in a programming language; one can build
objects and their behaviour from little more than assignable value
cells and good old lambda expressions._**

Guy Steele, comentant el disseny d'Scheme, citat a [Let Over Lambda](https://letoverlambda.com/)

<br>
I sÃ­, efectivament,

(...) **_assignable value cells and good old lambda expressions_** â¡ï¸ **_Closures_**

---

class: center, middle

# SessiÃ³ 06

---

## _Closures_: Estat mutable en el context lÃ¨xic

Fins ara hem vist _closures_ que capturen un context lÃ¨xic format
per noms de parÃ metres de funcions i per noms definits per
`let` i/o `letfn`. Aquests noms no admeten cap canvi en el seu lligam
a un valor, per tant el context lÃ¨xic estÃ  format per
_lligams (entre noms i valors) immutables_.

Clojure, perÃ², no Ã©s un llenguatge funcional _pur_, com ho pot ser
Haskell. AixÃ­, Ã©s possible que una _closure_ tingui i manipuli entitats
**_mutables_**. La diferÃ¨ncia amb altres llenguatges Ã©s que a
Clojure cal fer-ho **_explÃ­citament_**. Clojure tÃ© varies maneres de
manipular i fer mutable l'estat, fent servir `vars`, `atoms`, `refs` o
`agents`.red[*] (anomenats _reference types_).

`refs` i `agents` tenen un paper molt important a l'hora de gestionar
la concurrÃ¨ncia a Clojure, tema que nosaltres no tractem. Les `vars`
tambÃ© tenen algunes propietats interessants que nosaltres tampoc
veurem en detall, com el fet de tenir _abast dinÃ mic_
(_dynamic scoping_).

El mecanisme que nosaltres farem servir per treballar amb estat
mutable seran els `atoms`. AixÃ­ podrem tenir les _assignable value
cells_ que menciona la cita de Guy Steele a la sessiÃ³ anterior.

.footnote[.red[*] Vegeu [aquest](https://clojure-doc.org/articles/language/concurrency_and_parallelism/) article o
el capÃ­tol 10 de _The Joy of Clojure_]

---

## _Closures_: Atoms

Els `atoms`.red[*] a Clojure sÃ³n objectes que "_contenen_" _referÃ¨ncies_ a valors. Quan 
vinculem un nom a un `atom` estem creant un lligam immutable entre el nom i aquest
objecte. La diferÃ¨ncia ara Ã©s que _podem accedir a allÃ² referenciat i modificar aquesta 
referÃ¨ncia_. Fixem-nos que aixÃ² no afecta la immutabilitat del lligam entre el nom i
l'objecte que "_contÃ©_" aquesta referÃ¨ncia.

Les funcions principals que farem servir sÃ³n `atom`, la _read-macro_ `@` (alternativa a `deref`),
`swap!`, `reset!`.

```Clojure
(def nom_atom (atom 0)) ğŸ‘‰ #'user/nom_atom

(deref nom_atom ) ğŸ‘‰ 0
@nom_atom         ğŸ‘‰ 0

(swap! nom_atom #(+ % 10)) ğŸ‘‰ 10
@nom_atom                  ğŸ‘‰ 10

(reset! nom_atom 5) ğŸ‘‰ 5
@nom_atom           ğŸ‘‰ 5
```
Els `atoms` poden tenir _validators_ (funcions associades que controlen
que els valors referenciats compleixin uns determinats requeriments), perÃ² no en farem
gaire Ãºs.

.footnote[.red[*] Vegeu la secciÃ³ 10.4 de _The Joy of Clojure_ ]

---

## _Closures_: Atoms

.cols5050[
.col1[GrÃ ficament:]
.col2[
![:scale 80%](figures/atoms.png)
]]

* `(atom valor)` - crea un `atom` amb una referÃ¨ncia al `valor` proporcionat

* `(deref nom_atom)` - retorna el valor referenciat per l'objecte vinculat a `nom_atom` (`@nom_atom` Ã©s el mateix que `(deref nom_atom)`)

* `(reset! nom_atom valor)` - fa que `valor` sigui referenciat per l'objecte vinculat a `nom_atom`

* `(swap! nom_atom f x y & args)` - `f` ha de ser <ins>_pura_</ins>. Retorna el nou valor.

|        versiÃ³ de `swap!`        | fa que el nou valor de `nom_atom` sigui |
|---------------------------------|-----------------------------------------| 
| `(swap! nom_atom f)`            | `(apply f ( @nom_atom ))`
| `(swap! nom_atom f x)`          | `(apply f @nom_atom ( x ))`
| `(swap! nom_atom f x y)`        | `(apply f @nom_atom x ( y ))`
| `(swap! nom_atom f x y & args)` | `(apply f @nom_atom x y args)`

---

## _Closures_: Objectes

Tornem a les _closures_...

En el moment que podem tenir `atoms` com a part del context lÃ¨xic capturat per una
_closure_ ja podem tenir un "_estat intern_" mutable del que treure'n profit:

```Clojure
(def comptador-funcs (let [comptador (atom 0)] [#(identity @comptador)
                                                #(reset! comptador 0)
                                                #(swap! comptador + %) 
                                                #(swap! comptador - %)]))
(def consulta   (get comptador-funcs 0)) ğŸ‘‰ #'user/consulta
(def reset      (get comptador-funcs 1)) ğŸ‘‰ #'user/reset
(def incrementa (get comptador-funcs 2)) ğŸ‘‰ #'user/incrementa
(def decrementa (get comptador-funcs 3)) ğŸ‘‰ #'user/decrementa

(reset)        ğŸ‘‰ 0
(incrementa 3) ğŸ‘‰ 3
(incrementa 3) ğŸ‘‰ 6
(incrementa 5) ğŸ‘‰ 11
(consulta)     ğŸ‘‰ 11
(decrementa 9) ğŸ‘‰ 2
(consulta)     ğŸ‘‰ 2
```
Vinculem a `comptador-funcs` un vector amb quatre _closures_. Les quatre _closures_ han capturat
el **mateix** context lÃ¨xic, en aquest cas l'`atom` anomenat `comptador`.

---

## _Closures_: Objectes

**Exercici**: Donades aquestes dues funcions, expliqueu per quÃ¨ s'observa el que s'observa en executar-les:
.cols5050[
.col1[
```Clojure
(defn codi-a []
 (let [res (atom [])
       estat (atom 0)]
   (loop [i 1]
     (if (> i 3)  @res
       (do
         (swap! estat (fn [_] i))
         (swap! res
          #(conj % 
            (fn [] (println @estat))))
         (recur (inc i)))))))
```
]
.col2[
```Clojure
(defn codi-b []
 (let [res (atom [])]
   (loop [i 1]
     (let [estat (atom 0)]
       (if (> i 3)  @res
         (do
           (swap! estat (fn [_] i))
           (swap! res
            #(conj % 
              (fn [] (println @estat))))
           (recur (inc i))))))))
```
]]

```Clojure
(def c-a (codi-a)) ğŸ‘‰  #'user/c-a             (def c-b (codi-b)) ğŸ‘‰  #'user/c-b

;; Executem c-a...              ...i c-b

((c-a 0)) ğŸ‘‰ nil                  ((c-b 0)) ğŸ‘‰ nil
ğŸ‘ï¸ 3                              ğŸ‘ï¸ 1
((c-a 1)) ğŸ‘‰ nil                  ((c-b 1)) ğŸ‘‰ nil
ğŸ‘ï¸ 3                              ğŸ‘ï¸ 2
((c-a 2)) ğŸ‘‰ nil                  ((c-b 2)) ğŸ‘‰ nil
ğŸ‘ï¸ 3                              ğŸ‘ï¸ 3
```


---

## _Closures_: Estructures de dades

Que diverses _closures_ puguin capturar i compartir entitats mutables Ã©s una idea molt potent. De fet,
res ens allunya del concepte clÃ ssic d'_objecte_, no en el sentit d'_instÃ ncia d'una classe_, sinÃ² en el sentit
d'un _estat_ mutable i **_privat_** al que nomÃ©s es pot accedir via uns "_mÃ¨todes_" (les _closures_ que comparteixen
aquest _estat_).

Veiem-ne un exemple:

```Clojure
(defn generador_piles
  []
  (let [ed  (let [pila (atom []),
                  mida (atom 0)]
              {:reset    #(do (swap! pila (fn [_] [])) (swap! mida (fn [_] 0))),
               :push     #(do (swap! pila conj %) (swap! mida inc)),
               :top      #(when (> (count @pila) 0) (peek @pila)),
               :pop      #(when (> (count @pila) 0) 
                             (let [r (peek @pila)] 
                               (swap! pila pop) (swap! mida dec) r)),
               :empty?   #(= (count @pila) 0),
               :size     #(identity @mida)
               })]
    (fn [& cmd]
      (let [instr (keyword (first cmd)),
            argum (rest cmd)
            f     (instr ed)]
        (apply f argum)))))
```
---

## _Closures_: Estructures de dades

`generador_piles` retorna una funciÃ³ per manipular un `map` de
parelles _keyword_-_closure_, que alhora capturen i comparteixen dos `atoms`, amb valors
un vector i un enter, per tal de manipular-los amb les
operacions que caracteritzen una pila.

```Clojure
(def p (generador_piles)) ğŸ‘‰ #'user/p
(p 'reset) ğŸ‘‰ 0

(p 'push 2) ğŸ‘‰ 1
(p 'push \t) ğŸ‘‰ 2
(p 'push "hello") ğŸ‘‰ 3

(p 'size) ğŸ‘‰ 3
(p 'empty?) ğŸ‘‰ false 

(p 'top) ğŸ‘‰ "hello"
(p 'pop) ğŸ‘‰ "hello"

(p 'top) ğŸ‘‰ \t
(p 'pop) ğŸ‘‰ \t

(p 'top) ğŸ‘‰ 2
(p 'pop) ğŸ‘‰ 2

(p 'empty?) ğŸ‘‰ true

```
---

class: center, middle

# _Closures_: Altres exemples

---

## _Closures_: ComposiciÃ³ de funcions

Tot i que tenim `comp` a Clojure, tenint _closures_ en realitat no ens
cal. 

Veiem un exemple senzill, on fem una funciÃ³ `my-comp` per
composar funcions amb una seqÃ¼Ã¨ncia com a parÃ metre i que retornen una
seqÃ¼Ã¨ncia:

```Clojure
(defn my-comp [& funcs]
  "funcs Ã©s una colÂ·lecciÃ³ de funcions f tals que f: seqÃ¼Ã¨ncia -> seqÃ¼Ã¨ncia"
  (fn [arg] (fold #(%1 %2) arg funcs)))  ;; recordeu el fold?
        
(def foo (my-comp reverse sort (partial map #(* 2 %)) (partial filter even?))) 
ğŸ‘‰ #'user/foo
(foo (range 20)) ğŸ‘‰ (36 32 28 24 20 16 12 8 4 0)

((my-comp reverse) (range 10)) ğŸ‘‰ (9 8 7 6 5 4 3 2 1 0)

((my-comp) (range 20)) ğŸ‘‰ (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)

```

Ã’bviament un `my-comp` general requeriria una implementaciÃ³ mÃ©s sofisticada.

---

## _Closures_: Iteradors

```Clojure

```

---

## _Closures_: Decoradors

```Clojure

```

---

## _Closures_

<br>

I fins aquÃ­. 

Teniu mÃ©s exemples com a [exercicis](https://gebakx.github.io/cap/clausures.html#1) de laboratori.



