class: center, up

# CAP - _Closures_ - Model d'Entorns

![:scale 50%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 5 i 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# Sessi贸 05

---

## _Closures_: Introducci贸

### Definici贸

_In programming languages, a **closure**, also lexical closure or function
closure, is a technique for **implementing lexically scoped name binding
in a language with first-class functions**. Operationally, a closure is
a record storing a **function together with an environment**. The
environment is a mapping associating each free variable of the
function (variables that are used locally, but defined in an enclosing
scope) with the value or reference to which the name was bound when
the closure was created. Unlike a plain function, **a closure allows
the function to access those captured variables through the closure's
copies of their values or references, even when the function is
invoked outside their scope**._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29)]

---

## _Closures_: Introducci贸

Definim una funci贸 `sumador`:

```Clojure
(defn sumador [n] (fn [x] (+ n x)))
```
Invocar aquesta funci贸 implica retornar una funci贸:
```Clojure
(def suma_5 (sumador 5))
```
Ara `suma_5` est vinculat a una funci贸 `(fn [x] (+ n x))` amb un nom **_lliure_**, `n`, tot i que:
```Clojure
(suma_5 1000)  1005
(suma_5 -5)    0
(suma_5 25)    30
```
茅s a dir, `n` t茅 vinculat el valor 5. Aix铆, `n` 茅s lliure respecte a la funci贸 `(fn [x] (+ n x))` 
(`n` no 茅s un parmetre de la funci贸, tampoc 茅s local), per貌 aquesta funci贸, _d'alguna manera_, "sap"
que existeix un lligam entre `n` i el valor `5`.

**On est guardat aquest vincle entre `n` i el valor `5`?**

---

## _Closures_: Introducci贸

A Clojure la **_visibilitat_** dels diferents s铆mbols ve determinada
pel seu **_context l猫xic_** (**_lexical scope_**), i aquest 茅s
fcilment determinat a partir del _text_ del programa (per aix貌
s'anomena _l猫xic_).

En l'exemple de la plana anterior, el context l猫xic de `(fn [x] (+ n x))` cont茅 el s铆mbol `n`, i qualsevol
lligam que aquest pugui tenir amb un valor. 

Aix铆, el que ha retornat la funci贸 `sumador` **NO** 茅s nom茅s una funci贸,
茅s **una funci贸 que ha capturat el seu context l猫xic**.

Aix貌 茅s el que anomenarem **_closure_**: <ins>_funci贸 que captura el seu context l猫xic_</ins>.

Els parmetres d'una funci贸 formen part del context l猫xic del cos d'una funci贸, per貌 la definici贸
de s铆mbols locals fent servir `let` tamb茅 afegeix s铆mbols al context l猫xic del cos del `let`.

```Clojure
(def sumador #(let [n %] (fn [x] (+ n x))))  #'user/sumador

(def suma_10 (sumador 10))  #'user/suma_10

(suma_10 50)  60
```

---

# _Closures_: Exemples

Si tenim funcions d'ordre superior podem implementar estructures de dades. 
Perdem en efici猫ncia, per貌 aquest 茅s un exercici, un cop m茅s, en expressivitat.

Veiem un exemple: Estructures associatives. Imaginem que volem crear una 
estructura que em permeti associar claus a valors, i fer cerques sobre aquestes
claus per recuperar els valors associats. Operacions que volem sobre aquesta estructura: `crear`/`cercar`/`afegir`. 

Volem construir una estructura aix铆 fent servir _nom茅s_ funcions.

```Clojure
(defn crear []
    (fn [_] :default)) ;; retornem una funci贸 que retorna un valor per defecte

(defn cercar [estructura clau]
    (estructura clau))
    
(defn afegir [estructura clau valor]
    (fn [clau']
        (if (= clau' clau)
            valor
            (cercar estructura clau'))))

(let [d (afegir (afegir (afegir (afegir (crear) :a 1) :b 2) :c 3) :d 4)] 
    (cercar d :b))  2

(let [d (afegir (afegir (afegir (afegir (crear) :a 1) :b 2) :c 3) :d 4)] 
    (cercar d :e))  :default
```
