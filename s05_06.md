class: center, up

# CAP - _Closures_ - Model d'Entorns

![:scale 50%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 5 i 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# SessiÃ³ 05

---

## _Closures_: IntroducciÃ³

### DefiniciÃ³

_In programming languages, a **closure**, also lexical closure or function
closure, is a technique for **implementing lexically scoped name binding
in a language with first-class functions**. Operationally, a closure is
a record storing a **function together with an environment**. The
environment is a mapping associating each free variable of the
function (variables that are used locally, but defined in an enclosing
scope) with the value or reference to which the name was bound when
the closure was created. Unlike a plain function, **a closure allows
the function to access those captured variables through the closure's
copies of their values or references, even when the function is
invoked outside their scope**._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29)]

---

## _Closures_: IntroducciÃ³

Definim una funciÃ³ `sumador`:

```Clojure
(defn sumador [n] (fn [x] (+ n x)))
```
Invocar aquesta funciÃ³ implica retornar una funciÃ³:
```Clojure
(def suma_5 (sumador 5))
```
Ara `suma_5` estÃ  vinculat a una funciÃ³ `(fn [x] (+ n x))` amb un nom **_lliure_**, `n`, tot i que:
```Clojure
(suma_5 1000) ğŸ‘‰ 1005
(suma_5 -5)   ğŸ‘‰ 0
(suma_5 25)   ğŸ‘‰ 30
```
Ã©s a dir, `n` estÃ  vinculat al valor 5. AixÃ­, `n` Ã©s lliure respecte a la funciÃ³ `(fn [x] (+ n x))` 
(`n` no Ã©s un parÃ metre de la funciÃ³, tampoc Ã©s local), perÃ² aquesta funciÃ³, _d'alguna manera_, "sap"
que existeix un lligam entre `n` i el valor `5`.

**On estÃ  guardat aquest vincle entre `n` i el valor `5`?**

---

## _Closures_: IntroducciÃ³

A Clojure la **_visibilitat_** dels diferents sÃ­mbols ve determinada
pel seu **_context lÃ¨xic_** (**_lexical scope_**), i aquest Ã©s
fÃ cilment determinat a partir del _text_ del programa (per aixÃ²
s'anomena _lÃ¨xic_).

En l'exemple de la plana anterior, el context lÃ¨xic de `(fn [x] (+ n x))` contÃ© el sÃ­mbol `n`, i qualsevol
lligam que aquest pugui tenir amb un valor. 

AixÃ­, el que ha retornat la funciÃ³ `sumador` **NO** Ã©s _nomÃ©s_ una funciÃ³,
Ã©s **una funciÃ³ que ha capturat el seu context lÃ¨xic**.

AixÃ² Ã©s el que anomenarem **_closure_**: <ins>_funciÃ³ que captura el seu context lÃ¨xic_</ins>.

Els parÃ metres d'una funciÃ³ formen part del context lÃ¨xic del cos de la funciÃ³. La definiciÃ³
de sÃ­mbols locals fent servir `let` tambÃ© afegeix sÃ­mbols al context lÃ¨xic del cos del `let`.

```Clojure
(def sumador #(let [n %] (fn [x] (+ n x)))) ğŸ‘‰ #'user/sumador

(def suma_10 (sumador 10)) ğŸ‘‰ #'user/suma_10

(suma_10 50) ğŸ‘‰ 60
```

---

## _Closures_: IntroducciÃ³

Cal entendre bÃ© el concepte de _captura del context lÃ¨xic_. Veiem-ne un exemple senzill:
En aquest codi:

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) ğŸ‘‰ #'user/foo

(foo) ğŸ‘‰ 1

(let [bar 5] (foo)) ğŸ‘‰ ???
```

Quin valor retorna `(let [bar 5] (foo))`?

---

## _Closures_: IntroducciÃ³

Cal entendre bÃ© el concepte de _captura del context lÃ¨xic_. Veiem-ne un exemple senzill:
En aquest codi:

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) ğŸ‘‰ #'user/foo

(foo) ğŸ‘‰ 1

(let [bar 5] (foo)) ğŸ‘‰ ???
```

Quin valor retorna `(let [bar 5] (foo))`?

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) ğŸ‘‰ #'user/foo

(foo) ğŸ‘‰ 1

(let [bar 5] (foo)) ğŸ‘‰ 1
```
Ja que el nom `bar` (i el corresponent lligam al valor `1`) capturat
per `foo` Ã©s el que pertany al seu context lÃ¨xic, i aquest Ã©s **_el
context lÃ¨xic del moment de <ins>crear</ins> la funciÃ³_**, no el context
lÃ¨xic del moment de <ins>_cridar_</ins> la funciÃ³.

---

## _Closures_: Funcions d'ordre superior

<br>

Al tema de [Funcions _First Class_](https://jdelgadopin.github.io/CAP2024-25/s03_04.html) hem parlat
de _Funcions d'Ordre Superior_ en general, perÃ² nomÃ©s les hem fet servir com a argument d'altres
funcions.

<br>

AixÃ² ha estat _deliberat_: **Les funcions en Clojure sÃ³n realment _closures_**. Quan definim
funcions amb altres funcions com a parÃ metre podem ignorar aquest fet, ja que les funcions amb les 
que hem treballat fins ara sÃ³n essencialment pures (tret d'algun `println` que hem fet servir).

<br>

Sense sortir del tema de _Funcions d'Ordre Superior_, volem posar Ã¨mfasi en el fet que **_les 
funcions poden retornar funcions_**. I aquÃ­ ja no podem passar per alt el fet que les funcions sÃ³n en
realitat _closures_. Veieu l'exemple del `sumador` a la plana anterior.

---

## _Closures_: Funcions d'ordre superior

Les _closures_ poden **_compartir_** el context lÃ¨xic:

```Clojure
(defn sumador_amb_consulta
  "Retorna dues closures que comparteixen el mateix context lÃ¨xic"
  [n]
  [#(+ % n), #(identity n)])
  
(let [[suma, quÃ¨-val-n] (sumador_amb_consulta 100)]
  (println (suma 100))
  (println (suma 10))
  (quÃ¨-val-n)) ğŸ‘‰ 100
ğŸ‘ï¸ 200
ğŸ‘ï¸ 110
```

Fixem-nos que aquest context lÃ¨xic capturat provÃ© de parÃ metres de
funcions o bÃ© de noms locals que lliguem amb `let`. AixÃ² implica que
aquests contextos lÃ¨xics sÃ³n **_immutables_**, Ã©s a dir, un cop
lligats els noms a uns valors, no podem modificar aquest lligam. Els
valors lligats als noms capturats estan "_congelats_".

De moment, continuarem explorant les possibilitats de les _closures_
que capturen un context lÃ¨xic immutable...

---

## _Closures_: Estructures associatives amb funcions

Si tenim funcions d'ordre superior podem implementar estructures de dades. 
Perdem en eficiÃ¨ncia, perÃ² aquest Ã©s un exercici, un cop mÃ©s, en expressivitat.

Veiem un exemple: Estructures associatives. Imaginem que volem crear una 
estructura que em permeti associar claus a valors, i fer cerques sobre aquestes
claus per recuperar els valors associats. Operacions que volem sobre aquesta 
estructura: `crear`/`cercar`/`afegir`. 

Volem construir una estructura aixÃ­ fent servir <ins>_nomÃ©s_</ins> funcions.

```Clojure
(defn crear []
    (fn [_] :default)) ;; retornem una funciÃ³ que retorna un valor per defecte

(defn cercar [estructura clau]
    (estructura clau))
    
(defn afegir [estructura [clau valor]]
    (fn [clau']
        (if (= clau' clau)
            valor
            (cercar estructura clau'))))

(def d (reduce afegir (crear) [[:a 1], [:b 2], [:c 3], [:d 4]]))

(cercar d :b) ğŸ‘‰ 2
(cercar d :d) ğŸ‘‰ 4
(cercar d :e) ğŸ‘‰ :default
```
---

## _Closures_: Estructures associatives amb funcions

Podem fer quelcom de similar d'una manera mÃ©s compacta (i mÃ©s difÃ­cil d'entendre ğŸ˜€)


```Clojure
(defn crear
  ([] (crear (fn [_] :default)))
  ([prev]
   (letfn [(afegir [k v]
             (letfn [(cercar [k2]
                       (if (= k k2) v
                           (prev k2)))]
               [cercar, (crear cercar)]))]
     afegir)))
     
(let [ afegir1 (crear)
      [cercar2, afegir2] (afegir1 :a 1)
      [cercar3, afegir3] (afegir2 :b 2)
      [cercar4, afegir4] (afegir3 :c 3)
      [cercar5, afegir5] (afegir4 :d 4)]
  (println (cercar5 :a))
  (println (cercar5 :c))
  (println (cercar5 :b))
  (println (cercar5 :d))
  (println (cercar3 :c))) ğŸ‘‰ nil
ğŸ‘ï¸ 1
ğŸ‘ï¸ 3
ğŸ‘ï¸ 2
ğŸ‘ï¸ 4
ğŸ‘ï¸ :default

```
---

## _Closures_: Un altre exemple

Veiem un altre exemple: Implementeu `repetits`, que Ã©s una funciÃ³ que retorna
una funciÃ³ per detectar arguments repetits. Com a efecte secundari de
les crides repetides, s'escriu cada argument que s'ha utilitzat abans
en una seqÃ¼Ã¨ncia de crides repetides. Per tant, si un argument
apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
el trobi (diferent del primer cop). La funciÃ³ `detector` forma part
de la implementaciÃ³ de `repetits`, cal determinar com s'utilitza.
<ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
qualsevol altre colÂ·lecciÃ³_
 
```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ??)
  
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) ğŸ‘‰ #'user/f
ğŸ‘ï¸ 7
ğŸ‘ï¸ 1
ğŸ‘ï¸ 5
ğŸ‘ï¸ 1

```
---

## _Closures_: Un altre exemple

Veiem un altre exemple: Implementeu `repetits`, que Ã©s una funciÃ³ que retorna
una funciÃ³ per detectar arguments repetits. Com a efecte secundari de
les crides repetides, s'escriu cada argument que s'ha utilitzat abans
en una seqÃ¼Ã¨ncia de crides repetides. Per tant, si un argument
apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
el trobi (diferent del primer cop). La funciÃ³ `detector` forma part
de la implementaciÃ³ de `repetits`, cal determinar com s'utilitza.
<ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
qualsevol altre colÂ·lecciÃ³_
 
```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ((detector (fn [_] false)) k))
  
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) ğŸ‘‰ #'user/f
ğŸ‘ï¸ 7
ğŸ‘ï¸ 1
ğŸ‘ï¸ 5
ğŸ‘ï¸ 1

```
---

## _Closures_: Un altre exemple

Fixeu-vos que el que retorna la crida repetida a `repetits` tÃ© "_memÃ²ria_" (â€¼)

```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ((detector (fn [_] false)) k))

(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) ğŸ‘‰ #'user/f
ğŸ‘ï¸ 7
ğŸ‘ï¸ 1
ğŸ‘ï¸ 5
ğŸ‘ï¸ 1

(def ff (f 2))     ğŸ‘‰ #'user/ff
ğŸ‘ï¸ 2

(def fff (ff 8))   ğŸ‘‰ #'user/fff

(def ffff (fff 8)) ğŸ‘‰ #'user/ffff
ğŸ‘ï¸ 8

```

---

## _Closures_: Un patrÃ³ d'Ãºs

Aquests dos darrers exemples, la versiÃ³ compacta de `crear` i el `repetits`, tenen un _patrÃ³
comÃº_, freqÃ¼ent en l'Ãºs del retorn de _closures_. Mirem de generalitzar (informalment):

```Clojure
(defn fun 
  [f]
  (letfn [(g [params de g]
            ... crear una nova funciÃ³ nova_f, que inclogui alguna crida a f
            ... crida a (fun nova_f))]
    g))
```

AixÃ² permet anar explotant els diferents contextos lÃ¨xics que s'han anat capturant a mida
que es va cridant la funciÃ³ retornada `g` en diversos estadis del procÃ©s a realitzar. AixÃ­, podem 
anar _emmagatzemant_ informaciÃ³, malgrat la immutabilitat dels contextos capturats.

La crida `(fun nova_f)` en realitat nomÃ©s serveix per donar mÃ©s context a la nova `g` que serÃ 
retornada, a partir de la funciÃ³ `nova_f` que ja fa servir la `f` que s'ha utilitzat com a argument
en la crida anterior.

Estudiem amb detall l'exemple del `repetits`, per ilÂ·lustrar el patrÃ³...

---

## _Closures_: Un patrÃ³ d'Ãºs

```Clojure
;; (repetits 1) en realitat crida a ((detector (fn [_] false)) 1)
;; Pas 1        f1
;;        -------------
(detector (fn [_] false)) â¡ï¸  g1
;; on (g1 1) Ã©s
 (when (f1 1) (println 1))
 (detector #(or (= % 1) (f1 %)))

;; Pas 2           f2
;;        --------------------
(detector #(or (= % 1) (f1 %))) â¡ï¸  g2
;; on (g2 7) Ã©s (suposem que la segÃ¼ent crida es fa amb 7)
 (when (f2 7) (println 7))
 (detector #(or (= % 7) (f2 %)))
 
;; Pas 3           f3
;;        --------------------
(detector #(or (= % 7) (f2 %))) â¡ï¸  g3
;; on (g3 1) Ã©s (suposem que la segÃ¼ent crida es fa amb 1)
 (when (f3 1) (println 1))
 (detector #(or (= % 1) (f3 %)))
 
;; Pas 4           f4
;;        --------------------
(detector #(or (= % 1) (f3 %))) â¡ï¸  g4
;; on (g4 5) Ã©s (suposem que la segÃ¼ent crida es fa amb 5)
 (when (f4 5) (println 5))
 (detector #(or (= % 5) (f4 %)))
 
;; ...
```

---

## _Closures_: Un patrÃ³ d'Ãºs

Fixem-nos quÃ¨ passa en avaluar les diferents `g` que van apareixen, concretament, en les crides a 
`(fk i)` que determinen si un argument `i` s'escriu o no:

```Clojure
;; Pas 1
(f1 1) = ((fn [_] false) 1) = false  ;; per tant l'1 no s'escriu

;; Pas 2
(f2 7) = (#(or (= % 1) (f1 %)) 7) = (f1 7) = 
                                  = ((fn [_] false) 7) = false
;; per tant el 7 no s'escriu

;; Pas 3
(f3 1) = (#(or (= % 7) (f2 %)) 1) = (f2 1) = 
                                  = (#(or (= % 1) (f1 %)) 1) = true 
;; per tant el 1 sÃ­ s'escriu

;; Pas 4
(f4 5) = (#(or (= % 1) (f3 %)) 5) = (f3 5) = 
                                  = (#(or (= % 7) (f2 %)) 5) = ... = false
;; per tant el 5 no s'escriu

;; ...

```
Com que cada `fk` Ã©s un _closure_, ha capturat l'Ãºs de `f{k-1}` i aixÃ­, _implÃ­citament_, la
invocaciÃ³ de totes les funcions que s'han definit fins el moment, sent capaÃ§ de _memoritzar_ cada un
dels elements que han aparegut.

---

## _Closures_: El model d'entorns

Una manera de copsar aquest mecanisme de captura del context lÃ¨xic Ã©s mitjanÃ§ant el **_model d'entorns_**.red[*], 
que ens permet entendre: __QuÃ¨ passa quan es crida una funciÃ³?__.





.footnote[.red[*] Cal tenir clar que Ã©s un _model_, Ã©s a dir, no Ã©s una descripciÃ³ acurada del que
fa Clojure a la seva implementaciÃ³. Ã‰s una versiÃ³ simplificada que ens permet entendre quÃ¨ passa, sense entrar 
en tot detall. Veure [SICP](https://web.mit.edu/6.001/6.037/sicp.pdf), capÃ­tol 3 (encara que s'explica fent servir Scheme)
o [Composing Programs](https://www.composingprograms.com/), seccions 1.3 i 1.6, per a una explicaciÃ³ fent servir Python.]

---

## _Closures_

<br><br><br>

**_One of the conclusions that we reached was that the "object" need not
be a primitive notion in a programming language; one can build
objects and their behaviour from little more than assignable value
cells and good old lambda expressions._**

Guy Steele, comentant el disseny d'Scheme, citat a [Let Over Lambda](https://letoverlambda.com/)

<br><br><br>
I sÃ­, efectivament,

(...) **_assignable value cells and good old lambda expressions_** â¡ï¸ **_Closures_**

