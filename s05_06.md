class: center, up

# CAP - _Closures_ - Model d'Entorns

![:scale 50%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 5 i 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# Sessió 05

---

## _Closures_: Introducció

### Definició

_In programming languages, a **closure**, also lexical closure or function
closure, is a technique for **implementing lexically scoped name binding
in a language with first-class functions**. Operationally, a closure is
a record storing a **function together with an environment**. The
environment is a mapping associating each free variable of the
function (variables that are used locally, but defined in an enclosing
scope) with the value or reference to which the name was bound when
the closure was created. Unlike a plain function, **a closure allows
the function to access those captured variables through the closure's
copies of their values or references, even when the function is
invoked outside their scope**._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29)]

---

## _Closures_: Introducció

Definim una funció `sumador`:

```Clojure
(defn sumador [n] (fn [x] (+ n x)))
```
Invocar aquesta funció implica retornar una funció:
```Clojure
(def suma_5 (sumador 5))
```
Ara `suma_5` està vinculat a una funció `(fn [x] (+ n x))` amb un nom **_lliure_**, `n`, tot i que:
```Clojure
(suma_5 1000) 👉 1005
(suma_5 -5)   👉 0
(suma_5 25)   👉 30
```
és a dir, `n` està vinculat al valor 5. Així, `n` és lliure respecte a la funció `(fn [x] (+ n x))` 
(`n` no és un paràmetre de la funció, tampoc és local), però aquesta funció, _d'alguna manera_, "sap"
que existeix un lligam entre `n` i el valor `5`.

**On està guardat aquest vincle entre `n` i el valor `5`?**

---

## _Closures_: Introducció

A Clojure la **_visibilitat_** dels diferents símbols ve determinada
pel seu **_context lèxic_** (**_lexical scope_**), i aquest és
fàcilment determinat a partir del _text_ del programa (per això
s'anomena _lèxic_).

En l'exemple de la plana anterior, el context lèxic de `(fn [x] (+ n x))` conté el símbol `n`, i qualsevol
lligam que aquest pugui tenir amb un valor. 

Així, el que ha retornat la funció `sumador` **NO** és _només_ una funció,
és **una funció que ha capturat el seu context lèxic**.

Això és el que anomenarem **_closure_**: <ins>_funció que captura el seu context lèxic_</ins>.

Els paràmetres d'una funció formen part del context lèxic del cos de la funció. La definició
de símbols locals fent servir `let` també afegeix símbols al context lèxic del cos del `let`.

```Clojure
(def sumador #(let [n %] (fn [x] (+ n x)))) 👉 #'user/sumador

(def suma_10 (sumador 10)) 👉 #'user/suma_10

(suma_10 50) 👉 60
```

---

## _Closures_: Introducció

Cal entendre bé el concepte de _captura del context lèxic_. Veiem-ne un exemple senzill:
En aquest codi:

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) 👉 #'user/foo

(foo) 👉 1

(let [bar 5] (foo)) 👉 ???
```

Quin valor retorna `(let [bar 5] (foo))`?

---

## _Closures_: Introducció

Cal entendre bé el concepte de _captura del context lèxic_. Veiem-ne un exemple senzill:
En aquest codi:

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) 👉 #'user/foo

(foo) 👉 1

(let [bar 5] (foo)) 👉 ???
```

Quin valor retorna `(let [bar 5] (foo))`?

```Clojure
(def foo (let [bar 1] 
           (fn [] bar))) 👉 #'user/foo

(foo) 👉 1

(let [bar 5] (foo)) 👉 1
```
Ja que el nom `bar` (i el corresponent lligam al valor `1`) capturat
per `foo` és el que pertany al seu context lèxic, i aquest és **_el
context lèxic del moment de <ins>crear</ins> la funció_**, no el context
lèxic del moment de <ins>_cridar_</ins> la funció.

---

## _Closures_: Funcions d'ordre superior

<br>

Al tema de [Funcions _First Class_](https://jdelgadopin.github.io/CAP2024-25/s03_04.html) hem parlat
de _Funcions d'Ordre Superior_ en general, però només les hem fet servir com a argument d'altres
funcions.

<br>

Això ha estat _deliberat_: **Les funcions en Clojure són realment _closures_**. Quan definim
funcions amb altres funcions com a paràmetre podem ignorar aquest fet, ja que les funcions amb les 
que hem treballat fins ara són essencialment pures (tret d'algun `println` que hem fet servir).

<br>

Sense sortir del tema de _Funcions d'Ordre Superior_, volem posar èmfasi en el fet que **_les 
funcions poden retornar funcions_**. I aquí ja no podem passar per alt el fet que les funcions són en
realitat _closures_. Veieu l'exemple del `sumador` a la plana anterior.

---

## _Closures_: Funcions d'ordre superior

Les _closures_ poden **_compartir_** el context lèxic:

```Clojure
(defn sumador_amb_consulta
  "Retorna dues closures que comparteixen el mateix context lèxic"
  [n]
  [#(+ % n), #(identity n)])
  
(let [[suma, què-val-n] (sumador_amb_consulta 100)]
  (println (suma 100))
  (println (suma 10))
  (què-val-n)) 👉 100
👁️ 200
👁️ 110
```

Fixem-nos que aquest context lèxic capturat prové de paràmetres de
funcions o bé de noms locals que lliguem amb `let`. Això implica que
aquests contextos lèxics són **_immutables_**, és a dir, un cop
lligats els noms a uns valors, no podem modificar aquest lligam. Els
valors lligats als noms capturats estan "_congelats_".

De moment, continuarem explorant les possibilitats de les _closures_
que capturen un context lèxic immutable...

---

## _Closures_: Estructures associatives amb funcions

Si tenim funcions d'ordre superior podem implementar estructures de dades. 
Perdem en eficiència, però aquest és un exercici, un cop més, en expressivitat.

Veiem un exemple: Estructures associatives. Imaginem que volem crear una 
estructura que em permeti associar claus a valors, i fer cerques sobre aquestes
claus per recuperar els valors associats. Operacions que volem sobre aquesta 
estructura: `crear`/`cercar`/`afegir`. 

Volem construir una estructura així fent servir <ins>_només_</ins> funcions.

```Clojure
(defn crear []
    (fn [_] :default)) ;; retornem una funció que retorna un valor per defecte

(defn cercar [estructura clau]
    (estructura clau))
    
(defn afegir [estructura [clau valor]]
    (fn [clau']
        (if (= clau' clau)
            valor
            (cercar estructura clau'))))

(def d (reduce afegir (crear) [[:a 1], [:b 2], [:c 3], [:d 4]]))

(cercar d :b) 👉 2
(cercar d :d) 👉 4
(cercar d :e) 👉 :default
```
---

## _Closures_: Estructures associatives amb funcions

Podem fer quelcom de similar d'una manera més compacta (i més difícil d'entendre 😀)


```Clojure
(defn crear
  ([] (crear (fn [_] :default)))
  ([prev]
   (letfn [(afegir [k v]
             (letfn [(cercar [k2]
                       (if (= k k2) v
                           (prev k2)))]
               [cercar, (crear cercar)]))]
     afegir)))
     
(let [ afegir1 (crear)
      [cercar2, afegir2] (afegir1 :a 1)
      [cercar3, afegir3] (afegir2 :b 2)
      [cercar4, afegir4] (afegir3 :c 3)
      [cercar5, afegir5] (afegir4 :d 4)]
  (println (cercar5 :a))
  (println (cercar5 :c))
  (println (cercar5 :b))
  (println (cercar5 :d))
  (println (cercar3 :c))) 👉 nil
👁️ 1
👁️ 3
👁️ 2
👁️ 4
👁️ :default

```
---

## _Closures_: Un altre exemple

Veiem un altre exemple: Implementeu `repetits`, que és una funció que retorna
una funció per detectar arguments repetits. Com a efecte secundari de
les crides repetides, s'escriu cada argument que s'ha utilitzat abans
en una seqüència de crides repetides. Per tant, si un argument
apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
el trobi (diferent del primer cop). La funció `detector` forma part
de la implementació de `repetits`, cal determinar com s'utilitza.
<ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
qualsevol altre col·lecció_
 
```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ??)
  
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) 👉 #'user/f
👁️ 7
👁️ 1
👁️ 5
👁️ 1

```
---

## _Closures_: Un altre exemple

Veiem un altre exemple: Implementeu `repetits`, que és una funció que retorna
una funció per detectar arguments repetits. Com a efecte secundari de
les crides repetides, s'escriu cada argument que s'ha utilitzat abans
en una seqüència de crides repetides. Per tant, si un argument
apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
el trobi (diferent del primer cop). La funció `detector` forma part
de la implementació de `repetits`, cal determinar com s'utilitza.
<ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
qualsevol altre col·lecció_
 
```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ((detector (fn [_] false)) k))
  
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) 👉 #'user/f
👁️ 7
👁️ 1
👁️ 5
👁️ 1

```
---

## _Closures_: Un altre exemple

Fixeu-vos que el que retorna la crida repetida a `repetits` té "_memòria_" (‼)

```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (= % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ((detector (fn [_] false)) k))

(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) 👉 #'user/f
👁️ 7
👁️ 1
👁️ 5
👁️ 1

(def ff (f 2))     👉 #'user/ff
👁️ 2

(def fff (ff 8))   👉 #'user/fff

(def ffff (fff 8)) 👉 #'user/ffff
👁️ 8

```

---

## _Closures_: Un patró d'ús

Aquests dos darrers exemples, la versió compacta de `crear` i el `repetits`, tenen un _patró
comú_, freqüent en l'ús del retorn de _closures_. Mirem de generalitzar (informalment):

```Clojure
(defn fun 
  [f]
  (letfn [(g [params de g]
            ... crear una nova funció nova_f, que inclogui alguna crida a f
            ... crida a (fun nova_f))]
    g))
```

Això permet anar explotant els diferents contextos lèxics que s'han anat capturant a mida
que es va cridant la funció retornada `g` en diversos estadis del procés a realitzar. Així, podem 
anar _emmagatzemant_ informació, malgrat la immutabilitat dels contextos capturats.

La crida `(fun nova_f)` en realitat només serveix per donar més context a la nova `g` que serà
retornada, a partir de la funció `nova_f` que ja fa servir la `f` que s'ha utilitzat com a argument
en la crida anterior.

Estudiem amb detall l'exemple del `repetits`, per il·lustrar el patró...

---

## _Closures_: Un patró d'ús

```Clojure
;; (repetits 1) en realitat crida a ((detector (fn [_] false)) 1)
;; Pas 1        f1
;;        -------------
(detector (fn [_] false)) ➡️  g1
;; on (g1 1) és
 (when (f1 1) (println 1))
 (detector #(or (= % 1) (f1 %)))

;; Pas 2           f2
;;        --------------------
(detector #(or (= % 1) (f1 %))) ➡️  g2
;; on (g2 7) és (suposem que la següent crida es fa amb 7)
 (when (f2 7) (println 7))
 (detector #(or (= % 7) (f2 %)))
 
;; Pas 3           f3
;;        --------------------
(detector #(or (= % 7) (f2 %))) ➡️  g3
;; on (g3 1) és (suposem que la següent crida es fa amb 1)
 (when (f3 1) (println 1))
 (detector #(or (= % 1) (f3 %)))
 
;; Pas 4           f4
;;        --------------------
(detector #(or (= % 1) (f3 %))) ➡️  g4
;; on (g4 5) és (suposem que la següent crida es fa amb 5)
 (when (f4 5) (println 5))
 (detector #(or (= % 5) (f4 %)))
 
;; ...
```

---

## _Closures_: Un patró d'ús

Fixem-nos què passa en avaluar les diferents `g` que van apareixen, concretament, en les crides a 
`(fk i)` que determinen si un argument `i` s'escriu o no:

```Clojure
;; Pas 1
(f1 1) = ((fn [_] false) 1) = false  ;; per tant l'1 no s'escriu

;; Pas 2
(f2 7) = (#(or (= % 1) (f1 %)) 7) = (f1 7) = 
                                  = ((fn [_] false) 7) = false
;; per tant el 7 no s'escriu

;; Pas 3
(f3 1) = (#(or (= % 7) (f2 %)) 1) = (f2 1) = 
                                  = (#(or (= % 1) (f1 %)) 1) = true 
;; per tant el 1 sí s'escriu

;; Pas 4
(f4 5) = (#(or (= % 1) (f3 %)) 5) = (f3 5) = 
                                  = (#(or (= % 7) (f2 %)) 5) = ... = false
;; per tant el 5 no s'escriu

;; ...

```
Com que cada `fk` és un _closure_, ha capturat l'ús de `f{k-1}` i així, _implícitament_, la
invocació de totes les funcions que s'han definit fins el moment, sent capaç de _memoritzar_ cada un
dels elements que han aparegut.

---

## _Closures_: El model d'entorns

Una manera de copsar aquest mecanisme de captura del context lèxic és mitjançant el **_model d'entorns_**.red[*], 
que ens permet entendre: __Què passa quan es crida una funció?__.





.footnote[.red[*] Cal tenir clar que és un _model_, és a dir, no és una descripció acurada del que
fa Clojure a la seva implementació. És una versió simplificada que ens permet entendre què passa, sense entrar 
en tot detall. Veure [SICP](https://web.mit.edu/6.001/6.037/sicp.pdf), capítol 3 (encara que s'explica fent servir Scheme)
o [Composing Programs](https://www.composingprograms.com/), seccions 1.3 i 1.6, per a una explicació fent servir Python.]

---

## _Closures_

<br><br><br>

**_One of the conclusions that we reached was that the "object" need not
be a primitive notion in a programming language; one can build
objects and their behaviour from little more than assignable value
cells and good old lambda expressions._**

Guy Steele, comentant el disseny d'Scheme, citat a [Let Over Lambda](https://letoverlambda.com/)

<br><br><br>
I sí, efectivament,

(...) **_assignable value cells and good old lambda expressions_** ➡️ **_Closures_**

