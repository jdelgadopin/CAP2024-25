class: center, up

# CAP - _Closures_ - Model d'Entorns

![:scale 50%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 5 i 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# Sessió 05

---

## _Closures_: Introducció

### Definició

_In programming languages, a **closure**, also lexical closure or function
closure, is a technique for **implementing lexically scoped name binding
in a language with first-class functions**. Operationally, a closure is
a record storing a **function together with an environment**. The
environment is a mapping associating each free variable of the
function (variables that are used locally, but defined in an enclosing
scope) with the value or reference to which the name was bound when
the closure was created. Unlike a plain function, **a closure allows
the function to access those captured variables through the closure's
copies of their values or references, even when the function is
invoked outside their scope**._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29)]

---

## _Closures_: Introducció

Definim una funció `sumador`:

```Clojure
(defn sumador [n] (fn [x] (+ n x)))
```
Invocar aquesta funció implica retornar una funció:
```Clojure
(def suma_5 (sumador 5))
```
Ara `suma_5` està vinculat a una funció `(fn [x] (+ n x))` amb un nom **_lliure_**, `n`, tot i que:
```Clojure
(suma_5 1000) 👉 1005
(suma_5 -5)   👉 0
(suma_5 25)   👉 30
```
és a dir, `n` té vinculat el valor 5. Així, `n` és lliure respecte a la funció `(fn [x] (+ n x))` 
(`n` no és un paràmetre de la funció, tampoc és local), però aquesta funció, _d'alguna manera_, "sap"
que existeix un lligam entre `n` i el valor `5`.

**On està guardat aquest vincle entre `n` i el valor `5`?**

---

## _Closures_: Introducció

A Clojure la **_visibilitat_** dels diferents símbols ve determinada
pel seu **_context lèxic_** (**_lexical scope_**), i aquest és
fàcilment determinat a partir del _text_ del programa (per això
s'anomena _lèxic_).

En l'exemple de la plana anterior, el context lèxic de `(fn [x] (+ n x))` conté el símbol `n`, i qualsevol
lligam que aquest pugui tenir amb un valor. 

Així, el que ha retornat la funció `sumador` **NO** és només una funció,
és **una funció que ha capturat el seu context lèxic**.

Això és el que anomenarem **_closure_**: <ins>_funció que captura el seu context lèxic_</ins>.

Els paràmetres d'una funció formen part del context lèxic del cos d'una funció. La definició
de símbols locals fent servir `let` també afegeix símbols al context lèxic del cos del `let`.

```Clojure
(def sumador #(let [n %] (fn [x] (+ n x)))) 👉 #'user/sumador

(def suma_10 (sumador 10)) 👉 #'user/suma_10

(suma_10 50) 👉 60
```
---

## _Closures_: Funcions d'ordre superior

<br>

Al tema de [Funcions _First Class_](https://jdelgadopin.github.io/CAP2024-25/s03_04.html) hem parlat
de _Funcions d'Ordre Superior_ en general, però només les hem fet servir com a argument d'altres
funcions.

<br>

Això ha estat _deliberat_: **Les funcions en Clojure són realment _closures_**. Quan definim
funcions amb altres funcions com a paràmetre podem ignorar aquest fet, ja que les funcions amb les 
que hem treballat fins ara són essencialment pures (tret d'algun `println` que hem fet servir).

<br>

Sense sortir del tema de _Funcions d'Ordre Superior_, volem posar èmfasi en el fet que **_les 
funcions poden retornar funcions_**. I aquí ja no podem passar per alt el fet que les funcions són en
realitat _closures_. Veieu l'exemple del `sumador` a la plana anterior.

---

## _Closures_: Funcions d'ordre superior

Les _closures_ poden **_compartir_** el context lèxic:

```Clojure
(defn sumador_amb_consulta
  "Retorna dues closures que comparteixen el mateix context lèxic"
  [n]
  [#(+ % n), #(identity n)])
  
(let [[suma, que_val_n] (sumador_amb_consulta 100)]
  (println (suma 100))
  (println (suma 10))
  (que_val_n)) 👉 100
👁️ 200
👁️ 110
```

Fixem-nos que aquest context lèxic capturat prové de paràmetres de funcions o bé de noms locals
que lliguem amb `let`.

Aquests contextos lèxics són un **_estat immutable_**, és a dir, un cop lligats els noms a 
uns valors, no podem modificar aquest lligam. Els valors lligats als noms capturats estan
"_congelats_".

---

## _Closures_: Estructures associatives amb funcions

Si tenim funcions d'ordre superior podem implementar estructures de dades. 
Perdem en eficiència, però aquest és un exercici, un cop més, en expressivitat.

Veiem un exemple: Estructures associatives. Imaginem que volem crear una 
estructura que em permeti associar claus a valors, i fer cerques sobre aquestes
claus per recuperar els valors associats. Operacions que volem sobre aquesta 
estructura: `crear`/`cercar`/`afegir`. 

Volem construir una estructura així fent servir <ins>_només_</ins> funcions.

```Clojure
(defn crear []
    (fn [_] :default)) ;; retornem una funció que retorna un valor per defecte

(defn cercar [estructura clau]
    (estructura clau))
    
(defn afegir [estructura [clau valor]]
    (fn [clau']
        (if (= clau' clau)
            valor
            (cercar estructura clau'))))

(def d (reduce afegir (crear) [[:a 1], [:b 2], [:c 3], [:d 4]]))

(cercar d :b) 👉 2
(cercar d :d) 👉 4
(cercar d :e) 👉 :default
```
---

## _Closures_: Estructures associatives amb funcions

Podem fer quelcom de similar d'una manera més compacta (i més difícil d'entendre 😀)


```Clojure
(defn crear
  ([] (crear (fn [_] :default)))
  ([prev]
   (letfn [(afegir [k v]
             (letfn [(cercar [k2]
                       (if (= k k2) v
                           (prev k2)))]
               [cercar, (crear cercar)]))]
     afegir)))


(let [ afegir1 (crear)
      [cercar2, afegir2] (afegir1 "gat" "animal")
      [cercar3, afegir3] (afegir2 "taula" "moble")
      [cercar4, afegir4] (afegir3 "tassa" "estri")
      [cercar5, afegir5] (afegir4 "tesi" "paper")]
  (println (cercar5 "tesi"))
  (println (cercar5 "tassa"))
  (println (cercar5 "taula"))
  (println (cercar5 "gat"))
  (println (cercar3 "tassa"))) 👉 nil
👁️ paper
👁️ estri
👁️ moble
👁️ animal
👁️ :default

```

---

## _Closures_

<br><br><br>

**_One of the conclusions that we reached was that the "object" need not
be a primitive notion in a programming language; one can build
objects and their behaviour from little more than assignable value
cells and good old lambda expressions._**

Guy Steele, comentant el disseny d'Scheme, citat a [Let Over Lambda](https://letoverlambda.com/)

<br><br><br>
I sí, efectivament,

(...) **_assignable value cells and good old lambda expressions_** ➡️ **_Closures_**

---

## _Closures_: Exemples

**Exercici**: Implementeu `repetits`, que és una funció que retorna
 una funció per detectar arguments repetits. Com a efecte secundari de
 les crides repetides, s'escriu cada argument que s'ha utilitzat abans
 en una seqüència de crides repetides. Per tant, si un argument
 apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
 el trobi (diferent del primer cop). La funció `detector` forma part
 de la implementació de `repetits`, cal determinar com s'utilitza.
 <ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
 qualsevol altre col·lecció_
 
 ```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (== % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ??)
  
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) 👉 #'user/f
👁️ 7
👁️ 1
👁️ 5
👁️ 1

 ```
---

## _Closures_: Exemples

**Exercici**: Implementeu `repetits`, que és una funció que retorna
 una funció per detectar arguments repetits. Com a efecte secundari de
 les crides repetides, s'escriu cada argument que s'ha utilitzat abans
 en una seqüència de crides repetides. Per tant, si un argument
 apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
 el trobi (diferent del primer cop). La funció `detector` forma part
 de la implementació de `repetits`, cal determinar com s'utilitza.
 <ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
 qualsevol altre col·lecció_
 
 ```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (== % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ((detector (fn [_] false)) k))
  
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) 👉 #'user/f
👁️ 7
👁️ 1
👁️ 5
👁️ 1

 ```
