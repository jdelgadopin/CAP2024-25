class: center, up

# CAP - _Closures_ - Model d'Entorns

![:scale 50%](figures/clojure_logo.png)

**Jordi Delgado**, **Gerard Escudero**,

.large[**Curs 2024-25**: <ins>Sessions 5 i 6</ins>]

![:scale 40%](figures/fib50anysUPC.png)

---

class: center, middle

# SessiÃ³ 05

---

## _Closures_: IntroducciÃ³

### DefiniciÃ³

_In programming languages, a **closure**, also lexical closure or function
closure, is a technique for **implementing lexically scoped name binding
in a language with first-class functions**. Operationally, a closure is
a record storing a **function together with an environment**. The
environment is a mapping associating each free variable of the
function (variables that are used locally, but defined in an enclosing
scope) with the value or reference to which the name was bound when
the closure was created. Unlike a plain function, **a closure allows
the function to access those captured variables through the closure's
copies of their values or references, even when the function is
invoked outside their scope**._

.tiny[[.red[Font: Wikipedia]](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29)]

---

## _Closures_: IntroducciÃ³

Definim una funciÃ³ `sumador`:

```Clojure
(defn sumador [n] (fn [x] (+ n x)))
```
Invocar aquesta funciÃ³ implica retornar una funciÃ³:
```Clojure
(def suma_5 (sumador 5))
```
Ara `suma_5` estÃ  vinculat a una funciÃ³ `(fn [x] (+ n x))` amb un nom **_lliure_**, `n`, tot i que:
```Clojure
(suma_5 1000) ğŸ‘‰ 1005
(suma_5 -5)   ğŸ‘‰ 0
(suma_5 25)   ğŸ‘‰ 30
```
Ã©s a dir, `n` tÃ© vinculat el valor 5. AixÃ­, `n` Ã©s lliure respecte a la funciÃ³ `(fn [x] (+ n x))` 
(`n` no Ã©s un parÃ metre de la funciÃ³, tampoc Ã©s local), perÃ² aquesta funciÃ³, _d'alguna manera_, "sap"
que existeix un lligam entre `n` i el valor `5`.

**On estÃ  guardat aquest vincle entre `n` i el valor `5`?**

---

## _Closures_: IntroducciÃ³

A Clojure la **_visibilitat_** dels diferents sÃ­mbols ve determinada
pel seu **_context lÃ¨xic_** (**_lexical scope_**), i aquest Ã©s
fÃ cilment determinat a partir del _text_ del programa (per aixÃ²
s'anomena _lÃ¨xic_).

En l'exemple de la plana anterior, el context lÃ¨xic de `(fn [x] (+ n x))` contÃ© el sÃ­mbol `n`, i qualsevol
lligam que aquest pugui tenir amb un valor. 

AixÃ­, el que ha retornat la funciÃ³ `sumador` **NO** Ã©s nomÃ©s una funciÃ³,
Ã©s **una funciÃ³ que ha capturat el seu context lÃ¨xic**.

AixÃ² Ã©s el que anomenarem **_closure_**: <ins>_funciÃ³ que captura el seu context lÃ¨xic_</ins>.

Els parÃ metres d'una funciÃ³ formen part del context lÃ¨xic del cos d'una funciÃ³. La definiciÃ³
de sÃ­mbols locals fent servir `let` tambÃ© afegeix sÃ­mbols al context lÃ¨xic del cos del `let`.

```Clojure
(def sumador #(let [n %] (fn [x] (+ n x)))) ğŸ‘‰ #'user/sumador

(def suma_10 (sumador 10)) ğŸ‘‰ #'user/suma_10

(suma_10 50) ğŸ‘‰ 60
```
---

## _Closures_: Funcions d'ordre superior

<br>

Al tema de [Funcions _First Class_](https://jdelgadopin.github.io/CAP2024-25/s03_04.html) hem parlat
de _Funcions d'Ordre Superior_ en general, perÃ² nomÃ©s les hem fet servir com a argument d'altres
funcions.

<br>

AixÃ² ha estat _deliberat_: **Les funcions en Clojure sÃ³n realment _closures_**. Quan definim
funcions amb altres funcions com a parÃ metre podem ignorar aquest fet, ja que les funcions amb les 
que hem treballat fins ara sÃ³n essencialment pures (tret d'algun `println` que hem fet servir).

<br>

Sense sortir del tema de _Funcions d'Ordre Superior_, volem posar Ã¨mfasi en el fet que **_les 
funcions poden retornar funcions_**. I aquÃ­ ja no podem passar per alt el fet que les funcions sÃ³n en
realitat _closures_. Veieu l'exemple del `sumador` a la plana anterior.

---

## _Closures_: Funcions d'ordre superior

Les _closures_ poden **_compartir_** el context lÃ¨xic:

```Clojure
(defn sumador_amb_consulta
  "Retorna dues closures que comparteixen el mateix context lÃ¨xic"
  [n]
  [#(+ % n), #(identity n)])
  
(let [[suma, que_val_n] (sumador_amb_consulta 100)]
  (println (suma 100))
  (println (suma 10))
  (que_val_n)) ğŸ‘‰ 100
ğŸ‘ï¸ 200
ğŸ‘ï¸ 110
```

Fixem-nos que aquest context lÃ¨xic capturat provÃ© de parÃ metres de funcions o bÃ© de noms locals
que lliguem amb `let`.

Aquests contextos lÃ¨xics sÃ³n un **_estat immutable_**, Ã©s a dir, un cop lligats els noms a 
uns valors, no podem modificar aquest lligam. Els valors lligats als noms capturats estan
"_congelats_".

---

## _Closures_: Estructures associatives amb funcions

Si tenim funcions d'ordre superior podem implementar estructures de dades. 
Perdem en eficiÃ¨ncia, perÃ² aquest Ã©s un exercici, un cop mÃ©s, en expressivitat.

Veiem un exemple: Estructures associatives. Imaginem que volem crear una 
estructura que em permeti associar claus a valors, i fer cerques sobre aquestes
claus per recuperar els valors associats. Operacions que volem sobre aquesta 
estructura: `crear`/`cercar`/`afegir`. 

Volem construir una estructura aixÃ­ fent servir <ins>_nomÃ©s_</ins> funcions.

```Clojure
(defn crear []
    (fn [_] :default)) ;; retornem una funciÃ³ que retorna un valor per defecte

(defn cercar [estructura clau]
    (estructura clau))
    
(defn afegir [estructura [clau valor]]
    (fn [clau']
        (if (= clau' clau)
            valor
            (cercar estructura clau'))))

(def d (reduce afegir (crear) [[:a 1], [:b 2], [:c 3], [:d 4]]))

(cercar d :b) ğŸ‘‰ 2
(cercar d :d) ğŸ‘‰ 4
(cercar d :e) ğŸ‘‰ :default
```
---

## _Closures_: Estructures associatives amb funcions

Podem fer quelcom de similar d'una manera mÃ©s compacta (i mÃ©s difÃ­cil d'entendre ğŸ˜€)


```Clojure
(defn crear
  ([] (crear (fn [_] :default)))
  ([prev]
   (letfn [(afegir [k v]
             (letfn [(cercar [k2]
                       (if (= k k2) v
                           (prev k2)))]
               [cercar, (crear cercar)]))]
     afegir)))


(let [ afegir1 (crear)
      [cercar2, afegir2] (afegir1 "gat" "animal")
      [cercar3, afegir3] (afegir2 "taula" "moble")
      [cercar4, afegir4] (afegir3 "tassa" "estri")
      [cercar5, afegir5] (afegir4 "tesi" "paper")]
  (println (cercar5 "tesi"))
  (println (cercar5 "tassa"))
  (println (cercar5 "taula"))
  (println (cercar5 "gat"))
  (println (cercar3 "tassa"))) ğŸ‘‰ nil
ğŸ‘ï¸ paper
ğŸ‘ï¸ estri
ğŸ‘ï¸ moble
ğŸ‘ï¸ animal
ğŸ‘ï¸ :default

```

---

## _Closures_

<br><br><br>

**_One of the conclusions that we reached was that the "object" need not
be a primitive notion in a programming language; one can build
objects and their behaviour from little more than assignable value
cells and good old lambda expressions._**

Guy Steele, comentant el disseny d'Scheme, citat a [Let Over Lambda](https://letoverlambda.com/)

<br><br><br>
I sÃ­, efectivament,

(...) **_assignable value cells and good old lambda expressions_** â¡ï¸ **_Closures_**

---

## _Closures_: Exemples

**Exercici**: Implementeu `repetits`, que Ã©s una funciÃ³ que retorna
 una funciÃ³ per detectar arguments repetits. Com a efecte secundari de
 les crides repetides, s'escriu cada argument que s'ha utilitzat abans
 en una seqÃ¼Ã¨ncia de crides repetides. Per tant, si un argument
 apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
 el trobi (diferent del primer cop). La funciÃ³ `detector` forma part
 de la implementaciÃ³ de `repetits`, cal determinar com s'utilitza.
 <ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
 qualsevol altre colÂ·lecciÃ³_
 
 ```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (== % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ??)
  
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) ğŸ‘‰ #'user/f
ğŸ‘ï¸ 7
ğŸ‘ï¸ 1
ğŸ‘ï¸ 5
ğŸ‘ï¸ 1

 ```
---

## _Closures_: Exemples

**Exercici**: Implementeu `repetits`, que Ã©s una funciÃ³ que retorna
 una funciÃ³ per detectar arguments repetits. Com a efecte secundari de
 les crides repetides, s'escriu cada argument que s'ha utilitzat abans
 en una seqÃ¼Ã¨ncia de crides repetides. Per tant, si un argument
 apareix $n$ vegades, s'escriu $n - 1$ vegades en total, cada cop que
 el trobi (diferent del primer cop). La funciÃ³ `detector` forma part
 de la implementaciÃ³ de `repetits`, cal determinar com s'utilitza.
 <ins>Important</ins>: _no podeu utilitzar cap llista, conjunt o
 qualsevol altre colÂ·lecciÃ³_
 
 ```Clojure
(defn detector
  [f]
  (letfn [(g [i]
            (when (f i) (println i))
            (detector #(or (== % i) (f %))))]
    g))
  
(defn repetits
  [k]
  ((detector (fn [_] false)) k))
  
  
(def f (((((((((((repetits 1) 7) 7) 3) 4) 2) 5) 1) 6) 5) 1)) ğŸ‘‰ #'user/f
ğŸ‘ï¸ 7
ğŸ‘ï¸ 1
ğŸ‘ï¸ 5
ğŸ‘ï¸ 1

 ```
